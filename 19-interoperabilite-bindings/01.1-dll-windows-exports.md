🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.1 DLL Windows et exports

## Introduction aux DLL Windows

Une **DLL (Dynamic Link Library)** est le format de bibliothèque partagée utilisé par Microsoft Windows. C'est un fichier exécutable (format PE - Portable Executable) qui contient du code, des données et des ressources utilisables par plusieurs programmes simultanément.

### Historique et contexte

Les DLL ont été introduites avec Windows 1.0 en 1985 pour :
- Économiser la mémoire (très limitée à l'époque)
- Partager du code entre applications
- Permettre les mises à jour système sans recompiler les applications

Aujourd'hui, Windows repose massivement sur les DLL :
- `kernel32.dll` : fonctions système de base
- `user32.dll` : interface utilisateur
- `gdi32.dll` : graphiques
- `msvcrt.dll` : runtime C/C++
- Et des milliers d'autres...

### Structure d'une DLL

Une DLL Windows contient plusieurs sections :

```
┌─────────────────────────────────────┐
│         En-tête PE (PE Header)      │  ← Métadonnées du fichier
├─────────────────────────────────────┤
│      Table d'export (Export Table)  │  ← Fonctions disponibles
├─────────────────────────────────────┤
│      Table d'import (Import Table)  │  ← DLL dont elle dépend
├─────────────────────────────────────┤
│         Section .text               │  ← Code exécutable
├─────────────────────────────────────┤
│         Section .data               │  ← Données initialisées
├─────────────────────────────────────┤
│         Section .bss                │  ← Données non initialisées
├─────────────────────────────────────┤
│         Section .rsrc               │  ← Ressources (icônes, etc.)
├─────────────────────────────────────┤
│         Section .reloc              │  ← Relocations
└─────────────────────────────────────┘
```

### Pourquoi créer des DLL avec FreePascal ?

1. **Interopérabilité Windows** : Créer des composants utilisables par n'importe quelle application Windows
2. **Plugins** : Systèmes extensibles (comme les plugins Photoshop, VST audio, etc.)
3. **ActiveX/COM** : Technologies Windows nécessitant des DLL
4. **Wrapping** : Exposer du code Pascal à d'autres langages (C#, VB, Python)
5. **Performance** : Code natif optimisé accessible depuis des langages managés

## Créer votre première DLL

### Structure de base

Voici le squelette minimal d'une DLL en FreePascal :

```pascal
library MaPremiereLib;

{$mode objfpc}{$H+}

uses
  SysUtils;

// Déclaration des fonctions à exporter
function Addition(a, b: Integer): Integer; stdcall;
begin
  Result := a + b;
end;

// Section exports - OBLIGATOIRE pour une DLL
exports
  Addition;

begin
  // Code d'initialisation (optionnel)
end.
```

**Points clés** :
- Le mot-clé `library` au lieu de `program`
- Directive `exports` pour lister les fonctions accessibles
- Convention d'appel `stdcall` (standard Windows)
- Pas de `begin..end` final obligatoire si pas d'initialisation

### Compilation

Pour compiler cette DLL :

```batch
fpc -oMaPremiereLib.dll MaPremiereLib.pas
```

Options utiles :
- `-O3` : optimisation maximale
- `-WG` : génère une application GUI (pas de console)
- `-Xs` : strip symbols (réduction de taille)
- `-XX` : smart linking

**Exemple complet** :
```batch
fpc -oMaPremiereLib.dll -O3 -WG -Xs -XX MaPremiereLib.pas
```

### Utilisation depuis FreePascal

Pour utiliser votre DLL depuis une autre application Pascal :

```pascal
program TestDLL;

{$mode objfpc}{$H+}

// Déclaration de la fonction externe
function Addition(a, b: Integer): Integer; stdcall;
  external 'MaPremiereLib.dll';

var
  resultat: Integer;
begin
  resultat := Addition(10, 32);
  WriteLn('10 + 32 = ', resultat);
  ReadLn;
end.
```

### Utilisation depuis C/C++

La même DLL peut être utilisée depuis C :

```c
// test.c
#include <stdio.h>
#include <windows.h>

// Définition du type de fonction
typedef int (__stdcall *AdditionFunc)(int, int);

int main() {
    // Charger la DLL
    HMODULE dll = LoadLibrary("MaPremiereLib.dll");
    if (dll == NULL) {
        printf("Erreur: impossible de charger la DLL\n");
        return 1;
    }

    // Obtenir l'adresse de la fonction
    AdditionFunc Addition = (AdditionFunc)GetProcAddress(dll, "Addition");
    if (Addition == NULL) {
        printf("Erreur: fonction Addition non trouvée\n");
        FreeLibrary(dll);
        return 1;
    }

    // Utiliser la fonction
    int result = Addition(10, 32);
    printf("10 + 32 = %d\n", result);

    // Libérer la DLL
    FreeLibrary(dll);
    return 0;
}
```

Compilation C :
```batch
gcc test.c -o test.exe
```

## La directive exports

### Syntaxe de base

La directive `exports` liste les symboles (fonctions, procédures, variables) accessibles depuis l'extérieur de la DLL.

```pascal
exports
  Fonction1,
  Fonction2,
  Fonction3;
```

### Export avec alias

Vous pouvez exporter une fonction sous un nom différent :

```pascal
function CalculerSomme(a, b: Integer): Integer; stdcall;
begin
  Result := a + b;
end;

exports
  CalculerSomme name 'Add';  // Exportée sous le nom "Add"
```

Depuis C, vous l'appellerez `Add`, pas `CalculerSomme`.

### Export par index

Windows permet d'exporter par numéro (ordinal) au lieu du nom :

```pascal
exports
  Fonction1 index 1,
  Fonction2 index 2,
  Fonction3 index 3;
```

**Avantages** :
- Légèrement plus rapide (pas de recherche par nom)
- Fichier DLL plus petit (pas de noms stockés)

**Inconvénients** :
- Plus difficile à déboguer
- Fragile (changer l'ordre casse la compatibilité)

**Recommandation** : Utilisez les noms sauf si vous avez une raison spécifique d'utiliser des index.

### Export de variables

On peut aussi exporter des variables globales :

```pascal
var
  CompteurGlobal: Integer = 0;

procedure IncrémenterCompteur; stdcall;
begin
  Inc(CompteurGlobal);
end;

function ObtenirCompteur: Integer; stdcall;
begin
  Result := CompteurGlobal;
end;

exports
  IncrémenterCompteur,
  ObtenirCompteur;
```

**Attention** : Exporter directement des variables est délicat. Il est préférable d'utiliser des fonctions get/set.

## Conventions d'appel sur Windows

Windows supporte plusieurs conventions d'appel. Le choix est crucial pour la compatibilité.

### stdcall (WINAPI)

La convention standard de l'API Windows.

**Caractéristiques** :
- Paramètres passés sur la pile de droite à gauche
- La fonction appelée nettoie la pile
- Noms décorés : `_NomFonction@NombreOctets`

```pascal
function MaFonction(x: Integer; y: Integer): Integer; stdcall;
```

**Name mangling** : `_MaFonction@8` (8 = 2 paramètres × 4 octets)

**Quand l'utiliser** :
- Pour l'API Windows (obligatoire)
- Pour la compatibilité avec VB6, C# P/Invoke
- Pour les callbacks Windows

### cdecl

La convention C standard.

**Caractéristiques** :
- Paramètres passés sur la pile de droite à gauche
- L'appelant nettoie la pile
- Support des fonctions variadiques
- Noms décorés : `_NomFonction`

```pascal
function MaFonction(x: Integer; y: Integer): Integer; cdecl;
```

**Quand l'utiliser** :
- Pour la compatibilité C/C++
- Quand vous avez besoin de fonctions variadiques
- Pour les bibliothèques multi-plateformes

### register (Pascal)

Convention native de Pascal.

**Caractéristiques** :
- Utilise les registres CPU (EAX, EDX, ECX)
- Très efficace
- Non portable vers d'autres langages

```pascal
function MaFonction(x: Integer; y: Integer): Integer; register;
```

**Quand l'utiliser** :
- DLL uniquement pour FreePascal/Delphi
- Performance maximale
- Pas d'interopérabilité requise

### Tableau récapitulatif

| Convention | Nettoyage pile | Variadique | Registres | Décoration | Usage |
|------------|---------------|------------|-----------|------------|-------|
| stdcall | Appelé | Non | Non | Oui | API Windows, VB |
| cdecl | Appelant | Oui | Non | Oui | C/C++, portable |
| register | Appelé | Non | Oui | Oui | Pascal uniquement |

## Gestion de la mémoire dans les DLL

La mémoire est le point le plus délicat lors de l'échange de données entre une DLL et son client.

### Problème du "heap mismatch"

Chaque module (EXE, DLL) peut utiliser son propre gestionnaire de mémoire (heap) :

```
Application.exe                    MaLib.dll
     │                                 │
     ├─ Heap A                         ├─ Heap B
     │   (allocateur FPC)              │   (allocateur FPC)
     │                                 │
```

**Danger** : Si la DLL alloue avec Heap B et l'application libère avec Heap A → **CRASH**

### Solutions

#### Solution 1 : L'appelant alloue le buffer

La méthode la plus sûre.

```pascal
// Dans la DLL
procedure RemplirBuffer(buffer: PByte; taille: Integer); stdcall;
var
  i: Integer;
begin
  if buffer = nil then Exit;
  for i := 0 to taille - 1 do
    buffer[i] := i mod 256;
end;

exports
  RemplirBuffer;
```

Utilisation :
```pascal
// Dans l'application cliente
var
  buffer: array[0..99] of Byte;
begin
  RemplirBuffer(@buffer[0], Length(buffer));
end;
```

**Avantages** :
- Pas de problème de heap
- Simple et sûr

**Inconvénients** :
- Le client doit connaître la taille
- Pas de taille dynamique

#### Solution 2 : Paire allocation/libération

La DLL fournit les deux fonctions.

```pascal
// Allocation dans la DLL
function AllouerDonnees(taille: Integer): Pointer; stdcall;
begin
  GetMem(Result, taille);
end;

// Libération dans la DLL
procedure LibererDonnees(p: Pointer); stdcall;
begin
  FreeMem(p);
end;

exports
  AllouerDonnees,
  LibererDonnees;
```

Utilisation :
```pascal
var
  donnees: Pointer;
begin
  donnees := AllouerDonnees(1024);
  try
    // Utilisation
  finally
    LibererDonnees(donnees);
  end;
end;
```

**Avantages** :
- Taille dynamique
- Pas de heap mismatch

**Inconvénients** :
- Deux fonctions nécessaires
- Le client doit penser à libérer

#### Solution 3 : API Windows (GlobalAlloc/GlobalFree)

Utiliser l'allocateur Windows global.

```pascal
uses
  Windows;

function AllouerDonnees(taille: Integer): Pointer; stdcall;
begin
  Result := GlobalAlloc(GMEM_FIXED, taille);
end;

procedure LibererDonnees(p: Pointer); stdcall;
begin
  GlobalFree(HGLOBAL(p));
end;
```

**Avantages** :
- Compatible avec tous les modules Windows
- Standard pour COM/OLE

**Inconvénients** :
- Spécifique Windows
- Légèrement plus lent

#### Solution 4 : Handles opaques

La DLL cache complètement la gestion mémoire.

```pascal
type
  TMonObjet = record
    donnees: array[0..999] of Byte;
    taille: Integer;
  end;
  PMonObjet = ^TMonObjet;

  THandle = type Pointer;  // Type opaque

function CreerObjet: THandle; stdcall;
var
  obj: PMonObjet;
begin
  New(obj);
  obj^.taille := 0;
  Result := THandle(obj);
end;

procedure DetruireObjet(h: THandle); stdcall;
var
  obj: PMonObjet;
begin
  if h <> nil then
  begin
    obj := PMonObjet(h);
    Dispose(obj);
  end;
end;

function TailleObjet(h: THandle): Integer; stdcall;
var
  obj: PMonObjet;
begin
  if h = nil then
    Result := 0
  else
  begin
    obj := PMonObjet(h);
    Result := obj^.taille;
  end;
end;

exports
  CreerObjet,
  DetruireObjet,
  TailleObjet;
```

**Avantages** :
- Encapsulation totale
- Type-safe
- Flexible pour l'évolution

**Inconvénients** :
- Plus verbeux
- Overhead d'indirection

### Chaînes de caractères

Les chaînes Pascal (`string`) ne doivent **JAMAIS** être exposées directement.

#### Mauvais exemple

```pascal
// ❌ NE FAITES PAS ÇA
function ObtenirNom: string; stdcall;
begin
  Result := 'Hello World';
end;
```

Pourquoi ? La structure interne de `string` est spécifique à FreePascal et gère la mémoire automatiquement.

#### Bon exemple 1 : Buffer prédéfini

```pascal
// ✅ Approche buffer
procedure ObtenirNom(buffer: PChar; tailleBuffer: Integer); stdcall;
const
  NOM = 'Hello World';
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(NOM), tailleBuffer - 1);
end;

exports
  ObtenirNom;
```

Utilisation :
```pascal
var
  buffer: array[0..255] of Char;
begin
  ObtenirNom(@buffer[0], Length(buffer));
  WriteLn(buffer);
end;
```

#### Bon exemple 2 : Retour PChar (lecture seule)

```pascal
var
  NomGlobal: string = 'Hello World';

function ObtenirNom: PChar; stdcall;
begin
  Result := PChar(NomGlobal);
end;

exports
  ObtenirNom;
```

**Attention** : Le pointeur reste valide tant que `NomGlobal` existe. Ne pas libérer ce pointeur !

#### Bon exemple 3 : Allocation par l'appelant avec taille dynamique

```pascal
function ObtenirTailleNom: Integer; stdcall;
const
  NOM = 'Hello World';
begin
  Result := Length(NOM) + 1;  // +1 pour le #0 terminal
end;

procedure ObtenirNom(buffer: PChar; tailleBuffer: Integer); stdcall;
const
  NOM = 'Hello World';
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(NOM), tailleBuffer - 1);
end;

exports
  ObtenirTailleNom,
  ObtenirNom;
```

Utilisation :
```pascal
var
  taille: Integer;
  buffer: PChar;
begin
  taille := ObtenirTailleNom();
  GetMem(buffer, taille);
  try
    ObtenirNom(buffer, taille);
    WriteLn(buffer);
  finally
    FreeMem(buffer);
  end;
end;
```

## Gestion des erreurs

Les exceptions Pascal ne traversent pas les frontières des DLL de manière fiable.

### Approche 1 : Codes de retour

Méthode classique C/Windows.

```pascal
const
  SUCCESS = 0;
  ERROR_INVALID_PARAMETER = 1;
  ERROR_OUT_OF_MEMORY = 2;
  ERROR_FILE_NOT_FOUND = 3;

function FaireQuelqueChose(param: Integer): Integer; stdcall;
begin
  Result := SUCCESS;

  if param < 0 then
  begin
    Result := ERROR_INVALID_PARAMETER;
    Exit;
  end;

  try
    // Code qui peut échouer
  except
    Result := ERROR_OUT_OF_MEMORY;
  end;
end;

exports
  FaireQuelqueChose;
```

Utilisation :
```pascal
var
  code: Integer;
begin
  code := FaireQuelqueChose(42);
  if code <> SUCCESS then
    WriteLn('Erreur : ', code);
end;
```

### Approche 2 : Dernier code d'erreur (style GetLastError)

Comme l'API Windows.

```pascal
var
  DernierCodeErreur: Integer = 0;

function FaireQuelqueChose(param: Integer): Boolean; stdcall;
begin
  DernierCodeErreur := SUCCESS;
  Result := True;

  if param < 0 then
  begin
    DernierCodeErreur := ERROR_INVALID_PARAMETER;
    Result := False;
    Exit;
  end;

  // ... reste du code
end;

function ObtenirDernierCodeErreur: Integer; stdcall;
begin
  Result := DernierCodeErreur;
end;

exports
  FaireQuelqueChose,
  ObtenirDernierCodeErreur;
```

### Approche 3 : Messages d'erreur

Retourner un message lisible.

```pascal
var
  DernierMessageErreur: string = '';

function FaireQuelqueChose(param: Integer): Boolean; stdcall;
begin
  DernierMessageErreur := '';
  Result := True;

  try
    if param < 0 then
      raise Exception.Create('Paramètre invalide');
    // ... code
  except
    on E: Exception do
    begin
      DernierMessageErreur := E.Message;
      Result := False;
    end;
  end;
end;

procedure ObtenirDernierMessageErreur(buffer: PChar; taille: Integer); stdcall;
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(DernierMessageErreur), taille - 1);
end;

exports
  FaireQuelqueChose,
  ObtenirDernierMessageErreur;
```

## Initialisation et finalisation

Une DLL peut avoir du code exécuté au chargement et au déchargement.

### Structure complète

```pascal
library MaLib;

{$mode objfpc}{$H+}

uses
  SysUtils, Windows;

var
  InitialisationReussie: Boolean = False;
  CompteurInstances: Integer = 0;

function Initialiser: Boolean; stdcall;
begin
  Result := False;
  try
    // Initialisation des ressources
    WriteLn('Initialisation de la DLL');
    InitialisationReussie := True;
    Result := True;
  except
    InitialisationReussie := False;
  end;
end;

procedure Finaliser; stdcall;
begin
  WriteLn('Finalisation de la DLL');
  // Libération des ressources
end;

exports
  Initialiser,
  Finaliser;

// Point d'entrée DLL (optionnel)
procedure DLLMain(Reason: DWORD);
begin
  case Reason of
    DLL_PROCESS_ATTACH:
      begin
        Inc(CompteurInstances);
        WriteLn('DLL chargée par un processus. Instances : ', CompteurInstances);
      end;
    DLL_PROCESS_DETACH:
      begin
        Dec(CompteurInstances);
        WriteLn('DLL déchargée par un processus. Instances : ', CompteurInstances);
      end;
    DLL_THREAD_ATTACH:
      begin
        WriteLn('Nouveau thread a chargé la DLL');
      end;
    DLL_THREAD_DETACH:
      begin
        WriteLn('Un thread a déchargé la DLL');
      end;
  end;
end;

begin
  // Code d'initialisation de la DLL
  DLLProc := @DLLMain;
  DLLMain(DLL_PROCESS_ATTACH);
end.
```

**Constantes Windows** :
- `DLL_PROCESS_ATTACH` (1) : DLL chargée par un processus
- `DLL_PROCESS_DETACH` (0) : DLL déchargée par un processus
- `DLL_THREAD_ATTACH` (2) : Nouveau thread dans un processus qui a chargé la DLL
- `DLL_THREAD_DETACH` (3) : Thread se termine

## Callbacks depuis la DLL

Une DLL peut appeler des fonctions fournies par l'application cliente.

### Définition du callback

```pascal
library CallbackDemo;

{$mode objfpc}{$H+}

type
  // Type du callback
  TProgressCallback = procedure(progression: Integer); stdcall;

// Fonction qui utilise le callback
procedure TraiterDonnees(callback: TProgressCallback); stdcall;
var
  i: Integer;
begin
  for i := 0 to 100 do
  begin
    // Simulation de traitement
    Sleep(50);

    // Appeler le callback si fourni
    if Assigned(callback) then
      callback(i);
  end;
end;

exports
  TraiterDonnees;

begin
end.
```

### Utilisation du callback

```pascal
program TestCallback;

{$mode objfpc}{$H+}

uses
  SysUtils;

// Déclaration du type callback
type
  TProgressCallback = procedure(progression: Integer); stdcall;

// Déclaration de la fonction DLL
procedure TraiterDonnees(callback: TProgressCallback); stdcall;
  external 'CallbackDemo.dll';

// Implémentation du callback
procedure MonCallback(progression: Integer); stdcall;
begin
  WriteLn('Progression : ', progression, '%');
end;

begin
  WriteLn('Début du traitement...');
  TraiterDonnees(@MonCallback);
  WriteLn('Traitement terminé !');
  ReadLn;
end.
```

### Callbacks avec contexte utilisateur

Souvent, vous voulez passer des données au callback.

```pascal
type
  TProgressCallbackEx = procedure(progression: Integer;
    userData: Pointer); stdcall;

procedure TraiterDonneesEx(callback: TProgressCallbackEx;
  userData: Pointer); stdcall;
var
  i: Integer;
begin
  for i := 0 to 100 do
  begin
    Sleep(50);
    if Assigned(callback) then
      callback(i, userData);
  end;
end;

exports
  TraiterDonneesEx;
```

Utilisation :
```pascal
type
  TMonContexte = record
    nom: string[50];
    compteur: Integer;
  end;
  PMonContexte = ^TMonContexte;

procedure CallbackAvecContexte(progression: Integer; userData: Pointer); stdcall;
var
  ctx: PMonContexte;
begin
  ctx := PMonContexte(userData);
  Inc(ctx^.compteur);
  WriteLn(ctx^.nom, ' - Progression : ', progression,
    '% (appel #', ctx^.compteur, ')');
end;

var
  contexte: TMonContexte;
begin
  contexte.nom := 'MonTraitement';
  contexte.compteur := 0;
  TraiterDonneesEx(@CallbackAvecContexte, @contexte);
end;
```

## Débogage des DLL

### Vérifier les exports

Utilisez l'outil `dumpbin` (fourni avec Visual Studio) :

```batch
dumpbin /EXPORTS MaPremiereLib.dll
```

Ou `objdump` (fourni avec MinGW) :

```batch
objdump -x MaPremiereLib.dll | findstr "Export"
```

Sortie exemple :
```
ordinal hint RVA      name
      1    0 00001000 Addition
      2    1 00001020 Soustraction
```

### Dependency Walker

**Dependency Walker** est un outil graphique Windows très utile :
- Liste toutes les fonctions exportées
- Montre les dépendances (autres DLL)
- Détecte les DLL manquantes
- Affiche l'ordre de chargement

Téléchargeable gratuitement sur [dependencywalker.com](http://www.dependencywalker.com/)

### Déboguer avec GDB

Compiler la DLL avec les symboles de débogage :

```batch
fpc -g -oMaLib.dll MaLib.pas
```

Lancer GDB :
```batch
gdb MonApplication.exe
(gdb) break Addition
(gdb) run
(gdb) step
```

## Exemple complet : Bibliothèque mathématique

Créons une DLL complète avec plusieurs fonctions mathématiques.

```pascal
library MathLib;

{$mode objfpc}{$H+}

uses
  SysUtils, Math;

const
  MATHLIB_SUCCESS = 0;
  MATHLIB_ERROR_DIVISION_BY_ZERO = 1;
  MATHLIB_ERROR_NEGATIVE_ROOT = 2;

var
  LastError: Integer = MATHLIB_SUCCESS;
  LastErrorMessage: string = '';

// Addition
function Add(a, b: Double): Double; stdcall;
begin
  LastError := MATHLIB_SUCCESS;
  Result := a + b;
end;

// Soustraction
function Subtract(a, b: Double): Double; stdcall;
begin
  LastError := MATHLIB_SUCCESS;
  Result := a - b;
end;

// Multiplication
function Multiply(a, b: Double): Double; stdcall;
begin
  LastError := MATHLIB_SUCCESS;
  Result := a * b;
end;

// Division avec gestion d'erreur
function Divide(a, b: Double; out result: Double): Integer; stdcall;
begin
  LastError := MATHLIB_SUCCESS;
  LastErrorMessage := '';

  if b = 0 then
  begin
    LastError := MATHLIB_ERROR_DIVISION_BY_ZERO;
    LastErrorMessage := 'Division par zéro';
    result := 0;
    Result := LastError;
    Exit;
  end;

  result := a / b;
  Result := MATHLIB_SUCCESS;
end;

// Racine carrée avec gestion d'erreur
function SquareRoot(x: Double; out result: Double): Integer; stdcall;
begin
  LastError := MATHLIB_SUCCESS;
  LastErrorMessage := '';

  if x < 0 then
  begin
    LastError := MATHLIB_ERROR_NEGATIVE_ROOT;
    LastErrorMessage := 'Racine carrée d''un nombre négatif';
    result := 0;
    Result := LastError;
    Exit;
  end;

  result := Sqrt(x);
  Result := MATHLIB_SUCCESS;
end;

// Puissance
function Power(base, exponent: Double): Double; stdcall;
begin
  LastError := MATHLIB_SUCCESS;
  Result := Math.Power(base, exponent);
end;

// Obtenir le dernier code d'erreur
function GetLastError: Integer; stdcall;
begin
  Result := LastError;
end;

// Obtenir le dernier message d'erreur
procedure GetLastErrorMessage(buffer: PChar; bufferSize: Integer); stdcall;
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(LastErrorMessage), bufferSize - 1);
end;

// Version de la bibliothèque
function GetVersion: PChar; stdcall;
const
  VERSION = '1.0.0';
begin
  Result := VERSION;
end;

exports
  Add,
  Subtract,
  Multiply,
  Divide,
  SquareRoot,
  Power,
  GetLastError,
  GetLastErrorMessage,
  GetVersion;

begin
  // Initialisation
end.
```

### Programme de test

```pascal
program TestMathLib;

{$mode objfpc}{$H+}

uses
  SysUtils;

// Déclarations externes
function Add(a, b: Double): Double; stdcall; external 'MathLib.dll';
function Subtract(a, b: Double): Double; stdcall; external 'MathLib.dll';
function Multiply(a, b: Double): Double; stdcall; external 'MathLib.dll';
function Divide(a, b: Double; out result: Double): Integer; stdcall;
  external 'MathLib.dll';
function SquareRoot(x: Double; out result: Double): Integer; stdcall;
  external 'MathLib.dll';
function Power(base, exponent: Double): Double; stdcall; external 'MathLib.dll';
function GetLastError: Integer; stdcall; external 'MathLib.dll';
procedure GetLastErrorMessage(buffer: PChar; bufferSize: Integer); stdcall;
  external 'MathLib.dll';
function GetVersion: PChar; stdcall; external 'MathLib.dll';

procedure TestOperations;
var
  result: Double;
  errorCode: Integer;
  errorMsg: array[0..255] of Char;
begin
  WriteLn('=== Test de MathLib ===');
  WriteLn('Version : ', GetVersion);
  WriteLn;

  // Tests simples
  WriteLn('10 + 5 = ', Add(10, 5):0:2);
  WriteLn('10 - 5 = ', Subtract(10, 5):0:2);
  WriteLn('10 * 5 = ', Multiply(10, 5):0:2);
  WriteLn('2^8 = ', Power(2, 8):0:2);
  WriteLn;

  // Test division normale
  errorCode := Divide(10, 2, result);
  if errorCode = 0 then
    WriteLn('10 / 2 = ', result:0:2)
  else
  begin
    GetLastErrorMessage(@errorMsg[0], Length(errorMsg));
    WriteLn('Erreur : ', errorMsg);
  end;

  // Test division par zéro
  WriteLn;
  WriteLn('Test division par zéro :');
  errorCode := Divide(10, 0, result);
  if errorCode <> 0 then
  begin
    GetLastErrorMessage(@errorMsg[0], Length(errorMsg));
    WriteLn('Code erreur : ', errorCode);
    WriteLn('Message : ', errorMsg);
  end;

  // Test racine carrée normale
  WriteLn;
  errorCode := SquareRoot(16, result);
  if errorCode = 0 then
    WriteLn('Racine carrée de 16 = ', result:0:2);

  // Test racine carrée négative
  WriteLn;
  WriteLn('Test racine carrée d''un nombre négatif :');
  errorCode := SquareRoot(-16, result);
  if errorCode <> 0 then
  begin
    GetLastErrorMessage(@errorMsg[0], Length(errorMsg));
    WriteLn('Code erreur : ', errorCode);
    WriteLn('Message : ', errorMsg);
  end;
end;

begin
  try
    TestOperations;
  except
    on E: Exception do
      WriteLn('Exception : ', E.Message);
  end;

  WriteLn;
  WriteLn('Appuyez sur Entrée pour quitter...');
  ReadLn;
end.
```

**Sortie attendue** :
```
=== Test de MathLib ===
Version : 1.0.0

10 + 5 = 15.00
10 - 5 = 5.00
10 * 5 = 50.00
2^8 = 256.00

10 / 2 = 5.00

Test division par zéro :
Code erreur : 1
Message : Division par zéro

Racine carrée de 16 = 4.00

Test racine carrée d'un nombre négatif :
Code erreur : 2
Message : Racine carrée d'un nombre négatif

Appuyez sur Entrée pour quitter...
```

## Fichiers de définition de module (.def)

Un fichier `.def` (Module Definition File) permet de contrôler finement les exports d'une DLL.

### Pourquoi utiliser un fichier .def ?

- Contrôle précis sur les noms exportés (éviter le name mangling)
- Spécifier des ordinaux (index)
- Exporter des variables
- Documentation centralisée des exports

### Syntaxe de base

Créez un fichier `MathLib.def` :

```
LIBRARY MathLib
DESCRIPTION 'Bibliothèque mathématique pour FreePascal'

EXPORTS
    Add             @1
    Subtract        @2
    Multiply        @3
    Divide          @4
    SquareRoot      @5
    Power           @6
    GetLastError    @7
    GetLastErrorMessage @8
    GetVersion      @9
```

### Utilisation avec FreePascal

Pour utiliser un fichier `.def` lors de la compilation :

```batch
fpc -oMathLib.dll MathLib.pas MathLib.def
```

Ou créez un fichier de lien :

```batch
# link.res
EXPORTS
Add
Subtract
Multiply
```

Et compilez :
```batch
fpc -oMathLib.dll MathLib.pas link.res
```

### Avantages du fichier .def

**Sans .def** : Le compilateur peut décorer les noms
```
_Add@16
_Subtract@16
```

**Avec .def** : Les noms restent propres
```
Add
Subtract
```

## Métadonnées et ressources de DLL

Une DLL peut contenir des métadonnées (version, copyright, etc.).

### Fichier de ressources (.rc)

Créez un fichier `MathLib.rc` :

```rc
#include <windows.h>

VS_VERSION_INFO VERSIONINFO
FILEVERSION 1,0,0,0
PRODUCTVERSION 1,0,0,0
FILEFLAGSMASK 0x3fL
FILEFLAGS 0x0L
FILEOS VOS_NT_WINDOWS32
FILETYPE VFT_DLL
FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040c04b0"
        BEGIN
            VALUE "CompanyName", "Votre Société"
            VALUE "FileDescription", "Bibliothèque Mathématique"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "MathLib"
            VALUE "LegalCopyright", "Copyright (C) 2025"
            VALUE "OriginalFilename", "MathLib.dll"
            VALUE "ProductName", "MathLib"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x40c, 1200
    END
END
```

### Compiler les ressources

1. Compilez le fichier `.rc` en `.res` :
```batch
windres MathLib.rc -O coff -o MathLib.res
```

2. Liez avec la DLL :
```batch
fpc -oMathLib.dll MathLib.pas MathLib.res
```

### Inclure dans le code Pascal

Vous pouvez aussi inclure directement dans le code :

```pascal
library MathLib;

{$R MathLib.res}  // Inclusion du fichier de ressources

// ... reste du code
```

### Vérifier les métadonnées

Clic droit sur `MathLib.dll` → Propriétés → Détails

Vous verrez :
- Version du fichier
- Description
- Copyright
- Etc.

## Threading et DLL

Les DLL peuvent être utilisées par plusieurs threads simultanément.

### Variables globales et thread-safety

**Problème** : Les variables globales sont partagées entre tous les threads.

```pascal
var
  CompteurGlobal: Integer = 0;  // DANGEREUX en multithreading

function Incrementer: Integer; stdcall;
begin
  Inc(CompteurGlobal);  // Race condition !
  Result := CompteurGlobal;
end;
```

**Problème** : Si deux threads appellent `Incrementer` simultanément :

```
Thread 1: Lit CompteurGlobal (0)
Thread 2: Lit CompteurGlobal (0)
Thread 1: Incrémente → 1
Thread 2: Incrémente → 1  (devrait être 2 !)
```

### Solution 1 : Section critique

```pascal
uses
  Windows;

var
  CompteurGlobal: Integer = 0;
  CS: TRTLCriticalSection;

function Incrementer: Integer; stdcall;
begin
  EnterCriticalSection(CS);
  try
    Inc(CompteurGlobal);
    Result := CompteurGlobal;
  finally
    LeaveCriticalSection(CS);
  end;
end;

initialization
  InitializeCriticalSection(CS);

finalization
  DeleteCriticalSection(CS);
```

### Solution 2 : Opérations atomiques

```pascal
uses
  Windows;

var
  CompteurGlobal: Integer = 0;

function Incrementer: Integer; stdcall;
begin
  Result := InterlockedIncrement(CompteurGlobal);
end;
```

**Fonctions atomiques Windows** :
- `InterlockedIncrement` : Incrémentation atomique
- `InterlockedDecrement` : Décrémentation atomique
- `InterlockedExchange` : Échange atomique
- `InterlockedCompareExchange` : Compare et échange

### Solution 3 : Thread-Local Storage (TLS)

Chaque thread a sa propre copie de la variable.

```pascal
uses
  Windows;

var
  TLSIndex: DWORD;

function ObtenirValeurTLS: Integer;
begin
  Result := Integer(TlsGetValue(TLSIndex));
end;

procedure DefinirValeurTLS(valeur: Integer);
begin
  TlsSetValue(TLSIndex, Pointer(valeur));
end;

function IncrementerTLS: Integer; stdcall;
var
  val: Integer;
begin
  val := ObtenirValeurTLS;
  Inc(val);
  DefinirValeurTLS(val);
  Result := val;
end;

exports
  IncrementerTLS;

procedure DLLMain(Reason: DWORD);
begin
  case Reason of
    DLL_PROCESS_ATTACH:
      TLSIndex := TlsAlloc();
    DLL_PROCESS_DETACH:
      TlsFree(TLSIndex);
  end;
end;

begin
  DLLProc := @DLLMain;
  DLLMain(DLL_PROCESS_ATTACH);
end.
```

## Chargement dynamique de DLL

Plutôt que de lier statiquement, vous pouvez charger une DLL à la demande.

### Avantages du chargement dynamique

- La DLL n'est pas obligatoire au démarrage
- Choix de la DLL au runtime
- Gestion gracieuse si la DLL est absente
- Plugins optionnels

### Exemple complet

```pascal
program ChargementDynamique;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils;

type
  // Définition des types de fonction
  TAddFunc = function(a, b: Double): Double; stdcall;
  TGetVersionFunc = function: PChar; stdcall;

var
  hLib: HMODULE;
  Add: TAddFunc;
  GetVersion: TGetVersionFunc;

function ChargerDLL: Boolean;
begin
  Result := False;

  // Charger la DLL
  hLib := LoadLibrary('MathLib.dll');
  if hLib = 0 then
  begin
    WriteLn('Erreur : impossible de charger MathLib.dll');
    WriteLn('Code erreur : ', GetLastError);
    Exit;
  end;

  // Obtenir l'adresse de la fonction Add
  Add := TAddFunc(GetProcAddress(hLib, 'Add'));
  if not Assigned(Add) then
  begin
    WriteLn('Erreur : fonction Add non trouvée');
    FreeLibrary(hLib);
    Exit;
  end;

  // Obtenir l'adresse de la fonction GetVersion
  GetVersion := TGetVersionFunc(GetProcAddress(hLib, 'GetVersion'));
  if not Assigned(GetVersion) then
  begin
    WriteLn('Erreur : fonction GetVersion non trouvée');
    FreeLibrary(hLib);
    Exit;
  end;

  Result := True;
end;

procedure DechargerDLL;
begin
  if hLib <> 0 then
  begin
    FreeLibrary(hLib);
    hLib := 0;
    Add := nil;
    GetVersion := nil;
  end;
end;

begin
  hLib := 0;

  if not ChargerDLL then
  begin
    WriteLn('Impossible de charger la DLL');
    ReadLn;
    Exit;
  end;

  try
    WriteLn('DLL chargée avec succès !');
    WriteLn('Version : ', GetVersion);
    WriteLn('5 + 3 = ', Add(5, 3):0:2);
  finally
    DechargerDLL;
    WriteLn('DLL déchargée');
  end;

  WriteLn;
  WriteLn('Appuyez sur Entrée pour quitter...');
  ReadLn;
end.
```

### Recherche de DLL par Windows

Windows cherche les DLL dans cet ordre :

1. **Le répertoire de l'application**
2. Le répertoire système (`C:\Windows\System32`)
3. Le répertoire Windows (`C:\Windows`)
4. Le répertoire courant
5. Les répertoires listés dans la variable `PATH`

**Bonnes pratiques** :
- Placez vos DLL dans le même répertoire que votre EXE
- Ou spécifiez le chemin complet : `LoadLibrary('C:\MonApp\MathLib.dll')`

### Précharger une DLL spécifique

```pascal
function ChargerDLLDepuisRepertoire(const nomDLL, repertoire: string): HMODULE;
var
  cheminComplet: string;
begin
  cheminComplet := IncludeTrailingPathDelimiter(repertoire) + nomDLL;
  Result := LoadLibrary(PChar(cheminComplet));
end;

// Utilisation
hLib := ChargerDLLDepuisRepertoire('MathLib.dll', 'C:\MonApp\libs');
```

## DLL et gestion des exceptions

### Exceptions Pascal ne traversent pas les DLL

**Règle importante** : Les exceptions Pascal levées dans une DLL ne peuvent pas être attrapées dans l'application appelante (et vice-versa).

```pascal
// ❌ NE FONCTIONNERA PAS comme prévu
function DiviserDanger(a, b: Integer): Integer; stdcall;
begin
  Result := a div b;  // Lève une exception si b = 0
end;

// ✅ BON : Gérer l'exception dans la DLL
function DiviserSafe(a, b: Integer; out result: Integer): Boolean; stdcall;
begin
  try
    result := a div b;
    Result := True;
  except
    result := 0;
    Result := False;
  end;
end;
```

### Wrapper avec try..except

Encapsulez toutes les fonctions exportées :

```pascal
function OperationComplexe(param: Integer): Integer; stdcall;
begin
  Result := -1;  // Valeur d'erreur par défaut
  try
    // Code qui peut lever des exceptions
    Result := FaireCalculComplexe(param);
  except
    on E: Exception do
    begin
      // Logger l'erreur
      LogError(E.Message);
      // Définir le code d'erreur
      SetLastError(ERROR_EXCEPTION);
    end;
  end;
end;
```

## Optimisations spécifiques aux DLL

### Smart Linking

Activez le smart linking pour réduire la taille :

```pascal
{$SMARTLINK ON}
```

Ou en ligne de commande :
```batch
fpc -XX -CX -oMathLib.dll MathLib.pas
```

Réduction typique : 20-40% de la taille du fichier.

### Strip des symboles

Retirez les symboles de débogage pour la version finale :

```batch
fpc -Xs -oMathLib.dll MathLib.pas
```

Ou après compilation :
```batch
strip --strip-all MathLib.dll
```

### Utiliser -Os pour la taille

```batch
fpc -Os -XX -Xs -oMathLib.dll MathLib.pas
```

Options :
- `-Os` : Optimise pour la taille
- `-O2` : Optimise pour la vitesse
- `-O3` : Optimisations agressives

### Comparaison des tailles

```
Compilation normale :           150 KB
Avec smart linking :            100 KB  (-33%)
+ strip :                        80 KB  (-47%)
+ optimisation taille :          65 KB  (-57%)
```

## Compatibilité 32/64 bits

### Compilation pour les deux architectures

**32 bits** :
```batch
fpc -Twin32 -oMathLib32.dll MathLib.pas
```

**64 bits** :
```batch
fpc -Twin64 -oMathLib64.dll MathLib.pas
```

### Nommage recommandé

```
MathLib.dll         (64 bits par défaut)
MathLib32.dll       (explicitement 32 bits)
MathLib64.dll       (explicitement 64 bits)
```

### Chargement conditionnel

```pascal
function ChargerDLLAppropriee: HMODULE;
begin
  {$IFDEF CPU64}
  Result := LoadLibrary('MathLib64.dll');
  {$ELSE}
  Result := LoadLibrary('MathLib32.dll');
  {$ENDIF}
end;
```

### Différences importantes 32/64

**Types affectés** :
- `Pointer` : 4 octets (32-bit) vs 8 octets (64-bit)
- `NativeInt` : 4 octets (32-bit) vs 8 octets (64-bit)
- `NativeUInt` : 4 octets (32-bit) vs 8 octets (64-bit)

**Utilisez toujours** :
- `Integer` : toujours 32 bits
- `Int64` : toujours 64 bits
- `PtrInt`, `PtrUInt` : taille du pointeur

## Sécurité et signature de code

### Pourquoi signer une DLL ?

- **Authenticité** : Prouver l'origine du code
- **Intégrité** : Garantir que le fichier n'a pas été modifié
- **Confiance** : Windows SmartScreen et antivirus
- **Obligations** : Certains contextes (drivers kernel) l'exigent

### Obtenir un certificat

Sources de certificats de signature de code :
- **Autorités de certification commerciales** : DigiCert, Sectigo, GlobalSign
- **Certificat auto-signé** : Pour tests uniquement

### Signer avec SignTool

```batch
signtool sign /f MonCertificat.pfx /p MotDePasse /t http://timestamp.digicert.com MathLib.dll
```

Options :
- `/f` : Fichier certificat (.pfx)
- `/p` : Mot de passe du certificat
- `/t` : Serveur de timestamp (horodatage)
- `/d` : Description de la DLL

### Vérifier la signature

```batch
signtool verify /pa MathLib.dll
```

Ou clic droit sur le fichier → Propriétés → Signatures numériques

## Bonnes pratiques récapitulatives

### ✅ À faire

1. **Toujours utiliser `stdcall` ou `cdecl`** pour l'interopérabilité
2. **Gérer toutes les exceptions** dans les fonctions exportées
3. **Documenter l'API** complètement
4. **Versionner correctement** (SemVer)
5. **Fournir des paires create/destroy** pour les objets
6. **Utiliser des types simples** dans l'API publique
7. **Tester sur toutes les versions de Windows** ciblées
8. **Fournir des exemples** d'utilisation
9. **Logger les erreurs** en interne
10. **Vérifier la thread-safety** si applicable

### ❌ À éviter

1. **Exposer des `string` Pascal** directement
2. **Mélanger les gestionnaires de mémoire** (heap mismatch)
3. **Laisser les exceptions se propager** hors de la DLL
4. **Casser la compatibilité binaire** sans changer la version majeure
5. **Utiliser des variables globales mutables** sans protection
6. **Oublier de tester le chargement dynamique**
7. **Négliger la documentation** des codes d'erreur
8. **Ignorer les problèmes d'encodage** (ANSI/Unicode)
9. **Ne pas fournir de fonction de version**
10. **Compiler sans optimisations** pour la production

## Checklist de déploiement

Avant de distribuer votre DLL :

- [ ] Testée sur toutes les versions Windows ciblées (7, 8, 10, 11)
- [ ] Testée 32 et 64 bits si applicable
- [ ] Documentation complète de l'API
- [ ] Exemples de code fonctionnels
- [ ] Fichier de version/changelog
- [ ] Tests de performance effectués
- [ ] Tests de thread-safety si applicable
- [ ] Pas de dépendances manquantes
- [ ] Signée numériquement (recommandé)
- [ ] Licence clairement définie
- [ ] Support technique disponible

## Conclusion

Créer des DLL Windows avec FreePascal est un processus puissant qui permet :
- **Réutilisation maximale** du code Pascal
- **Interopérabilité** avec tous les langages Windows
- **Architecture modulaire** et extensible
- **Performance optimale** avec du code natif

Les points essentiels à retenir :
- ✅ Convention `stdcall` pour l'API Windows
- ✅ Gestion rigoureuse de la mémoire
- ✅ Traitement des erreurs sans exceptions
- ✅ Types compatibles C
- ✅ Documentation et tests complets

Avec ces connaissances, vous pouvez créer des DLL professionnelles, robustes et largement utilisables sur la plateforme Windows.

⏭️ [Shared Objects (.so) Linux](/19-interoperabilite-bindings/01.2-shared-objects-so-linux.md)
