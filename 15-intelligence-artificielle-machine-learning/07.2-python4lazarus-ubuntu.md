🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.2 Python4Lazarus sur Ubuntu

## Introduction

Cette section vous guide dans l'installation et la configuration de Python4Lazarus sur Ubuntu/Linux. Vous découvrirez les spécificités de l'environnement Linux, les différences avec Windows, et comment tirer parti des outils natifs d'Ubuntu pour créer des applications d'Intelligence Artificielle performantes.

## Pourquoi Ubuntu pour l'IA ?

Ubuntu est devenu la plateforme de référence pour le développement en Intelligence Artificielle :

### Avantages d'Ubuntu pour l'IA

✅ **Écosystème natif** : Python et bibliothèques IA sont conçus pour Linux
✅ **Performance** : Meilleure gestion mémoire, moins d'overhead système
✅ **Outils de développement** : apt, pip, conda intégrés nativement
✅ **Serveurs** : Facilité de déploiement sur serveurs Linux
✅ **Docker/Conteneurs** : Support natif pour le déploiement conteneurisé
✅ **GPU** : Meilleure intégration CUDA/NVIDIA pour le deep learning

### Différences principales avec Windows

| Aspect | Windows | Ubuntu/Linux |
|--------|---------|--------------|
| **Séparateur de chemin** | `\` (backslash) | `/` (forward slash) |
| **Bibliothèques dynamiques** | `.dll` | `.so` (shared object) |
| **Gestionnaire de paquets** | pip, chocolatey | apt, pip, snap |
| **Permissions** | UAC | chmod, sudo |
| **Python par défaut** | Non installé | Pré-installé (3.x) |
| **Chemins système** | `C:\Program Files` | `/usr/lib`, `/usr/local` |

## Prérequis

### 1. Vérifier votre système Ubuntu

Ouvrez un terminal (Ctrl+Alt+T) et vérifiez votre version :

```bash
lsb_release -a
```

**Sortie attendue :**
```
Distributor ID: Ubuntu
Description:    Ubuntu 22.04.3 LTS
Release:        22.04
Codename:       jammy
```

Cette section est testée sur Ubuntu 20.04, 22.04 et 24.04 LTS.

### 2. Vérifier l'installation de Python

Ubuntu vient généralement avec Python 3 pré-installé :

```bash
python3 --version
```

**Sortie attendue :**
```
Python 3.10.12
```

Si Python n'est pas installé (rare), installez-le :

```bash
sudo apt update
sudo apt install python3 python3-pip python3-dev
```

### 3. Installer Lazarus et FreePascal

**Méthode 1 : Via les dépôts Ubuntu (stable)**

```bash
sudo apt update
sudo apt install lazarus lcl fp-compiler fp-units-misc
```

**Méthode 2 : Via le PPA (version plus récente)**

```bash
sudo add-apt-repository ppa:lazarus-team/lazarus
sudo apt update
sudo apt install lazarus
```

**Vérifier l'installation :**

```bash
lazarus-ide --version
fpc -iV
```

### 4. Identifier les chemins Python importants

**Chemin de l'exécutable Python :**

```bash
which python3
```

**Sortie typique :**
```
/usr/bin/python3
```

**Chemin des bibliothèques Python :**

```bash
python3 -c "import sys; print(sys.executable)"
python3 -c "import sysconfig; print(sysconfig.get_config_var('LIBDIR'))"
```

**Sortie typique :**
```
/usr/bin/python3
/usr/lib/x86_64-linux-gnu
```

**Trouver libpython3.X.so :**

```bash
find /usr/lib -name "libpython3*.so*" 2>/dev/null
```

**Sortie typique :**
```
/usr/lib/x86_64-linux-gnu/libpython3.10.so
/usr/lib/x86_64-linux-gnu/libpython3.10.so.1
/usr/lib/x86_64-linux-gnu/libpython3.10.so.1.0
```

**Notez ces chemins, ils seront nécessaires pour la configuration !**

## Installation de Python4Lazarus

### Méthode 1 : Installation via OPM (Recommandée)

**Étape 1 : Lancer Lazarus**

```bash
lazarus-ide
```

Ou depuis le menu Applications → Développement → Lazarus

**Étape 2 : Ouvrir OPM (Online Package Manager)**

1. Menu **Paquets → Gestionnaire de paquets en ligne**
2. Attendez le chargement de la liste

**Étape 3 : Installer Python4Lazarus**

1. Recherchez "python" dans la barre de recherche
2. Sélectionnez **Python4Lazarus** ou **python4delphi**
3. Cliquez sur **Installer**
4. Cliquez sur **Recompiler l'IDE**
5. Lazarus redémarre automatiquement

**Étape 4 : Vérification**

Après le redémarrage, vérifiez la présence de l'onglet **Python** dans la palette de composants avec :
- TPythonEngine
- TPythonModule
- TPythonInputOutput
- TPythonGUIInputOutput

### Méthode 2 : Installation manuelle depuis GitHub

**Étape 1 : Télécharger Python4Delphi**

```bash
cd ~/Downloads
git clone https://github.com/pyscripter/python4delphi.git
```

Ou téléchargez le ZIP depuis GitHub et extrayez-le.

**Étape 2 : Ouvrir le paquet dans Lazarus**

1. Lancez Lazarus
2. Menu **Paquet → Ouvrir un fichier paquet (.lpk)**
3. Naviguez vers `~/Downloads/python4delphi/Packages/Lazarus/`
4. Ouvrez `python4lazarus_package.lpk`

**Étape 3 : Compiler et installer**

1. Dans la fenêtre du paquet, cliquez **Compiler**
2. Une fois la compilation réussie, cliquez **Utiliser → Installer**
3. Confirmez la recompilation de l'IDE
4. Lazarus redémarre

**Étape 4 : Vérification**

Vérifiez la présence des composants Python dans la palette.

## Configuration de base

### Créer un premier projet test

**Étape 1 : Nouveau projet**

1. **Projet → Nouveau projet**
2. Sélectionnez **Application**
3. Enregistrez : `TestPythonUbuntu.lpi`

**Étape 2 : Ajouter les composants**

1. Onglet **Python** dans la palette
2. Ajoutez `TPythonEngine` sur le formulaire
3. Ajoutez `TPythonGUIInputOutput` sur le formulaire

**Étape 3 : Ajouter l'interface utilisateur**

Ajoutez ces composants :
- 1 `TMemo` nommé `MemoCode` (pour le code Python)
- 1 `TButton` nommé `ButtonExecute` (Caption = "Exécuter")
- 1 `TMemo` nommé `MemoOutput` (pour les résultats)
- 1 `TLabel` nommé `LabelStatus`

**Disposition suggérée :**

```
┌─────────────────────────────────────────┐
│  MemoCode (Code Python)                 │
│  ┌───────────────────────────────────┐  │
│  │ import sys                        │  │
│  │ print(f"Python {sys.version}")    │  │
│  │ print("Hello from Ubuntu!")       │  │
│  └───────────────────────────────────┘  │
│                                         │
│  [Exécuter]  ← ButtonExecute            │
│                                         │
│  Status: ● Prêt                         │
│                                         │
│  MemoOutput (Sortie)                    │
│  ┌───────────────────────────────────┐  │
│  │ Python 3.10.12                    │  │
│  │ Hello from Ubuntu!                │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### Configuration de TPythonEngine pour Ubuntu

Sélectionnez `PythonEngine1` dans l'Object Inspector :

**Configuration automatique (recommandée) :**

```
Propriété : AutoLoad
Valeur   : True

Propriété : UseLastKnownVersion
Valeur   : True
```

Avec cette configuration, Python4Lazarus cherche automatiquement Python dans le système.

**Configuration manuelle (si automatique ne fonctionne pas) :**

```
Propriété : DllPath
Valeur   : /usr/lib/x86_64-linux-gnu

Propriété : DllName
Valeur   : libpython3.10.so
(Adaptez selon votre version Python)
```

**Configuration de PythonGUIInputOutput1 :**

```
Propriété : Engine
Valeur   : PythonEngine1
```

### Code Pascal complet

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  PythonEngine, PythonGUIInputOutput;

type
  TForm1 = class(TForm)
    ButtonExecute: TButton;
    LabelStatus: TLabel;
    MemoCode: TMemo;
    MemoOutput: TMemo;
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonExecuteClick(Sender: TObject);
    procedure PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);

  private
    procedure InitializePython;
    procedure UpdateStatus(const Msg: string; IsOK: Boolean);
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

procedure TForm1.FormCreate(Sender: TObject);
begin
  InitializePython;

  // Code Python par défaut
  MemoCode.Lines.Clear;
  MemoCode.Lines.Add('import sys');
  MemoCode.Lines.Add('import platform');
  MemoCode.Lines.Add('');
  MemoCode.Lines.Add('print(f"Python {sys.version}")');
  MemoCode.Lines.Add('print(f"Plateforme : {platform.system()}")');
  MemoCode.Lines.Add('print("Hello from Ubuntu!")');
end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TForm1.InitializePython;
begin
  try
    // Configuration pour Ubuntu
    {$IFDEF UNIX}
    PythonEngine1.UseLastKnownVersion := True;
    PythonEngine1.AutoLoad := True;
    {$ENDIF}

    // Charger Python
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      UpdateStatus('Python ' + PythonEngine1.PyVersion + ' initialisé', True);
      MemoOutput.Lines.Add('=== Python initialisé avec succès ===');
      MemoOutput.Lines.Add('Version : ' + PythonEngine1.PyVersion);

      // Afficher les chemins Python
      PythonEngine1.ExecString('import sys');
      MemoOutput.Lines.Add('Exécutable : ' +
        PythonEngine1.EvalString('sys.executable'));

      ButtonExecute.Enabled := True;
    end
    else
    begin
      UpdateStatus('Erreur : Python non initialisé', False);
      ShowMessage('Impossible d''initialiser Python. Vérifiez l''installation.');
    end;

  except
    on E: Exception do
    begin
      UpdateStatus('Erreur : ' + E.Message, False);
      ShowMessage('Erreur lors de l''initialisation Python :' + LineEnding +
                  E.Message);
    end;
  end;
end;

procedure TForm1.ButtonExecuteClick(Sender: TObject);
begin
  if not PythonEngine1.Initialized then
  begin
    ShowMessage('Python n''est pas initialisé !');
    Exit;
  end;

  MemoOutput.Clear;
  UpdateStatus('Exécution en cours...', True);

  try
    PythonEngine1.ExecStrings(MemoCode.Lines);
    UpdateStatus('Exécution terminée', True);
  except
    on E: Exception do
    begin
      UpdateStatus('Erreur d''exécution', False);
      MemoOutput.Lines.Add('=== ERREUR ===');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;

procedure TForm1.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);
begin
  MemoOutput.Lines.Add(Data);
end;

procedure TForm1.UpdateStatus(const Msg: string; IsOK: Boolean);
begin
  LabelStatus.Caption := 'Status: ' + Msg;

  if IsOK then
  begin
    LabelStatus.Font.Color := clGreen;
    LabelStatus.Caption := LabelStatus.Caption + ' ●';
  end
  else
  begin
    LabelStatus.Font.Color := clRed;
    LabelStatus.Caption := LabelStatus.Caption + ' ●';
  end;
end;

end.
```

### Compiler et tester

**Compilation :**

1. **Lancer → Compiler** (Ctrl+F9)
2. Vérifiez qu'il n'y a pas d'erreurs

**Exécution :**

1. **Lancer → Exécuter** (F9)
2. Cliquez sur **Exécuter**
3. Vous devriez voir :

```
=== Python initialisé avec succès ===
Version : 3.10.12
Exécutable : /usr/bin/python3
Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0]
Plateforme : Linux
Hello from Ubuntu!
```

## Gestion des chemins et bibliothèques sur Ubuntu

### Comprendre les chemins Linux

Sur Ubuntu, les bibliothèques Python peuvent être à différents endroits :

**Chemins système standard :**

```
/usr/lib/python3.10/          # Bibliothèque standard Python
/usr/lib/x86_64-linux-gnu/    # Bibliothèques compilées (.so)
/usr/local/lib/python3.10/    # Installations locales
/home/user/.local/lib/        # Installations utilisateur (pip install --user)
```

### Détection automatique de Python

**Code pour trouver automatiquement Python :**

```pascal
uses
  Process;

function FindPythonLibrary: string;
var
  Process: TProcess;
  OutputLines: TStringList;
  LibPath: string;
begin
  Result := '';

  Process := TProcess.Create(nil);
  OutputLines := TStringList.Create;
  try
    // Trouver le chemin de libpython
    Process.Executable := 'python3';
    Process.Parameters.Add('-c');
    Process.Parameters.Add(
      'import sysconfig; print(sysconfig.get_config_var("LIBDIR"))'
    );
    Process.Options := [poWaitOnExit, poUsePipes];
    Process.Execute;

    OutputLines.LoadFromStream(Process.Output);

    if OutputLines.Count > 0 then
    begin
      LibPath := Trim(OutputLines[0]);

      // Chercher libpython3.X.so
      if FileExists(LibPath + '/libpython3.10.so') then
        Result := LibPath + '/libpython3.10.so'
      else if FileExists(LibPath + '/libpython3.11.so') then
        Result := LibPath + '/libpython3.11.so'
      else if FileExists(LibPath + '/libpython3.9.so') then
        Result := LibPath + '/libpython3.9.so';
    end;

  finally
    OutputLines.Free;
    Process.Free;
  end;
end;

// Utilisation
procedure TForm1.FormCreate(Sender: TObject);
var
  PythonLib: string;
begin
  PythonLib := FindPythonLibrary;

  if PythonLib <> '' then
  begin
    PythonEngine1.DllPath := ExtractFilePath(PythonLib);
    PythonEngine1.DllName := ExtractFileName(PythonLib);
    PythonEngine1.LoadDll;
  end
  else
  begin
    // Utiliser la détection automatique
    PythonEngine1.UseLastKnownVersion := True;
    PythonEngine1.LoadDll;
  end;
end;
```

### Gestion des erreurs courantes

**Erreur : "Could not load library libpython3.X.so"**

**Solution 1 : Installer les fichiers de développement Python**

```bash
sudo apt install python3-dev
```

**Solution 2 : Créer un lien symbolique**

Si vous avez `libpython3.10.so.1.0` mais pas `libpython3.10.so` :

```bash
cd /usr/lib/x86_64-linux-gnu
sudo ln -s libpython3.10.so.1.0 libpython3.10.so
```

**Solution 3 : Vérifier ldconfig**

```bash
sudo ldconfig -v | grep python
```

Si la bibliothèque n'apparaît pas, ajoutez-la :

```bash
echo "/usr/lib/x86_64-linux-gnu" | sudo tee /etc/ld.so.conf.d/python.conf
sudo ldconfig
```

## Installation de bibliothèques Python pour l'IA

### Méthode 1 : Via pip (recommandée)

**Installer pip si nécessaire :**

```bash
sudo apt install python3-pip
```

**Installer les bibliothèques IA essentielles :**

```bash
# Bibliothèques de base
pip3 install numpy pandas matplotlib seaborn

# Machine Learning
pip3 install scikit-learn xgboost lightgbm

# Deep Learning
pip3 install tensorflow
# ou
pip3 install torch torchvision

# Computer Vision
pip3 install opencv-python pillow

# NLP
pip3 install transformers spacy nltk

# Jupyter (optionnel, pour prototypage)
pip3 install jupyter notebook
```

**Installation dans un environnement virtuel (recommandé) :**

```bash
# Créer un environnement virtuel
python3 -m venv ~/myenv

# Activer l'environnement
source ~/myenv/bin/activate

# Installer les bibliothèques
pip install tensorflow numpy pandas

# Désactiver
deactivate
```

### Méthode 2 : Via apt (bibliothèques système)

Certaines bibliothèques sont disponibles via apt :

```bash
sudo apt install python3-numpy python3-pandas python3-matplotlib
sudo apt install python3-sklearn python3-opencv
```

**Avantages apt :**
- Intégration système optimale
- Gestion des dépendances automatique
- Mises à jour système

**Inconvénients apt :**
- Versions souvent plus anciennes
- Moins de bibliothèques disponibles

### Méthode 3 : Via Conda/Miniconda

**Installer Miniconda :**

```bash
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
bash Miniconda3-latest-Linux-x86_64.sh
```

**Créer un environnement :**

```bash
conda create -n myenv python=3.10
conda activate myenv
conda install tensorflow numpy pandas scikit-learn
```

**Utiliser avec Python4Lazarus :**

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  // Pointer vers Python de conda
  PythonEngine1.DllPath := '/home/user/miniconda3/envs/myenv/lib';
  PythonEngine1.DllName := 'libpython3.10.so';
  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
  begin
    // Configurer le path Python pour l'environnement conda
    PythonEngine1.ExecString('import sys');
    PythonEngine1.ExecString(
      'sys.path.insert(0, "/home/user/miniconda3/envs/myenv/lib/python3.10/site-packages")'
    );
  end;
end;
```

### Vérifier les installations

**Test dans votre application Lazarus :**

```pascal
procedure TForm1.ButtonTestLibrariesClick(Sender: TObject);
var
  Libraries: array of string;
  i: Integer;
  Available, Missing: TStringList;
begin
  Libraries := ['numpy', 'pandas', 'matplotlib', 'sklearn', 'tensorflow'];

  Available := TStringList.Create;
  Missing := TStringList.Create;
  try
    for i := 0 to High(Libraries) do
    begin
      try
        PythonEngine1.ExecString('import ' + Libraries[i]);
        Available.Add(Libraries[i]);
      except
        Missing.Add(Libraries[i]);
      end;
    end;

    MemoOutput.Lines.Add('=== Bibliothèques disponibles ===');
    MemoOutput.Lines.AddStrings(Available);
    MemoOutput.Lines.Add('');

    if Missing.Count > 0 then
    begin
      MemoOutput.Lines.Add('=== Bibliothèques manquantes ===');
      MemoOutput.Lines.AddStrings(Missing);
      MemoOutput.Lines.Add('');
      MemoOutput.Lines.Add('Installez-les avec :');
      MemoOutput.Lines.Add('pip3 install ' + Missing.DelimitedText);
    end;

  finally
    Available.Free;
    Missing.Free;
  end;
end;
```

## Spécificités Ubuntu/Linux

### Permissions et sudo

Sur Ubuntu, certaines opérations nécessitent des privilèges administrateur :

**Cas 1 : Installation système**

```bash
# Installation globale (nécessite sudo)
sudo pip3 install tensorflow

# Installation utilisateur (sans sudo, recommandé)
pip3 install --user tensorflow
```

**Cas 2 : Accès aux périphériques**

Pour accéder à la caméra, au GPU, etc. :

```bash
# Ajouter l'utilisateur au groupe video (pour caméra)
sudo usermod -a -G video $USER

# Pour le GPU NVIDIA
sudo usermod -a -G video $USER
```

**Déconnectez-vous et reconnectez-vous** pour que les changements prennent effet.

### Variables d'environnement

**Configurer PYTHONPATH dans votre application :**

```pascal
procedure TForm1.SetupPythonEnvironment;
begin
  // Ajouter des chemins personnalisés
  PythonEngine1.ExecString('import sys');
  PythonEngine1.ExecString('import os');

  // Ajouter un chemin personnalisé
  PythonEngine1.ExecString(
    'sys.path.insert(0, os.path.expanduser("~/mon_projet/python_scripts"))'
  );

  // Définir des variables d'environnement
  PythonEngine1.ExecString(
    'os.environ["CUDA_VISIBLE_DEVICES"] = "0"'  // Utiliser GPU 0
  );
end;
```

### Chemins relatifs et absolus

Sur Linux, utilisez toujours `/` comme séparateur :

```pascal
// ✅ Correct sur Linux
PythonEngine.ExecString('data = load_file("/home/user/data.csv")');
PythonEngine.ExecString('img = load_image("./images/photo.jpg")');

// ✅ Chemin utilisateur avec expansion
PythonEngine.ExecString('import os');
PythonEngine.ExecString('home = os.path.expanduser("~")');
PythonEngine.ExecString('file_path = os.path.join(home, "Documents", "data.csv")');

// ❌ À éviter (Windows style)
// PythonEngine.ExecString('data = load_file("C:\Users\data.csv")');
```

**Fonction Pascal pour gérer les chemins multi-plateformes :**

```pascal
function ToPythonPath(const Path: string): string;
begin
  {$IFDEF WINDOWS}
  Result := StringReplace(Path, '\', '/', [rfReplaceAll]);
  {$ELSE}
  Result := Path;
  {$ENDIF}
end;

// Utilisation
var
  DataPath: string;
begin
  DataPath := '/home/user/data.csv';
  PythonEngine.ExecString(
    Format('data = pd.read_csv("%s")', [ToPythonPath(DataPath)])
  );
end;
```

## Compilation conditionnelle Windows/Ubuntu

Pour créer une application qui fonctionne sur les deux plateformes :

```pascal
unit CrossPlatformPython;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TCrossPlatformPython = class
  private
    FPythonEngine: TPythonEngine;
    procedure ConfigureForPlatform;
  public
    constructor Create(APythonEngine: TPythonEngine);
    function GetPythonPath: string;
    function GetLibraryName: string;
  end;

implementation

constructor TCrossPlatformPython.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
  ConfigureForPlatform;
end;

procedure TCrossPlatformPython.ConfigureForPlatform;
begin
  {$IFDEF WINDOWS}
  // Configuration Windows
  FPythonEngine.DllPath := 'C:\Python310';
  FPythonEngine.DllName := 'python310.dll';
  {$ENDIF}

  {$IFDEF LINUX}
  // Configuration Linux/Ubuntu
  FPythonEngine.UseLastKnownVersion := True;
  FPythonEngine.AutoLoad := True;
  // ou spécifique:
  // FPythonEngine.DllPath := '/usr/lib/x86_64-linux-gnu';
  // FPythonEngine.DllName := 'libpython3.10.so';
  {$ENDIF}

  {$IFDEF DARWIN}
  // Configuration macOS
  FPythonEngine.DllPath := '/usr/local/lib';
  FPythonEngine.DllName := 'libpython3.10.dylib';
  {$ENDIF}
end;

function TCrossPlatformPython.GetPythonPath: string;
begin
  {$IFDEF WINDOWS}
  Result := 'C:\Python310';
  {$ENDIF}

  {$IFDEF LINUX}
  Result := '/usr/bin/python3';
  {$ENDIF}

  {$IFDEF DARWIN}
  Result := '/usr/local/bin/python3';
  {$ENDIF}
end;

function TCrossPlatformPython.GetLibraryName: string;
begin
  {$IFDEF WINDOWS}
  Result := 'python310.dll';
  {$ENDIF}

  {$IFDEF LINUX}
  Result := 'libpython3.10.so';
  {$ENDIF}

  {$IFDEF DARWIN}
  Result := 'libpython3.10.dylib';
  {$ENDIF}
end;

end.
```

## Exemple complet : Application de classification d'images sur Ubuntu

```pascal
unit ImageClassifierUbuntu;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  ExtDlgs, PythonEngine, PythonGUIInputOutput;

type
  TFormClassifier = class(TForm)
    ButtonLoadModel: TButton;
    ButtonSelectImage: TButton;
    ButtonClassify: TButton;
    ImagePreview: TImage;
    LabelResult: TLabel;
    LabelStatus: TLabel;
    MemoLog: TMemo;
    OpenPictureDialog: TOpenPictureDialog;
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonLoadModelClick(Sender: TObject);
    procedure ButtonSelectImageClick(Sender: TObject);
    procedure ButtonClassifyClick(Sender: TObject);
    procedure PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);

  private
    FModelLoaded: Boolean;
    FCurrentImage: string;
    procedure InitializePython;
    procedure LoadModel;
    procedure ClassifyImage;
  end;

var
  FormClassifier: TFormClassifier;

implementation

{$R *.lfm}

procedure TFormClassifier.FormCreate(Sender: TObject);
begin
  FModelLoaded := False;
  FCurrentImage := '';
  InitializePython;
end;

procedure TFormClassifier.FormDestroy(Sender: TObject);
begin
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TFormClassifier.InitializePython;
begin
  try
    // Configuration Ubuntu
    {$IFDEF LINUX}
    PythonEngine1.UseLastKnownVersion := True;
    PythonEngine1.AutoLoad := True;
    {$ENDIF}

    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      LabelStatus.Caption := 'Python ' + PythonEngine1.PyVersion;
      LabelStatus.Font.Color := clGreen;

      MemoLog.Lines.Add('=== Initialisation Python ===');
      MemoLog.Lines.Add('Version : ' + PythonEngine1.PyVersion);

      // Afficher le système
      PythonEngine1.ExecString('import platform');
      MemoLog.Lines.Add('OS : ' + PythonEngine1.EvalString('platform.system()'));
      MemoLog.Lines.Add('Architecture : ' +
        PythonEngine1.EvalString('platform.machine()'));

      ButtonLoadModel.Enabled := True;
    end
    else
    begin
      LabelStatus.Caption := 'Erreur Python';
      LabelStatus.Font.Color := clRed;
      ShowMessage('Impossible d''initialiser Python');
    end;

  except
    on E: Exception do
    begin
      LabelStatus.Caption := 'Erreur : ' + E.Message;
      LabelStatus.Font.Color := clRed;
      ShowMessage('Erreur Python : ' + E.Message);
    end;
  end;
end;

procedure TFormClassifier.ButtonLoadModelClick(Sender: TObject);
begin
  ButtonLoadModel.Enabled := False;
  LabelStatus.Caption := 'Chargement du modèle...';
  Application.ProcessMessages;

  try
    LoadModel;
  finally
    ButtonLoadModel.Enabled := not FModelLoaded;
  end;
end;

procedure TFormClassifier.LoadModel;
begin
  try
    MemoLog.Lines.Add('');
    MemoLog.Lines.Add('=== Chargement du modèle ===');

    // Importer les bibliothèques
    PythonEngine1.ExecString('import tensorflow as tf');
    PythonEngine1.ExecString('import numpy as np');
    PythonEngine1.ExecString('from PIL import Image');

    MemoLog.Lines.Add('✓ TensorFlow importé');

    // Charger le modèle MobileNetV2 pré-entraîné
    PythonEngine1.ExecString(
      'model = tf.keras.applications.MobileNetV2(' +
      'weights="imagenet", include_top=True)'
    );

    MemoLog.Lines.Add('✓ Modèle MobileNetV2 chargé');

    // Préparer les fonctions de traitement
    PythonEngine1.ExecString(
      'preprocess = tf.keras.applications.mobilenet_v2.preprocess_input'
    );
    PythonEngine1.ExecString(
      'decode = tf.keras.applications.mobilenet_v2.decode_predictions'
    );

    FModelLoaded := True;
    LabelStatus.Caption := 'Modèle prêt';
    LabelStatus.Font.Color := clGreen;

    ButtonSelectImage.Enabled := True;

    MemoLog.Lines.Add('✓ Prêt pour la classification');

  except
    on E: Exception do
    begin
      FModelLoaded := False;
      LabelStatus.Caption := 'Erreur chargement';
      LabelStatus.Font.Color := clRed;

      MemoLog.Lines.Add('✗ Erreur : ' + E.Message);

      ShowMessage('Erreur lors du chargement du modèle :' + LineEnding +
                  E.Message + LineEnding + LineEnding +
                  'Installez TensorFlow avec :' + LineEnding +
                  'pip3 install tensorflow pillow');
    end;
  end;
end;

procedure TFormClassifier.ButtonSelectImageClick(Sender: TObject);
begin
  if OpenPictureDialog.Execute then
  begin
    FCurrentImage := OpenPictureDialog.FileName;

    try
      ImagePreview.Picture.LoadFromFile(FCurrentImage);
      ButtonClassify.Enabled := True;
      LabelResult.Caption := 'Résultat : (en attente)';

      MemoLog.Lines.Add('');
      MemoLog.Lines.Add('Image sélectionnée : ' +
        ExtractFileName(FCurrentImage));

    except
      on E: Exception do
        ShowMessage('Erreur chargement image : ' + E.Message);
    end;
  end;
end;

procedure TFormClassifier.ButtonClassifyClick(Sender: TObject);
begin
  if not FModelLoaded then
  begin
    ShowMessage('Veuillez d''abord charger le modèle !');
    Exit;
  end;

  if FCurrentImage = '' then
  begin
    ShowMessage('Veuillez d''abord sélectionner une image !');
    Exit;
  end;

  ButtonClassify.Enabled := False;
  LabelStatus.Caption := 'Classification en cours...';
  Application.ProcessMessages;

  try
    ClassifyImage;
  finally
    ButtonClassify.Enabled := True;
    LabelStatus.Caption := 'Prêt';
  end;
end;

procedure TFormClassifier.ClassifyImage;
var
  PredictionClass: string;
  PredictionScore: string;
  Score: Double;
begin
  try
    MemoLog.Lines.Add('');
    MemoLog.Lines.Add('=== Classification ===');

    // Charger et prétraiter l'image
    PythonEngine1.ExecString(
      Format('img = Image.open(r"%s")', [FCurrentImage])
    );
    PythonEngine1.ExecString('img = img.resize((224, 224))');
    PythonEngine1.ExecString('img_array = np.array(img)');
    PythonEngine1.ExecString('img_array = np.expand_dims(img_array, axis=0)');
    PythonEngine1.ExecString('img_array = preprocess(img_array)');

    MemoLog.Lines.Add('✓ Image prétraitée');

    // Faire la prédiction
    PythonEngine1.ExecString('predictions = model.predict(img_array, verbose=0)');
    PythonEngine1.ExecString('decoded = decode(predictions, top=1)[0][0]');

    // Récupérer les résultats
    PythonEngine1.ExecString('class_name = decoded[1]');
    PythonEngine1.ExecString('confidence = float(decoded[2])');

    PredictionClass := PythonEngine1.EvalString('class_name');
    PredictionScore := PythonEngine1.EvalString('str(confidence)');

    Score := StrToFloat(PredictionScore);

    // Afficher le résultat
    LabelResult.Caption := Format('Résultat : %s (%.1f%%)',
      [PredictionClass, Score * 100]);
    LabelResult.Font.Color := clGreen;
    LabelResult.Font.Style := [fsBold];

    MemoLog.Lines.Add(Format('✓ Prédiction : %s', [PredictionClass]));
    MemoLog.Lines.Add(Format('✓ Confiance : %.1f%%', [Score * 100]));

    // Obtenir le top 3
    PythonEngine1.ExecString('decoded_top3 = decode(predictions, top=3)[0]');
    PythonEngine1.ExecString(
      'top3_str = "\\n".join([f"{i+1}. {p[1]} ({p[2]*100:.1f}%)" ' +
      'for i, p in enumerate(decoded_top3)])'
    );

    var Top3 := PythonEngine1.EvalString('top3_str');

    ShowMessage('Top 3 prédictions :' + LineEnding + LineEnding + Top3);

  except
    on E: Exception do
    begin
      LabelResult.Caption := 'Erreur de classification';
      LabelResult.Font.Color := clRed;

      MemoLog.Lines.Add('✗ Erreur : ' + E.Message);
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;

procedure TFormClassifier.PythonGUIInputOutput1SendData(Sender: TObject;
  const Data: string);
begin
  if Trim(Data) <> '' then
    MemoLog.Lines.Add('[Python] ' + Data);
end;

end.
```

## Utilisation du GPU sur Ubuntu

### Installation des pilotes NVIDIA

Pour utiliser TensorFlow avec GPU sur Ubuntu :

**Étape 1 : Vérifier la carte graphique**

```bash
lspci | grep -i nvidia
```

**Étape 2 : Installer les pilotes NVIDIA**

```bash
# Méthode recommandée (via ubuntu-drivers)
sudo ubuntu-drivers autoinstall

# Redémarrer
sudo reboot

# Vérifier l'installation
nvidia-smi
```

**Sortie attendue de nvidia-smi :**
```
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 525.125.06   Driver Version: 525.125.06   CUDA Version: 12.0     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ... Off   | 00000000:01:00.0 Off |                  N/A |
| 30%   42C    P0    N/A /  N/A |      0MiB /  8192MiB |      0%      Default |
+-------------------------------+----------------------+----------------------+
```

**Étape 3 : Installer CUDA Toolkit**

```bash
# Pour Ubuntu 22.04
wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin
sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600
wget https://developer.download.nvidia.com/compute/cuda/12.0.0/local_installers/cuda-repo-ubuntu2204-12-0-local_12.0.0-525.60.13-1_amd64.deb
sudo dpkg -i cuda-repo-ubuntu2204-12-0-local_12.0.0-525.60.13-1_amd64.deb
sudo cp /var/cuda-repo-ubuntu2204-12-0-local/cuda-*-keyring.gpg /usr/share/keyrings/
sudo apt-get update
sudo apt-get -y install cuda
```

**Étape 4 : Installer cuDNN**

```bash
# Télécharger depuis https://developer.nvidia.com/cudnn (nécessite un compte)
# Puis :
sudo dpkg -i cudnn-local-repo-ubuntu2204-8.x.x.x_1.0-1_amd64.deb
sudo cp /var/cudnn-local-repo-*/cudnn-local-*-keyring.gpg /usr/share/keyrings/
sudo apt-get update
sudo apt-get install libcudnn8 libcudnn8-dev
```

**Étape 5 : Installer TensorFlow GPU**

```bash
pip3 install tensorflow[and-cuda]
# ou pour une version spécifique
pip3 install tensorflow-gpu==2.13.0
```

**Étape 6 : Tester le GPU dans votre application**

```pascal
procedure TForm1.TestGPUClick(Sender: TObject);
var
  GPUAvailable: string;
  GPUDevices: string;
begin
  try
    PythonEngine1.ExecString('import tensorflow as tf');

    // Vérifier la disponibilité du GPU
    PythonEngine1.ExecString('gpu_available = len(tf.config.list_physical_devices("GPU")) > 0');
    GPUAvailable := PythonEngine1.EvalString('str(gpu_available)');

    if GPUAvailable = 'True' then
    begin
      MemoLog.Lines.Add('✓ GPU disponible !');

      // Lister les GPU
      PythonEngine1.ExecString('gpus = tf.config.list_physical_devices("GPU")');
      PythonEngine1.ExecString('gpu_names = [gpu.name for gpu in gpus]');
      GPUDevices := PythonEngine1.EvalString('str(gpu_names)');

      MemoLog.Lines.Add('GPU(s) : ' + GPUDevices);

      // Test de calcul sur GPU
      PythonEngine1.ExecString(
        'with tf.device("/GPU:0"):' + LineEnding +
        '    a = tf.constant([[1.0, 2.0], [3.0, 4.0]])' + LineEnding +
        '    b = tf.constant([[1.0, 1.0], [0.0, 1.0]])' + LineEnding +
        '    c = tf.matmul(a, b)' + LineEnding +
        '    print("Calcul sur GPU réussi:", c.numpy())'
      );
    end
    else
    begin
      MemoLog.Lines.Add('✗ Aucun GPU détecté');
      MemoLog.Lines.Add('TensorFlow utilisera le CPU');
    end;

  except
    on E: Exception do
      ShowMessage('Erreur test GPU : ' + E.Message);
  end;
end;
```

### Configuration de la mémoire GPU

```pascal
procedure TForm1.ConfigureGPUMemory;
begin
  // Permettre la croissance dynamique de la mémoire GPU
  PythonEngine1.ExecString('import tensorflow as tf');
  PythonEngine1.ExecString(
    'gpus = tf.config.list_physical_devices("GPU")' + LineEnding +
    'if gpus:' + LineEnding +
    '    for gpu in gpus:' + LineEnding +
    '        tf.config.experimental.set_memory_growth(gpu, True)'
  );

  // Ou limiter la mémoire GPU à 4GB
  PythonEngine1.ExecString(
    'if gpus:' + LineEnding +
    '    tf.config.set_logical_device_configuration(' + LineEnding +
    '        gpus[0],' + LineEnding +
    '        [tf.config.LogicalDeviceConfiguration(memory_limit=4096)]' + LineEnding +
    '    )'
  );
end;
```

## Scripts shell et automatisation

### Script d'installation des dépendances

Créez un fichier `install_dependencies.sh` :

```bash
#!/bin/bash

echo "=== Installation des dépendances Python pour l'IA ==="

# Mise à jour du système
echo "Mise à jour du système..."
sudo apt update

# Installation de Python et outils
echo "Installation de Python et pip..."
sudo apt install -y python3 python3-pip python3-dev python3-venv

# Installation des bibliothèques IA
echo "Installation des bibliothèques IA..."
pip3 install --upgrade pip
pip3 install numpy pandas matplotlib seaborn
pip3 install scikit-learn xgboost
pip3 install tensorflow
pip3 install torch torchvision
pip3 install opencv-python pillow
pip3 install transformers spacy

# Installation de Jupyter (optionnel)
echo "Installation de Jupyter..."
pip3 install jupyter notebook

# Vérification
echo ""
echo "=== Vérification des installations ==="
python3 -c "import numpy; print('NumPy:', numpy.__version__)"
python3 -c "import pandas; print('Pandas:', pandas.__version__)"
python3 -c "import tensorflow; print('TensorFlow:', tensorflow.__version__)"

echo ""
echo "Installation terminée !"
```

**Rendre le script exécutable et l'exécuter :**

```bash
chmod +x install_dependencies.sh
./install_dependencies.sh
```

### Script de lancement de l'application

Créez `launch_app.sh` :

```bash
#!/bin/bash

# Activer l'environnement virtuel si nécessaire
if [ -d "venv" ]; then
    source venv/bin/activate
fi

# Définir les variables d'environnement
export PYTHONPATH="${PYTHONPATH}:$(pwd)/python_scripts"
export TF_CPP_MIN_LOG_LEVEL=2  # Réduire les logs TensorFlow

# Lancer l'application
./MonApplication

# Désactiver l'environnement virtuel
if [ -d "venv" ]; then
    deactivate
fi
```

**Utilisation :**

```bash
chmod +x launch_app.sh
./launch_app.sh
```

### Intégration dans l'application Lazarus

```pascal
procedure TForm1.ButtonInstallDependenciesClick(Sender: TObject);
var
  Process: TProcess;
  ScriptPath: string;
begin
  ScriptPath := ExtractFilePath(Application.ExeName) + 'install_dependencies.sh';

  if not FileExists(ScriptPath) then
  begin
    ShowMessage('Script d''installation introuvable !');
    Exit;
  end;

  Process := TProcess.Create(nil);
  try
    Process.Executable := 'x-terminal-emulator';
    Process.Parameters.Add('-e');
    Process.Parameters.Add('bash');
    Process.Parameters.Add(ScriptPath);
    Process.Execute;

    ShowMessage('Installation lancée dans un terminal');
  finally
    Process.Free;
  end;
end;
```

## Environnements virtuels Python

### Créer et utiliser un venv

**Créer un environnement virtuel :**

```bash
# Dans le dossier de votre projet
python3 -m venv venv

# Activer
source venv/bin/activate

# Installer les dépendances
pip install tensorflow numpy pandas

# Désactiver
deactivate
```

**Utiliser le venv dans votre application Lazarus :**

```pascal
procedure TForm1.UseVirtualEnvironment;
var
  VenvPath: string;
  PythonExe: string;
  LibPath: string;
begin
  // Chemin vers l'environnement virtuel
  VenvPath := ExtractFilePath(Application.ExeName) + 'venv';

  if not DirectoryExists(VenvPath) then
  begin
    ShowMessage('Environnement virtuel introuvable !');
    Exit;
  end;

  // Configurer PythonEngine pour utiliser le venv
  PythonExe := VenvPath + '/bin/python3';
  LibPath := VenvPath + '/lib';

  // Trouver libpython dans le venv
  PythonEngine1.DllPath := LibPath;
  PythonEngine1.DllName := 'libpython3.10.so';  // Adapter selon version
  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
  begin
    // Ajouter le site-packages du venv au path
    PythonEngine1.ExecString('import sys');
    PythonEngine1.ExecString(
      Format('sys.path.insert(0, "%s/lib/python3.10/site-packages")', [VenvPath])
    );

    ShowMessage('Environnement virtuel chargé !');
  end;
end;
```

### Créer un venv depuis l'application

```pascal
procedure TForm1.CreateVirtualEnvironment;
var
  Process: TProcess;
  VenvPath: string;
begin
  VenvPath := ExtractFilePath(Application.ExeName) + 'venv';

  if DirectoryExists(VenvPath) then
  begin
    if MessageDlg('Un environnement existe déjà. Recréer ?',
                  mtConfirmation, [mbYes, mbNo], 0) = mrNo then
      Exit;

    DeleteDirectory(VenvPath, True);
  end;

  Process := TProcess.Create(nil);
  try
    Process.Executable := 'python3';
    Process.Parameters.Add('-m');
    Process.Parameters.Add('venv');
    Process.Parameters.Add(VenvPath);
    Process.Options := [poWaitOnExit];
    Process.Execute;

    if Process.ExitStatus = 0 then
      ShowMessage('Environnement virtuel créé !' + LineEnding +
                  'Chemin : ' + VenvPath)
    else
      ShowMessage('Erreur lors de la création');

  finally
    Process.Free;
  end;
end;
```

## Déploiement sur Ubuntu

### Structure de déploiement recommandée

```
MonApplication/
├── bin/
│   └── MonApplication              # Exécutable
├── lib/
│   └── x86_64-linux-gnu/          # Bibliothèques si nécessaire
├── share/
│   ├── scripts/                   # Scripts Python
│   │   ├── preprocessing.py
│   │   └── models.py
│   ├── models/                    # Modèles ML
│   │   └── trained_model.h5
│   └── data/                      # Données
├── config/
│   └── app.conf                   # Configuration
├── install.sh                     # Script d'installation
├── uninstall.sh                   # Script de désinstallation
├── requirements.txt               # Dépendances Python
└── README.md                      # Documentation
```

### Fichier requirements.txt

```
numpy>=1.24.0
pandas>=2.0.0
matplotlib>=3.7.0
scikit-learn>=1.3.0
tensorflow>=2.13.0
opencv-python>=4.8.0
pillow>=10.0.0
```

### Script d'installation - install.sh

```bash
#!/bin/bash

APP_NAME="MonApplication"
INSTALL_DIR="/opt/$APP_NAME"
BIN_DIR="/usr/local/bin"
DESKTOP_DIR="/usr/share/applications"

echo "=== Installation de $APP_NAME ==="

# Vérifier les privilèges
if [ "$EUID" -ne 0 ]; then
    echo "Erreur : Ce script doit être exécuté avec sudo"
    exit 1
fi

# Créer les répertoires
echo "Création des répertoires..."
mkdir -p "$INSTALL_DIR"/{bin,share,config}

# Copier les fichiers
echo "Copie des fichiers..."
cp -r bin/* "$INSTALL_DIR/bin/"
cp -r share/* "$INSTALL_DIR/share/"
cp -r config/* "$INSTALL_DIR/config/"

# Rendre l'exécutable... exécutable
chmod +x "$INSTALL_DIR/bin/$APP_NAME"

# Créer un lien symbolique
ln -sf "$INSTALL_DIR/bin/$APP_NAME" "$BIN_DIR/$APP_NAME"

# Installer les dépendances Python
echo "Installation des dépendances Python..."
if [ -f "requirements.txt" ]; then
    pip3 install -r requirements.txt
fi

# Créer un fichier .desktop
cat > "$DESKTOP_DIR/$APP_NAME.desktop" <<EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=$APP_NAME
Comment=Application IA avec FreePascal
Exec=$BIN_DIR/$APP_NAME
Icon=$INSTALL_DIR/share/icon.png
Terminal=false
Categories=Science;Education;
EOF

echo ""
echo "Installation terminée !"
echo "Lancez l'application avec : $APP_NAME"
echo "Ou depuis le menu Applications"
```

**Utilisation :**

```bash
sudo ./install.sh
```

### Créer un paquet .deb

**Structure du paquet :**

```
monapp-1.0/
├── DEBIAN/
│   ├── control
│   ├── postinst
│   └── prerm
├── opt/
│   └── MonApplication/
│       ├── bin/
│       └── share/
└── usr/
    ├── bin/
    └── share/
        └── applications/
```

**Fichier DEBIAN/control :**

```
Package: monapp
Version: 1.0
Section: science
Priority: optional
Architecture: amd64
Depends: python3 (>= 3.8), python3-pip, libpython3.10
Maintainer: Votre Nom <email@example.com>
Description: Application d'IA avec FreePascal
 Application de Machine Learning développée avec FreePascal
 et Python intégré via Python4Lazarus.
```

**Fichier DEBIAN/postinst :**

```bash
#!/bin/bash
set -e

# Installer les dépendances Python
pip3 install -r /opt/MonApplication/requirements.txt

echo "Installation de MonApplication terminée"
```

**Fichier DEBIAN/prerm :**

```bash
#!/bin/bash
set -e

echo "Désinstallation de MonApplication..."
```

**Construire le paquet :**

```bash
# Rendre les scripts exécutables
chmod 755 DEBIAN/postinst DEBIAN/prerm

# Construire le .deb
dpkg-deb --build monapp-1.0

# Installer
sudo dpkg -i monapp-1.0.deb

# Ou désinstaller
sudo dpkg -r monapp
```

### Créer une AppImage

Une AppImage est un format portable qui fonctionne sur toutes les distributions Linux.

**Utiliser appimagetool :**

```bash
# Télécharger appimagetool
wget https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
chmod +x appimagetool-x86_64.AppImage

# Structure de l'AppImage
mkdir -p MonApplication.AppDir/usr/{bin,lib,share}

# Copier les fichiers
cp bin/MonApplication MonApplication.AppDir/usr/bin/
cp -r share/* MonApplication.AppDir/usr/share/

# Créer AppRun
cat > MonApplication.AppDir/AppRun <<'EOF'
#!/bin/bash
SELF=$(readlink -f "$0")
HERE=${SELF%/*}
export PATH="${HERE}/usr/bin:${PATH}"
export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"
export PYTHONPATH="${HERE}/usr/share/scripts:${PYTHONPATH}"
exec "${HERE}/usr/bin/MonApplication" "$@"
EOF

chmod +x MonApplication.AppDir/AppRun

# Créer le .desktop
cp MonApplication.desktop MonApplication.AppDir/

# Créer l'icône
cp icon.png MonApplication.AppDir/

# Construire l'AppImage
./appimagetool-x86_64.AppImage MonApplication.AppDir

# Résultat : MonApplication-x86_64.AppImage
chmod +x MonApplication-x86_64.AppImage

# Exécuter
./MonApplication-x86_64.AppImage
```

## Débogage avancé sur Ubuntu

### Utiliser gdb avec Python et Lazarus

```bash
# Compiler en mode debug
lazbuild --build-mode=Debug MonProjet.lpi

# Lancer avec gdb
gdb ./MonApplication

# Dans gdb
(gdb) run
(gdb) break Unit1.pas:42
(gdb) continue
(gdb) print variable
(gdb) backtrace
```

### Logs système

```pascal
uses
  Unix, BaseUnix;

procedure TForm1.LogToSyslog(const Message: string);
begin
  {$IFDEF LINUX}
  FpSyslog(LOG_INFO, PChar(Message));
  {$ENDIF}
end;

// Utilisation
LogToSyslog('Application démarrée');
LogToSyslog('Modèle ML chargé');
```

**Voir les logs :**

```bash
journalctl -f | grep MonApplication
```

### Monitoring des ressources

```pascal
procedure TForm1.CheckResourceUsage;
var
  MemInfo: string;
begin
  // Utilisation mémoire Python
  PythonEngine1.ExecString('import psutil');
  PythonEngine1.ExecString('import os');

  PythonEngine1.ExecString('process = psutil.Process(os.getpid())');
  PythonEngine1.ExecString('mem_info = process.memory_info()');
  PythonEngine1.ExecString('mem_mb = mem_info.rss / 1024 / 1024');

  MemInfo := PythonEngine1.EvalString('f"{mem_mb:.1f} MB"');

  LabelMemory.Caption := 'Mémoire : ' + MemInfo;
end;
```

## Conclusion et bonnes pratiques Ubuntu

### Points clés à retenir

✅ **Installation** : Python3 pré-installé, utiliser apt et pip
✅ **Chemins** : `/usr/lib`, `/usr/local`, utiliser `/` comme séparateur
✅ **Bibliothèques** : `.so` au lieu de `.dll`
✅ **Permissions** : Gérer sudo et chmod correctement
✅ **GPU** : CUDA et cuDNN pour TensorFlow/PyTorch
✅ **Déploiement** : Scripts shell, .deb, AppImage
✅ **Environnements** : venv ou conda pour isolation

### Avantages d'Ubuntu pour l'IA

- Performance native des bibliothèques Python
- Meilleure gestion GPU/CUDA
- Déploiement serveur simplifié
- Conteneurisation native (Docker)
- Outils de développement intégrés
- Communauté IA très active sur Linux

### Prochaines étapes

Vous maîtrisez maintenant Python4Lazarus sur Ubuntu ! Vous pouvez :

1. Créer des applications IA performantes
2. Utiliser le GPU pour le deep learning
3. Déployer facilement sur serveurs Linux
4. Empaqueter pour distribution (.deb, AppImage)
5. Combiner les avantages de Pascal et Python

# 15.7.2 Python4Lazarus sur Ubuntu (partie 3 - Finale)

## Projets complets d'exemple

### Projet 1 : Serveur d'IA avec interface de monitoring

Application complète qui lance un serveur Flask Python et monitore son activité depuis Lazarus.

```pascal
unit AIServer;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  PythonEngine, PythonGUIInputOutput, Process, ComCtrls;

type
  TFormAIServer = class(TForm)
    ButtonStartServer: TButton;
    ButtonStopServer: TButton;
    ButtonTestAPI: TButton;
    EditPort: TEdit;
    LabelPort: TLabel;
    LabelStatus: TLabel;
    MemoLog: TMemo;
    ProgressBarLoad: TProgressBar;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonStartServerClick(Sender: TObject);
    procedure ButtonStopServerClick(Sender: TObject);
    procedure ButtonTestAPIClick(Sender: TObject);

  private
    FServerRunning: Boolean;
    FServerPort: Integer;
    procedure InitializePython;
    procedure StartFlaskServer;
    procedure StopFlaskServer;
    procedure TestAPIEndpoint;
    procedure UpdateStatus(const Status: string; IsRunning: Boolean);
  end;

var
  FormAIServer: TFormAIServer;

implementation

uses
  fphttpclient, fpjson, jsonparser;

{$R *.lfm}

procedure TFormAIServer.FormCreate(Sender: TObject);
begin
  FServerRunning := False;
  FServerPort := 5000;
  EditPort.Text := '5000';

  InitializePython;
end;

procedure TFormAIServer.FormDestroy(Sender: TObject);
begin
  if FServerRunning then
    StopFlaskServer;

  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TFormAIServer.InitializePython;
begin
  try
    {$IFDEF LINUX}
    PythonEngine1.UseLastKnownVersion := True;
    PythonEngine1.AutoLoad := True;
    {$ENDIF}

    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      MemoLog.Lines.Add('✓ Python ' + PythonEngine1.PyVersion + ' initialisé');

      // Vérifier Flask
      try
        PythonEngine1.ExecString('import flask');
        MemoLog.Lines.Add('✓ Flask disponible');
        ButtonStartServer.Enabled := True;
      except
        MemoLog.Lines.Add('✗ Flask non installé');
        MemoLog.Lines.Add('  Installez avec : pip3 install flask');
        ButtonStartServer.Enabled := False;
      end;
    end
    else
    begin
      MemoLog.Lines.Add('✗ Erreur initialisation Python');
    end;

  except
    on E: Exception do
      MemoLog.Lines.Add('✗ Erreur : ' + E.Message);
  end;
end;

procedure TFormAIServer.ButtonStartServerClick(Sender: TObject);
begin
  FServerPort := StrToIntDef(EditPort.Text, 5000);
  StartFlaskServer;
end;

procedure TFormAIServer.StartFlaskServer;
var
  ServerCode: string;
begin
  try
    MemoLog.Lines.Add('');
    MemoLog.Lines.Add('=== Démarrage du serveur ===');

    // Code du serveur Flask
    ServerCode :=
      'from flask import Flask, request, jsonify' + LineEnding +
      'import threading' + LineEnding +
      'import numpy as np' + LineEnding +
      '' + LineEnding +
      'app = Flask(__name__)' + LineEnding +
      '' + LineEnding +
      '@app.route("/")' + LineEnding +
      'def home():' + LineEnding +
      '    return jsonify({"status": "running", "service": "AI Server"})' + LineEnding +
      '' + LineEnding +
      '@app.route("/predict", methods=["POST"])' + LineEnding +
      'def predict():' + LineEnding +
      '    data = request.json' + LineEnding +
      '    # Simulation de prédiction' + LineEnding +
      '    result = {"prediction": "classe_A", "confidence": 0.87}' + LineEnding +
      '    return jsonify(result)' + LineEnding +
      '' + LineEnding +
      '@app.route("/health")' + LineEnding +
      'def health():' + LineEnding +
      '    return jsonify({"status": "healthy"})' + LineEnding +
      '' + LineEnding +
      'def run_server():' + LineEnding +
      Format('    app.run(host="0.0.0.0", port=%d, debug=False)', [FServerPort]) + LineEnding +
      '' + LineEnding +
      'server_thread = threading.Thread(target=run_server, daemon=True)' + LineEnding +
      'server_thread.start()';

    PythonEngine1.ExecString(ServerCode);

    FServerRunning := True;
    UpdateStatus(Format('Serveur actif sur le port %d', [FServerPort]), True);

    MemoLog.Lines.Add('✓ Serveur démarré');
    MemoLog.Lines.Add(Format('  URL : http://localhost:%d', [FServerPort]));

    ButtonStartServer.Enabled := False;
    ButtonStopServer.Enabled := True;
    ButtonTestAPI.Enabled := True;
    EditPort.Enabled := False;

    // Attendre un peu que le serveur démarre
    Sleep(1000);

  except
    on E: Exception do
    begin
      MemoLog.Lines.Add('✗ Erreur démarrage : ' + E.Message);
      FServerRunning := False;
    end;
  end;
end;

procedure TFormAIServer.ButtonStopServerClick(Sender: TObject);
begin
  StopFlaskServer;
end;

procedure TFormAIServer.StopFlaskServer;
begin
  FServerRunning := False;
  UpdateStatus('Serveur arrêté', False);

  MemoLog.Lines.Add('');
  MemoLog.Lines.Add('✓ Serveur arrêté');

  ButtonStartServer.Enabled := True;
  ButtonStopServer.Enabled := False;
  ButtonTestAPI.Enabled := False;
  EditPort.Enabled := True;
end;

procedure TFormAIServer.ButtonTestAPIClick(Sender: TObject);
begin
  TestAPIEndpoint;
end;

procedure TFormAIServer.TestAPIEndpoint;
var
  HTTPClient: TFPHTTPClient;
  Response: string;
  JSONData: TJSONData;
  URL: string;
begin
  try
    MemoLog.Lines.Add('');
    MemoLog.Lines.Add('=== Test de l''API ===');

    HTTPClient := TFPHTTPClient.Create(nil);
    try
      // Test endpoint /
      URL := Format('http://localhost:%d/', [FServerPort]);
      MemoLog.Lines.Add('GET ' + URL);

      Response := HTTPClient.Get(URL);
      MemoLog.Lines.Add('Réponse : ' + Response);

      JSONData := GetJSON(Response);
      try
        MemoLog.Lines.Add('  Status : ' + JSONData.FindPath('status').AsString);
        MemoLog.Lines.Add('  Service : ' + JSONData.FindPath('service').AsString);
      finally
        JSONData.Free;
      end;

      // Test endpoint /health
      URL := Format('http://localhost:%d/health', [FServerPort]);
      MemoLog.Lines.Add('');
      MemoLog.Lines.Add('GET ' + URL);

      Response := HTTPClient.Get(URL);
      MemoLog.Lines.Add('Réponse : ' + Response);

      MemoLog.Lines.Add('');
      MemoLog.Lines.Add('✓ Tests réussis');

    finally
      HTTPClient.Free;
    end;

  except
    on E: Exception do
    begin
      MemoLog.Lines.Add('✗ Erreur test : ' + E.Message);
      MemoLog.Lines.Add('  Le serveur est-il démarré ?');
    end;
  end;
end;

procedure TFormAIServer.UpdateStatus(const Status: string; IsRunning: Boolean);
begin
  LabelStatus.Caption := 'Status : ' + Status;

  if IsRunning then
  begin
    LabelStatus.Font.Color := clGreen;
    LabelStatus.Caption := LabelStatus.Caption + ' 🟢';
  end
  else
  begin
    LabelStatus.Font.Color := clRed;
    LabelStatus.Caption := LabelStatus.Caption + ' 🔴';
  end;
end;

end.
```

### Projet 2 : Analyseur de logs avec ML

Application qui analyse des fichiers de logs système et détecte des anomalies.

```pascal
unit LogAnalyzer;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  ComCtrls, Grids, PythonEngine;

type
  TFormLogAnalyzer = class(TForm)
    ButtonLoadLog: TButton;
    ButtonAnalyze: TButton;
    ButtonExport: TButton;
    MemoLogContent: TMemo;
    StringGridResults: TStringGrid;
    ProgressBar1: TProgressBar;
    LabelStats: TLabel;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure ButtonLoadLogClick(Sender: TObject);
    procedure ButtonAnalyzeClick(Sender: TObject);
    procedure ButtonExportClick(Sender: TObject);

  private
    FLogPath: string;
    procedure InitializePython;
    procedure LoadSystemLog(const LogPath: string);
    procedure AnalyzeLog;
    procedure DisplayResults;
  end;

var
  FormLogAnalyzer: TFormLogAnalyzer;

implementation

{$R *.lfm}

procedure TFormLogAnalyzer.FormCreate(Sender: TObject);
begin
  InitializePython;

  // Configuration de la grille
  StringGridResults.ColCount := 4;
  StringGridResults.RowCount := 1;
  StringGridResults.Cells[0, 0] := 'Timestamp';
  StringGridResults.Cells[1, 0] := 'Type';
  StringGridResults.Cells[2, 0] := 'Message';
  StringGridResults.Cells[3, 0] := 'Score anomalie';
end;

procedure TFormLogAnalyzer.InitializePython;
begin
  try
    {$IFDEF LINUX}
    PythonEngine1.UseLastKnownVersion := True;
    PythonEngine1.LoadDll;
    {$ENDIF}

    if PythonEngine1.Initialized then
    begin
      // Importer les bibliothèques nécessaires
      PythonEngine1.ExecString('import pandas as pd');
      PythonEngine1.ExecString('import numpy as np');
      PythonEngine1.ExecString('from sklearn.ensemble import IsolationForest');
      PythonEngine1.ExecString('from sklearn.feature_extraction.text import TfidfVectorizer');
      PythonEngine1.ExecString('import re');

      ButtonLoadLog.Enabled := True;
    end;

  except
    on E: Exception do
      ShowMessage('Erreur Python : ' + E.Message);
  end;
end;

procedure TFormLogAnalyzer.ButtonLoadLogClick(Sender: TObject);
var
  OpenDialog: TOpenDialog;
begin
  OpenDialog := TOpenDialog.Create(nil);
  try
    OpenDialog.Filter := 'Fichiers log|*.log;*.txt|Tous|*.*';
    OpenDialog.InitialDir := '/var/log';

    if OpenDialog.Execute then
    begin
      FLogPath := OpenDialog.FileName;
      LoadSystemLog(FLogPath);
    end;
  finally
    OpenDialog.Free;
  end;
end;

procedure TFormLogAnalyzer.LoadSystemLog(const LogPath: string);
var
  LogLines: TStringList;
begin
  try
    LogLines := TStringList.Create;
    try
      LogLines.LoadFromFile(LogPath);

      MemoLogContent.Lines.Clear;
      MemoLogContent.Lines.AddStrings(LogLines);

      LabelStats.Caption := Format('%d lignes chargées', [LogLines.Count]);

      // Charger dans Python
      PythonEngine1.ExecString(
        Format('log_path = r"%s"', [LogPath])
      );
      PythonEngine1.ExecString(
        'with open(log_path, "r") as f:' + LineEnding +
        '    log_lines = f.readlines()'
      );

      ButtonAnalyze.Enabled := True;

    finally
      LogLines.Free;
    end;

  except
    on E: Exception do
      ShowMessage('Erreur chargement : ' + E.Message);
  end;
end;

procedure TFormLogAnalyzer.ButtonAnalyzeClick(Sender: TObject);
begin
  ButtonAnalyze.Enabled := False;
  ProgressBar1.Style := pbstMarquee;

  try
    AnalyzeLog;
    DisplayResults;
  finally
    ButtonAnalyze.Enabled := True;
    ProgressBar1.Style := pbstNormal;
  end;
end;

procedure TFormLogAnalyzer.AnalyzeLog;
begin
  try
    // Prétraitement des logs
    PythonEngine1.ExecString(
      '# Extraire timestamp, type et message' + LineEnding +
      'import re' + LineEnding +
      'pattern = r"(\w+\s+\d+\s+\d+:\d+:\d+)\s+(\w+)\s+(.*)"' + LineEnding +
      'parsed_logs = []' + LineEnding +
      'for line in log_lines:' + LineEnding +
      '    match = re.search(pattern, line)' + LineEnding +
      '    if match:' + LineEnding +
      '        parsed_logs.append({' + LineEnding +
      '            "timestamp": match.group(1),' + LineEnding +
      '            "type": match.group(2),' + LineEnding +
      '            "message": match.group(3)' + LineEnding +
      '        })'
    );

    // Créer un DataFrame
    PythonEngine1.ExecString('df = pd.DataFrame(parsed_logs)');

    // Vectorisation TF-IDF
    PythonEngine1.ExecString(
      'if len(df) > 0:' + LineEnding +
      '    vectorizer = TfidfVectorizer(max_features=100)' + LineEnding +
      '    X = vectorizer.fit_transform(df["message"].fillna(""))' + LineEnding +
      '    ' + LineEnding +
      '    # Détection d''anomalies' + LineEnding +
      '    clf = IsolationForest(contamination=0.1, random_state=42)' + LineEnding +
      '    df["anomaly_score"] = clf.fit_predict(X.toarray())' + LineEnding +
      '    df["is_anomaly"] = df["anomaly_score"] == -1'
    );

    // Résumé
    PythonEngine1.ExecString(
      'anomaly_count = df["is_anomaly"].sum()' + LineEnding +
      'total_count = len(df)'
    );

    var AnomalyCount := PythonEngine1.EvalString('str(anomaly_count)');
    var TotalCount := PythonEngine1.EvalString('str(total_count)');

    LabelStats.Caption := Format('Anomalies détectées : %s / %s',
      [AnomalyCount, TotalCount]);

  except
    on E: Exception do
      ShowMessage('Erreur analyse : ' + E.Message);
  end;
end;

procedure TFormLogAnalyzer.DisplayResults;
var
  RowCount: Integer;
  i: Integer;
  RowData: string;
  Cells: TStringArray;
begin
  try
    // Obtenir le nombre de lignes
    RowCount := StrToInt(PythonEngine1.EvalString('str(len(df))'));

    if RowCount = 0 then
      Exit;

    StringGridResults.RowCount := RowCount + 1;

    // Remplir la grille (limiter à 100 premières anomalies)
    PythonEngine1.ExecString(
      'anomalies = df[df["is_anomaly"]].head(100)' + LineEnding +
      'result_rows = []' + LineEnding +
      'for _, row in anomalies.iterrows():' + LineEnding +
      '    result_rows.append("|".join([' + LineEnding +
      '        str(row["timestamp"]),' + LineEnding +
      '        str(row["type"]),' + LineEnding +
      '        str(row["message"][:50]),' + LineEnding +
      '        str(row["anomaly_score"])' + LineEnding +
      '    ]))'
    );

    PythonEngine1.ExecString('result_str = "\n".join(result_rows)');

    var Results := PythonEngine1.EvalString('result_str');
    var ResultLines := Results.Split([LineEnding]);

    for i := 0 to High(ResultLines) do
    begin
      if Trim(ResultLines[i]) = '' then
        Continue;

      Cells := ResultLines[i].Split(['|']);

      if Length(Cells) >= 4 then
      begin
        StringGridResults.Cells[0, i + 1] := Cells[0];
        StringGridResults.Cells[1, i + 1] := Cells[1];
        StringGridResults.Cells[2, i + 1] := Cells[2];
        StringGridResults.Cells[3, i + 1] := Cells[3];
      end;
    end;

    ButtonExport.Enabled := True;

  except
    on E: Exception do
      ShowMessage('Erreur affichage : ' + E.Message);
  end;
end;

procedure TFormLogAnalyzer.ButtonExportClick(Sender: TObject);
var
  SaveDialog: TSaveDialog;
  ExportPath: string;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Filter := 'CSV|*.csv';
    SaveDialog.DefaultExt := 'csv';
    SaveDialog.FileName := 'anomalies.csv';

    if SaveDialog.Execute then
    begin
      ExportPath := SaveDialog.FileName;

      PythonEngine1.ExecString(
        Format('anomalies = df[df["is_anomaly"]]' + LineEnding +
               'anomalies.to_csv(r"%s", index=False)', [ExportPath])
      );

      ShowMessage('Export réussi : ' + ExportPath);
    end;
  finally
    SaveDialog.Free;
  end;
end;

end.
```

### Projet 3 : Reconnaissance vocale en temps réel

Application utilisant Whisper pour la transcription vocale en temps réel.

```pascal
unit VoiceRecognition;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  PythonEngine, Process;

type
  TFormVoice = class(TForm)
    ButtonLoadModel: TButton;
    ButtonRecord: TButton;
    ButtonStop: TButton;
    ButtonTranscribe: TButton;
    MemoTranscription: TMemo;
    LabelStatus: TLabel;
    TimerRecording: TTimer;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure ButtonLoadModelClick(Sender: TObject);
    procedure ButtonRecordClick(Sender: TObject);
    procedure ButtonStopClick(Sender: TObject);
    procedure ButtonTranscribeClick(Sender: TObject);
    procedure TimerRecordingTimer(Sender: TObject);

  private
    FModelLoaded: Boolean;
    FRecording: Boolean;
    FRecordProcess: TProcess;
    FAudioFile: string;

    procedure InitializePython;
    procedure LoadWhisperModel;
    procedure StartRecording;
    procedure StopRecording;
    procedure TranscribeAudio;
  end;

var
  FormVoice: TFormVoice;

implementation

{$R *.lfm}

procedure TFormVoice.FormCreate(Sender: TObject);
begin
  FModelLoaded := False;
  FRecording := False;
  FAudioFile := GetTempDir + 'recording.wav';

  InitializePython;
end;

procedure TFormVoice.InitializePython;
begin
  try
    {$IFDEF LINUX}
    PythonEngine1.UseLastKnownVersion := True;
    PythonEngine1.LoadDll;
    {$ENDIF}

    if PythonEngine1.Initialized then
    begin
      LabelStatus.Caption := 'Python initialisé';
      ButtonLoadModel.Enabled := True;
    end;

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;

procedure TFormVoice.ButtonLoadModelClick(Sender: TObject);
begin
  ButtonLoadModel.Enabled := False;
  LabelStatus.Caption := 'Chargement du modèle Whisper...';
  Application.ProcessMessages;

  LoadWhisperModel;
end;

procedure TFormVoice.LoadWhisperModel;
begin
  try
    // Importer Whisper
    PythonEngine1.ExecString('import whisper');

    MemoTranscription.Lines.Add('✓ Whisper importé');

    // Charger le modèle (base ou tiny pour plus rapide)
    LabelStatus.Caption := 'Chargement du modèle (peut prendre du temps)...';
    Application.ProcessMessages;

    PythonEngine1.ExecString('model = whisper.load_model("base")');

    FModelLoaded := True;
    LabelStatus.Caption := 'Modèle Whisper chargé et prêt';
    ButtonRecord.Enabled := True;

    MemoTranscription.Lines.Add('✓ Modèle chargé');
    MemoTranscription.Lines.Add('');
    MemoTranscription.Lines.Add('Prêt pour l''enregistrement !');

  except
    on E: Exception do
    begin
      LabelStatus.Caption := 'Erreur chargement';
      ShowMessage('Erreur : ' + E.Message + LineEnding + LineEnding +
                  'Installez Whisper avec :' + LineEnding +
                  'pip3 install openai-whisper');
      ButtonLoadModel.Enabled := True;
    end;
  end;
end;

procedure TFormVoice.ButtonRecordClick(Sender: TObject);
begin
  StartRecording;
end;

procedure TFormVoice.StartRecording;
begin
  // Utiliser arecord (ALSA) pour enregistrer
  FRecordProcess := TProcess.Create(nil);
  try
    FRecordProcess.Executable := 'arecord';
    FRecordProcess.Parameters.Add('-f');
    FRecordProcess.Parameters.Add('cd');  // CD quality
    FRecordProcess.Parameters.Add('-t');
    FRecordProcess.Parameters.Add('wav');
    FRecordProcess.Parameters.Add(FAudioFile);

    FRecordProcess.Execute;

    FRecording := True;
    LabelStatus.Caption := 'Enregistrement en cours... 🔴';
    LabelStatus.Font.Color := clRed;

    ButtonRecord.Enabled := False;
    ButtonStop.Enabled := True;
    TimerRecording.Enabled := True;

    MemoTranscription.Lines.Add('');
    MemoTranscription.Lines.Add('🎤 Enregistrement démarré...');

  except
    on E: Exception do
    begin
      ShowMessage('Erreur enregistrement : ' + E.Message + LineEnding +
                  'Installez arecord avec : sudo apt install alsa-utils');
      FRecordProcess.Free;
    end;
  end;
end;

procedure TFormVoice.ButtonStopClick(Sender: TObject);
begin
  StopRecording;
end;

procedure TFormVoice.StopRecording;
begin
  if FRecordProcess <> nil then
  begin
    FRecordProcess.Terminate(0);
    Sleep(500);
    FRecordProcess.Free;
    FRecordProcess := nil;
  end;

  FRecording := False;
  TimerRecording.Enabled := False;

  LabelStatus.Caption := 'Enregistrement terminé';
  LabelStatus.Font.Color := clGreen;

  ButtonRecord.Enabled := True;
  ButtonStop.Enabled := False;
  ButtonTranscribe.Enabled := True;

  MemoTranscription.Lines.Add('✓ Enregistrement sauvegardé');
end;

procedure TFormVoice.TimerRecordingTimer(Sender: TObject);
begin
  // Afficher un indicateur visuel pendant l'enregistrement
  if LabelStatus.Caption.EndsWith('🔴') then
    LabelStatus.Caption := 'Enregistrement en cours...'
  else
    LabelStatus.Caption := 'Enregistrement en cours... 🔴';
end;

procedure TFormVoice.ButtonTranscribeClick(Sender: TObject);
begin
  ButtonTranscribe.Enabled := False;
  LabelStatus.Caption := 'Transcription en cours...';
  Application.ProcessMessages;

  try
    TranscribeAudio;
  finally
    ButtonTranscribe.Enabled := True;
    LabelStatus.Caption := 'Transcription terminée';
  end;
end;

procedure TFormVoice.TranscribeAudio;
var
  Transcription: string;
  Language: string;
begin
  try
    if not FileExists(FAudioFile) then
    begin
      ShowMessage('Fichier audio introuvable !');
      Exit;
    end;

    MemoTranscription.Lines.Add('');
    MemoTranscription.Lines.Add('=== Transcription ===');

    // Transcrire avec Whisper
    PythonEngine1.ExecString(
      Format('result = model.transcribe(r"%s", fp16=False)', [FAudioFile])
    );

    // Récupérer le texte
    PythonEngine1.ExecString('text = result["text"]');
    Transcription := PythonEngine1.EvalString('text');

    // Récupérer la langue
    PythonEngine1.ExecString('lang = result["language"]');
    Language := PythonEngine1.EvalString('lang');

    // Afficher
    MemoTranscription.Lines.Add('Langue détectée : ' + Language);
    MemoTranscription.Lines.Add('');
    MemoTranscription.Lines.Add('Texte :');
    MemoTranscription.Lines.Add(Transcription);

  except
    on E: Exception do
      ShowMessage('Erreur transcription : ' + E.Message);
  end;
end;

end.
```

## Intégration avec les outils système Ubuntu

### Notifications système (notify-send)

```pascal
procedure TForm1.SendSystemNotification(const Title, Message: string);
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    Process.Executable := 'notify-send';
    Process.Parameters.Add(Title);
    Process.Parameters.Add(Message);
    Process.Parameters.Add('--icon=dialog-information');
    Process.Execute;
  finally
    Process.Free;
  end;
end;

// Utilisation
SendSystemNotification('Analyse terminée', 'Aucune anomalie détectée');
```

### Intégration avec systemd (services)

Créer un fichier de service `/etc/systemd/system/monapp-ai.service` :

```ini
[Unit]
Description=Mon Application IA
After=network.target

[Service]
Type=simple
User=monuser
WorkingDirectory=/opt/MonApplication
ExecStart=/opt/MonApplication/bin/MonApplication --headless
Restart=on-failure
RestartSec=10

# Variables d'environnement Python
Environment="PYTHONPATH=/opt/MonApplication/scripts"
Environment="TF_CPP_MIN_LOG_LEVEL=2"

[Install]
WantedBy=multi-user.target
```

**Commandes systemd :**

```bash
# Recharger systemd
sudo systemctl daemon-reload

# Activer le service au démarrage
sudo systemctl enable monapp-ai

# Démarrer le service
sudo systemctl start monapp-ai

# Voir le statut
sudo systemctl status monapp-ai

# Voir les logs
journalctl -u monapp-ai -f
```

### Cron jobs pour tâches planifiées

```bash
# Éditer le crontab
crontab -e

# Ajouter une tâche (exemple : analyse quotidienne à 2h du matin)
0 2 * * * /opt/MonApplication/bin/MonApplication --analyze-daily >> /var/log/monapp.log 2>&1

# Tâche toutes les heures
0 * * * * /opt/MonApplication/bin/MonApplication --check-anomalies
```

**Supporter les arguments en ligne de commande dans votre app :**

```pascal
procedure TForm1.FormCreate(Sender: TObject);
var
  i: Integer;
  Param: string;
  HeadlessMode: Boolean;
begin
  HeadlessMode := False;

  // Parcourir les arguments
  for i := 1 to ParamCount do
  begin
    Param := ParamStr(i);

    case Param of
      '--headless':
      begin
        HeadlessMode := True;
        Application.ShowMainForm := False;
      end;

      '--analyze-daily':
      begin
        InitializePython;
        RunDailyAnalysis;
        Application.Terminate;
      end;

      '--check-anomalies':
      begin
        InitializePython;
        CheckAnomalies;
        Application.Terminate;
      end;

      '--version':
      begin
        WriteLn('MonApplication v1.0');
        WriteLn('Python: ' + GetPythonVersion);
        Application.Terminate;
      end;

      '--help':
      begin
        WriteLn('Usage: MonApplication [options]');
        WriteLn('Options:');
        WriteLn('  --headless          Mode sans interface');
        WriteLn('  --analyze-daily     Analyse quotidienne');
        WriteLn('  --check-anomalies   Vérification anomalies');
        WriteLn('  --version           Afficher la version');
        WriteLn('  --help              Afficher cette aide');
        Application.Terminate;
      end;
    end;
  end;

  if not HeadlessMode then
    InitializePython;
end;

procedure TForm1.RunDailyAnalysis;
begin
  // Code pour l'analyse quotidienne
  WriteLn('Démarrage de l''analyse quotidienne...');

  try
    PythonEngine1.ExecString('from datetime import datetime');
    PythonEngine1.ExecString('import logging');
    PythonEngine1.ExecString('logging.basicConfig(filename="/var/log/monapp/daily.log")');

    // Votre logique d'analyse
    PythonEngine1.ExecString('print(f"Analyse lancée à {datetime.now()}")');

    WriteLn('Analyse terminée avec succès');

  except
    on E: Exception do
      WriteLn('Erreur: ' + E.Message);
  end;
end;
```

### Intégration avec D-Bus

D-Bus permet la communication entre applications sur Ubuntu :

```pascal
uses
  Process;

procedure TForm1.SendDBusNotification(const Summary, Body: string);
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    Process.Executable := 'dbus-send';
    Process.Parameters.Add('--session');
    Process.Parameters.Add('--type=method_call');
    Process.Parameters.Add('--dest=org.freedesktop.Notifications');
    Process.Parameters.Add('/org/freedesktop/Notifications');
    Process.Parameters.Add('org.freedesktop.Notifications.Notify');
    Process.Parameters.Add('string:MonApplication');
    Process.Parameters.Add('uint32:0');
    Process.Parameters.Add('string:');
    Process.Parameters.Add('string:' + Summary);
    Process.Parameters.Add('string:' + Body);
    Process.Parameters.Add('array:string:');
    Process.Parameters.Add('dict:string:string:');
    Process.Parameters.Add('int32:5000');

    Process.Execute;
  finally
    Process.Free;
  end;
end;

// Utilisation
SendDBusNotification('Analyse IA', 'Traitement terminé avec succès');
```

## Optimisations spécifiques Ubuntu

### Utilisation de la mémoire partagée

Pour des performances optimales avec de gros volumes de données :

```pascal
procedure TForm1.UseSharedMemory;
begin
  // Activer la mémoire partagée pour numpy
  PythonEngine1.ExecString('import os');
  PythonEngine1.ExecString('os.environ["OPENBLAS_NUM_THREADS"] = "4"');
  PythonEngine1.ExecString('os.environ["MKL_NUM_THREADS"] = "4"');

  // Optimiser TensorFlow pour CPU
  PythonEngine1.ExecString('import tensorflow as tf');
  PythonEngine1.ExecString(
    'tf.config.threading.set_inter_op_parallelism_threads(4)' + LineEnding +
    'tf.config.threading.set_intra_op_parallelism_threads(4)'
  );
end;
```

### Profiling avec perf

Analyser les performances sur Ubuntu :

```bash
# Compiler avec informations de debug
lazbuild --build-mode=Debug MonProjet.lpi

# Profiler avec perf
perf record -g ./MonApplication

# Analyser les résultats
perf report

# Voir les hotspots
perf top
```

### Surveillance de la consommation mémoire

```pascal
procedure TForm1.MonitorMemoryUsage;
var
  MemUsage: string;
  CPUUsage: string;
begin
  try
    PythonEngine1.ExecString('import psutil');
    PythonEngine1.ExecString('import os');

    // Mémoire du processus
    PythonEngine1.ExecString(
      'process = psutil.Process(os.getpid())' + LineEnding +
      'mem_info = process.memory_info()' + LineEnding +
      'mem_mb = mem_info.rss / 1024 / 1024' + LineEnding +
      'cpu_percent = process.cpu_percent(interval=1)'
    );

    MemUsage := PythonEngine1.EvalString('f"{mem_mb:.1f}"');
    CPUUsage := PythonEngine1.EvalString('f"{cpu_percent:.1f}"');

    LabelStats.Caption := Format('Mémoire: %s MB | CPU: %s%%',
      [MemUsage, CPUUsage]);

    // Log si usage élevé
    if StrToFloat(MemUsage) > 1000 then
    begin
      WriteLn('ATTENTION: Usage mémoire élevé: ' + MemUsage + ' MB');

      // Forcer le garbage collector Python
      PythonEngine1.ExecString('import gc');
      PythonEngine1.ExecString('gc.collect()');
    end;

  except
    on E: Exception do
      WriteLn('Erreur monitoring: ' + E.Message);
  end;
end;
```

## Gestion multi-utilisateurs

### Permissions et accès fichiers

```pascal
function TForm1.CheckFilePermissions(const FilePath: string): Boolean;
var
  Info: stat;
begin
  Result := False;

  if FpStat(FilePath, Info) = 0 then
  begin
    // Vérifier les permissions de lecture
    Result := (Info.st_mode and S_IRUSR) <> 0;

    if not Result then
      ShowMessage('Permissions insuffisantes pour lire: ' + FilePath);
  end
  else
    ShowMessage('Impossible d''accéder au fichier: ' + FilePath);
end;

procedure TForm1.SetFilePermissions(const FilePath: string; Mode: Integer);
begin
  if FpChmod(FilePath, Mode) <> 0 then
    ShowMessage('Erreur lors de la modification des permissions');
end;

// Utilisation
SetFilePermissions('/tmp/output.csv', &644); // rw-r--r--
```

### Configuration par utilisateur

```pascal
function TForm1.GetUserConfigPath: string;
var
  HomeDir: string;
begin
  HomeDir := GetEnvironmentVariable('HOME');
  Result := HomeDir + '/.config/MonApplication';

  // Créer le dossier s'il n'existe pas
  if not DirectoryExists(Result) then
    CreateDir(Result);
end;

procedure TForm1.LoadUserConfig;
var
  ConfigPath: string;
  Config: TStringList;
begin
  ConfigPath := GetUserConfigPath + '/config.ini';

  if FileExists(ConfigPath) then
  begin
    Config := TStringList.Create;
    try
      Config.LoadFromFile(ConfigPath);

      // Charger la configuration
      FPythonPath := Config.Values['PythonPath'];
      FModelPath := Config.Values['ModelPath'];

    finally
      Config.Free;
    end;
  end;
end;

procedure TForm1.SaveUserConfig;
var
  ConfigPath: string;
  Config: TStringList;
begin
  ConfigPath := GetUserConfigPath + '/config.ini';

  Config := TStringList.Create;
  try
    Config.Add('PythonPath=' + FPythonPath);
    Config.Add('ModelPath=' + FModelPath);
    Config.Add('LastUsed=' + DateTimeToStr(Now));

    Config.SaveToFile(ConfigPath);
  finally
    Config.Free;
  end;
end;
```

## Tests et CI/CD sur Ubuntu

### Tests unitaires avec FPCUnit

```pascal
unit TestAIFunctions;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, fpcunit, testregistry, PythonEngine;

type
  TTestAI = class(TTestCase)
  private
    FPythonEngine: TPythonEngine;
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestPythonInitialization;
    procedure TestModelLoading;
    procedure TestPrediction;
  end;

implementation

procedure TTestAI.SetUp;
begin
  FPythonEngine := TPythonEngine.Create(nil);
  FPythonEngine.UseLastKnownVersion := True;
  FPythonEngine.LoadDll;
end;

procedure TTestAI.TearDown;
begin
  if FPythonEngine.Initialized then
    FPythonEngine.Finalize;
  FPythonEngine.Free;
end;

procedure TTestAI.TestPythonInitialization;
begin
  AssertTrue('Python devrait être initialisé', FPythonEngine.Initialized);
  AssertTrue('Version Python devrait commencer par 3',
    FPythonEngine.PyVersion.StartsWith('3'));
end;

procedure TTestAI.TestModelLoading;
begin
  try
    FPythonEngine.ExecString('import numpy as np');
    AssertTrue('NumPy devrait être importable', True);
  except
    Fail('Impossible d''importer NumPy');
  end;
end;

procedure TTestAI.TestPrediction;
var
  Result: string;
begin
  FPythonEngine.ExecString('result = 2 + 2');
  Result := FPythonEngine.EvalString('str(result)');
  AssertEquals('2+2 devrait égaler 4', '4', Result);
end;

initialization
  RegisterTest(TTestAI);

end.
```

**Exécuter les tests :**

```bash
# Compiler les tests
lazbuild tests/TestSuite.lpi

# Exécuter
./tests/TestSuite --all --format=plain

# Avec sortie XML pour CI
./tests/TestSuite --all --format=xml --output=test-results.xml
```

### GitHub Actions pour Ubuntu

Créer `.github/workflows/ubuntu-build.yml` :

```yaml
name: Build Ubuntu

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - uses: actions/checkout@v3

    - name: Install Lazarus
      run: |
        sudo add-apt-repository ppa:lazarus-team/lazarus
        sudo apt-get update
        sudo apt-get install -y lazarus lcl fp-compiler

    - name: Install Python dependencies
      run: |
        sudo apt-get install -y python3 python3-pip python3-dev
        pip3 install numpy pandas tensorflow scikit-learn

    - name: Build application
      run: |
        lazbuild --build-all --build-mode=Release MonProjet.lpi

    - name: Run tests
      run: |
        lazbuild tests/TestSuite.lpi
        ./tests/TestSuite --all --format=xml --output=test-results.xml

    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results
        path: test-results.xml

    - name: Upload artifact
      uses: actions/upload-artifact@v3
      with:
        name: ubuntu-build
        path: bin/MonApplication
```

### GitLab CI pour Ubuntu

Créer `.gitlab-ci.yml` :

```yaml
image: ubuntu:22.04

variables:
  GIT_SUBMODULE_STRATEGY: recursive

stages:
  - build
  - test
  - deploy

before_script:
  - apt-get update -qq
  - apt-get install -y -qq lazarus lcl fp-compiler python3 python3-pip
  - pip3 install numpy pandas tensorflow scikit-learn

build:
  stage: build
  script:
    - lazbuild --build-all --build-mode=Release MonProjet.lpi
  artifacts:
    paths:
      - bin/MonApplication
    expire_in: 1 week

test:
  stage: test
  script:
    - lazbuild tests/TestSuite.lpi
    - ./tests/TestSuite --all --format=xml --output=test-results.xml
  artifacts:
    reports:
      junit: test-results.xml

deploy:
  stage: deploy
  only:
    - main
  script:
    - dpkg-deb --build package/
    - cp package.deb MonApplication-${CI_COMMIT_TAG}.deb
  artifacts:
    paths:
      - MonApplication-${CI_COMMIT_TAG}.deb
```

## Docker et conteneurisation

### Dockerfile pour application Ubuntu

```dockerfile
FROM ubuntu:22.04

# Éviter les prompts interactifs
ENV DEBIAN_FRONTEND=noninteractive

# Installer les dépendances
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    libpython3.10 \
    && rm -rf /var/lib/apt/lists/*

# Installer les bibliothèques Python
RUN pip3 install --no-cache-dir \
    numpy \
    pandas \
    tensorflow \
    scikit-learn

# Créer un utilisateur non-root
RUN useradd -m -s /bin/bash appuser

# Copier l'application
COPY --chown=appuser:appuser bin/MonApplication /opt/MonApplication/
COPY --chown=appuser:appuser share/ /opt/MonApplication/share/
COPY --chown=appuser:appuser config/ /opt/MonApplication/config/

# Définir les permissions
RUN chmod +x /opt/MonApplication/MonApplication

# Basculer vers l'utilisateur non-root
USER appuser

# Définir le répertoire de travail
WORKDIR /opt/MonApplication

# Point d'entrée
ENTRYPOINT ["./MonApplication"]
CMD ["--headless"]
```

**Construire et exécuter :**

```bash
# Construire l'image
docker build -t monapp:latest .

# Exécuter
docker run -it --rm monapp:latest

# Avec volume pour les données
docker run -it --rm \
  -v $(pwd)/data:/data \
  monapp:latest --analyze /data/input.csv

# Avec GPU (NVIDIA)
docker run -it --rm --gpus all \
  monapp:latest
```

### Docker Compose pour stack complète

```yaml
version: '3.8'

services:
  app:
    build: .
    image: monapp:latest
    container_name: monapp
    restart: unless-stopped
    environment:
      - PYTHONPATH=/opt/MonApplication/scripts
      - TF_CPP_MIN_LOG_LEVEL=2
    volumes:
      - ./data:/data
      - ./logs:/var/log/monapp
    ports:
      - "5000:5000"
    networks:
      - app-network

  postgres:
    image: postgres:15
    container_name: monapp-db
    restart: unless-stopped
    environment:
      - POSTGRES_DB=monapp
      - POSTGRES_USER=monapp
      - POSTGRES_PASSWORD=secret
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    container_name: monapp-cache
    restart: unless-stopped
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  postgres-data:
```

## Comparaison Windows vs Ubuntu

### Tableau récapitulatif

| Aspect | Windows | Ubuntu |
|--------|---------|--------|
| **Installation Python** | Télécharger depuis python.org | Pré-installé (`python3`) |
| **Gestionnaire de paquets** | pip, chocolatey | apt, pip, snap |
| **Bibliothèques dynamiques** | `.dll` | `.so` |
| **Séparateur de chemin** | `\` | `/` |
| **Chemin Python typique** | `C:\Python310` | `/usr/bin/python3` |
| **Librairie Python** | `python310.dll` | `libpython3.10.so` |
| **Performance ML/IA** | Bonne | Excellente (natif) |
| **Support GPU** | Bon (CUDA) | Excellent (CUDA natif) |
| **Déploiement serveur** | IIS, services Windows | systemd, native |
| **Conteneurisation** | WSL2 requis | Natif |
| **Outils système** | Registry, WMI | D-Bus, systemd |
| **Permissions** | UAC | chmod, sudo |
| **Environnements virtuels** | venv, conda | venv, conda (natif) |

### Code multi-plateforme unifié

```pascal
unit CrossPlatformAI;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, PythonEngine
  {$IFDEF UNIX}, BaseUnix{$ENDIF}
  {$IFDEF WINDOWS}, Windows{$ENDIF};

type
  TPlatformHelper = class
  public
    class function GetPythonPath: string;
    class function GetPythonLibrary: string;
    class function GetConfigPath: string;
    class function GetTempPath: string;
    class function PathSeparator: Char;
    class function ExecuteCommand(const Cmd: string): string;
  end;

implementation

class function TPlatformHelper.GetPythonPath: string;
begin
  {$IFDEF WINDOWS}
  Result := 'C:\Python310';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := '/usr/bin';
  {$ENDIF}
end;

class function TPlatformHelper.GetPythonLibrary: string;
begin
  {$IFDEF WINDOWS}
  Result := 'python310.dll';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := 'libpython3.10.so';
  {$ENDIF}
end;

class function TPlatformHelper.GetConfigPath: string;
begin
  {$IFDEF WINDOWS}
  Result := GetEnvironmentVariable('APPDATA') + '\MonApplication';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetEnvironmentVariable('HOME') + '/.config/MonApplication';
  {$ENDIF}

  if not DirectoryExists(Result) then
    CreateDir(Result);
end;

class function TPlatformHelper.GetTempPath: string;
begin
  {$IFDEF WINDOWS}
  Result := GetEnvironmentVariable('TEMP') + '\';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := '/tmp/';
  {$ENDIF}
end;

class function TPlatformHelper.PathSeparator: Char;
begin
  {$IFDEF WINDOWS}
  Result := '\';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := '/';
  {$ENDIF}
end;

class function TPlatformHelper.ExecuteCommand(const Cmd: string): string;
var
  Process: TProcess;
  Output: TStringList;
begin
  Process := TProcess.Create(nil);
  Output := TStringList.Create;
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'cmd.exe';
    Process.Parameters.Add('/c');
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/bin/bash';
    Process.Parameters.Add('-c');
    {$ENDIF}

    Process.Parameters.Add(Cmd);
    Process.Options := [poWaitOnExit, poUsePipes];
    Process.Execute;

    Output.LoadFromStream(Process.Output);
    Result := Output.Text;

  finally
    Output.Free;
    Process.Free;
  end;
end;

end.
```

## Récapitulatif et conclusion

### Points clés Ubuntu

✅ **Installation simple** : Python pré-installé, apt pour les dépendances
✅ **Performance native** : Bibliothèques optimisées pour Linux
✅ **GPU** : Support CUDA/cuDNN excellent
✅ **Déploiement** : systemd, docker natif, .deb, AppImage
✅ **Outils système** : D-Bus, cron, journalctl intégrés
✅ **Serveurs** : Idéal pour déploiement production
✅ **Open Source** : Écosystème cohérent et gratuit

### Workflow complet Ubuntu

```
1. Développement
   ├─ Lazarus IDE
   ├─ Python3 + venv
   ├─ Git pour versioning
   └─ Tests unitaires FPCUnit

2. Build
   ├─ lazbuild (ligne de commande)
   ├─ CI/CD (GitHub Actions/GitLab)
   └─ Tests automatisés

3. Packaging
   ├─ .deb pour distributions Debian/Ubuntu
   ├─ AppImage pour portabilité
   └─ Docker pour conteneurisation

4. Déploiement
   ├─ systemd service
   ├─ Nginx reverse proxy
   ├─ Monitoring (Prometheus)
   └─ Logs (journalctl)
```

### Ressources Ubuntu spécifiques

**Documentation :**
- Ubuntu Developers : [ubuntu.com/desktop/developers](https://ubuntu.com/desktop/developers)
- Python Packaging : [packaging.python.org](https://packaging.python.org)
- Lazarus Wiki : [wiki.lazarus.freepascal.org](https://wiki.lazarus.freepascal.org)

**Outils :**
```bash
# Outils de développement essentiels
sudo apt install build-essential gdb valgrind

# Outils Python
sudo apt install python3-dev python3-venv ipython3

# Outils système
sudo apt install htop iotop nethogs
```

**Communauté :**
- Ask Ubuntu : [askubuntu.com](https://askubuntu.com)
- Forum Lazarus : Section Linux/Unix
- Stack Overflow : Tags "freepascal" + "ubuntu"

### Prochaines étapes

Vous maîtrisez maintenant Python4Lazarus sur Ubuntu ! Vous êtes capable de :

1. ✅ Installer et configurer Python et Lazarus sur Ubuntu
2. ✅ Créer des applications IA performantes
3. ✅ Utiliser le GPU pour le deep learning
4. ✅ Déployer sur serveurs Linux
5. ✅ Créer des packages .deb et AppImage
6. ✅ Intégrer avec systemd et outils système
7. ✅ Mettre en place CI/CD
8. ✅ Conteneuriser avec Docker

**Félicitations !** Vous avez terminé l'étude complète de Python4Lazarus sur Windows et Ubuntu. Vous pouvez maintenant développer des applications d'Intelligence Artificielle multi-plateformes professionnelles avec FreePascal ! 🐧🐍🎉

⏭️ [ONNX et modèles portables](/15-intelligence-artificielle-machine-learning/08-onnx-modeles-portables.md)
