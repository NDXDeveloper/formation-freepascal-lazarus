🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.1 Python4Lazarus sur Windows

## Introduction

Cette section vous guide pas à pas dans l'installation et la configuration de Python4Lazarus sur Windows. Nous allons voir comment intégrer l'interpréteur Python directement dans vos applications Lazarus sous Windows, avec toutes les spécificités et bonnes pratiques de cette plateforme.

## Prérequis

Avant de commencer, assurez-vous d'avoir :

### 1. Lazarus et FreePascal installés

Vérifiez votre installation :
- Ouvrez Lazarus
- Allez dans **Aide → À propos de Lazarus**
- Vérifiez que vous avez au minimum :
  - Lazarus 2.0 ou supérieur
  - FreePascal 3.2.0 ou supérieur

### 2. Python installé sur Windows

**Option A : Installation depuis python.org (recommandée)**

1. Téléchargez Python depuis [https://www.python.org/downloads/](https://www.python.org/downloads/)
2. Choisissez Python 3.9, 3.10 ou 3.11 (versions stables et bien supportées)
3. **IMPORTANT** : Lors de l'installation, cochez **"Add Python to PATH"**

```
┌─────────────────────────────────────────┐
│  Python 3.10.x Setup                    │
├─────────────────────────────────────────┤
│  ☑ Install launcher for all users      │
│  ☑ Add Python 3.10 to PATH   ← CRUCIAL │
└─────────────────────────────────────────┘
```

4. Notez le chemin d'installation (généralement `C:\Python310` ou `C:\Users\VotreNom\AppData\Local\Programs\Python\Python310`)

**Option B : Via le Microsoft Store**

1. Ouvrez le Microsoft Store
2. Recherchez "Python 3.10"
3. Cliquez sur "Obtenir" puis "Installer"
4. Python sera installé dans `C:\Users\VotreNom\AppData\Local\Microsoft\WindowsApps\`

**Vérification de l'installation Python**

Ouvrez l'invite de commande (Win+R, tapez `cmd`) :

```cmd
python --version
```

Vous devriez voir :
```
Python 3.10.11
```

Si vous voyez un message d'erreur, Python n'est pas dans le PATH. Vous devrez ajouter le chemin manuellement.

### 3. Connaître les chemins Python importants

Exécutez dans l'invite de commande :

```cmd
python -c "import sys; print(sys.executable)"
```

Cela affiche le chemin de l'exécutable Python, par exemple :
```
C:\Python310\python.exe
```

Le dossier contenant `python310.dll` est généralement le même :
```
C:\Python310\python310.dll
```

**Notez ces chemins, vous en aurez besoin !**

## Installation de Python4Lazarus

### Méthode 1 : Installation via OPM (Online Package Manager) - Recommandée

C'est la méthode la plus simple.

**Étape 1 : Ouvrir OPM**

1. Ouvrez Lazarus
2. Allez dans **Paquets → Gestionnaire de paquets en ligne (OPM)**
3. Attendez que la liste des paquets se charge

**Étape 2 : Rechercher Python4Lazarus**

1. Dans la barre de recherche, tapez : `python`
2. Cherchez **"Python4Lazarus"** ou **"python4delphi"** dans la liste
3. Sélectionnez le paquet

**Étape 3 : Installer**

1. Cliquez sur **"Installer"**
2. OPM télécharge et installe le paquet
3. À la fin, cliquez sur **"Recompiler l'IDE"**
4. Lazarus va redémarrer

**Étape 4 : Vérification**

Après le redémarrage :
1. Allez dans l'onglet **Composants** de la palette
2. Vous devriez voir un nouvel onglet **"Python"** avec les composants :
   - `TPythonEngine`
   - `TPythonModule`
   - `TPythonInputOutput`
   - `TPythonGUIInputOutput`

### Méthode 2 : Installation manuelle depuis GitHub

Si OPM ne fonctionne pas ou si vous voulez la dernière version.

**Étape 1 : Télécharger Python4Lazarus**

1. Allez sur [https://github.com/pyscripter/python4delphi](https://github.com/pyscripter/python4delphi)
2. Cliquez sur **Code → Download ZIP**
3. Extrayez le ZIP dans un dossier, par exemple : `C:\Dev\Python4Delphi`

**Étape 2 : Ouvrir le paquet dans Lazarus**

1. Dans Lazarus, allez dans **Paquet → Ouvrir un fichier paquet (.lpk)**
2. Naviguez vers le dossier extrait
3. Ouvrez le fichier : `Python4Delphi\Packages\Lazarus\python4lazarus_package.lpk`

**Étape 3 : Compiler et installer**

1. Dans la fenêtre du paquet, cliquez sur **"Compiler"**
2. Une fois compilé avec succès, cliquez sur **"Utiliser → Installer"**
3. Lazarus demandera de recompiler l'IDE, acceptez
4. Lazarus redémarre avec Python4Lazarus installé

**Étape 4 : Vérification**

Vérifiez la présence des composants Python dans la palette de composants.

## Configuration de base

### Créer un premier projet de test

**Étape 1 : Nouveau projet**

1. **Projet → Nouveau projet**
2. Choisissez **Application**
3. Enregistrez le projet : `TestPython.lpi`

**Étape 2 : Ajouter un TPythonEngine**

1. Dans la palette de composants, onglet **Python**
2. Cliquez sur `TPythonEngine`
3. Cliquez sur le formulaire pour le placer (il sera invisible, c'est normal)
4. Le composant apparaît en bas du formulaire dans la zone des composants non-visuels

**Étape 3 : Configurer TPythonEngine**

Sélectionnez `PythonEngine1` dans l'Object Inspector et configurez :

```
Propriété : DllPath
Valeur   : C:\Python310
(Remplacez par votre chemin Python)

Propriété : DllName
Valeur   : python310.dll
(Adaptez selon votre version : python39.dll, python311.dll, etc.)
```

**Alternatives pour trouver automatiquement Python** :

Vous pouvez laisser `DllPath` vide et Python4Lazarus cherchera Python dans le PATH Windows.

**Étape 4 : Ajouter un TPythonGUIInputOutput**

1. Cliquez sur `TPythonGUIInputOutput` dans la palette
2. Placez-le sur le formulaire
3. Dans l'Object Inspector, configurez :

```
Propriété : Engine
Valeur   : PythonEngine1
```

Cela connecte l'objet InputOutput à votre moteur Python.

**Étape 5 : Ajouter des composants visuels**

Ajoutez sur votre formulaire :
- 1 `TMemo` : nommez-le `MemoCode` (pour écrire du code Python)
- 1 `TButton` : nommez-le `ButtonExecute`, Caption = "Exécuter"
- 1 `TMemo` : nommez-le `MemoOutput` (pour voir les résultats)

**Disposition suggérée** :

```
┌────────────────────────────────────────┐
│  MemoCode (Code Python)                │
│  ┌──────────────────────────────────┐  │
│  │ print("Hello from Python!")      │  │
│  │ x = 10 + 20                      │  │
│  │ print(f"Résultat : {x}")         │  │
│  └──────────────────────────────────┘  │
│                                        │
│  [Exécuter]  ← ButtonExecute           │
│                                        │
│  MemoOutput (Résultat)                 │
│  ┌──────────────────────────────────┐  │
│  │ Hello from Python!               │  │
│  │ Résultat : 30                    │  │
│  └──────────────────────────────────┘  │
└────────────────────────────────────────┘
```

### Écrire le code Pascal

**Étape 1 : Initialisation de Python**

Double-cliquez sur le formulaire pour créer l'événement `OnCreate` :

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  // Initialiser Python
  try
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      MemoOutput.Lines.Add('Python initialisé avec succès !');
      MemoOutput.Lines.Add('Version : ' + PythonEngine1.PyVersion);
    end
    else
      MemoOutput.Lines.Add('ERREUR : Python non initialisé');

  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''initialisation :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;
```

**Étape 2 : Configurer la sortie Python**

Double-cliquez sur `PythonGUIInputOutput1` et créez l'événement `OnSendData` :

```pascal
procedure TForm1.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);
begin
  // Afficher les print() Python dans MemoOutput
  MemoOutput.Lines.Add(Data);
end;
```

**Étape 3 : Exécution du code Python**

Double-cliquez sur `ButtonExecute` et ajoutez :

```pascal
procedure TForm1.ButtonExecuteClick(Sender: TObject);
var
  Code: string;
begin
  if not PythonEngine1.Initialized then
  begin
    ShowMessage('Python n''est pas initialisé !');
    Exit;
  end;

  // Effacer l'ancien résultat
  MemoOutput.Clear;

  // Récupérer le code Python
  Code := MemoCode.Text;

  try
    // Exécuter le code Python
    PythonEngine1.ExecStrings(MemoCode.Lines);
  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''exécution :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;
```

**Étape 4 : Libération des ressources**

Double-cliquez sur le formulaire et créez `OnDestroy` :

```pascal
procedure TForm1.FormDestroy(Sender: TObject);
begin
  // Libérer Python proprement
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;
```

### Code complet du formulaire

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  PythonEngine, PythonGUIInputOutput;

type
  TForm1 = class(TForm)
    ButtonExecute: TButton;
    MemoCode: TMemo;
    MemoOutput: TMemo;
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonExecuteClick(Sender: TObject);
    procedure PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);
  private

  public

  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

procedure TForm1.FormCreate(Sender: TObject);
begin
  try
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      MemoOutput.Lines.Add('Python initialisé avec succès !');
      MemoOutput.Lines.Add('Version : ' + PythonEngine1.PyVersion);
    end
    else
      MemoOutput.Lines.Add('ERREUR : Python non initialisé');

  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''initialisation :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TForm1.ButtonExecuteClick(Sender: TObject);
begin
  if not PythonEngine1.Initialized then
  begin
    ShowMessage('Python n''est pas initialisé !');
    Exit;
  end;

  MemoOutput.Clear;

  try
    PythonEngine1.ExecStrings(MemoCode.Lines);
  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''exécution :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;

procedure TForm1.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);
begin
  MemoOutput.Lines.Add(Data);
end;

end.
```

### Tester l'application

**Test 1 : Hello World**

Dans `MemoCode`, écrivez :
```python
print("Hello from Python!")
print("Ceci fonctionne dans Lazarus !")
```

Cliquez sur **Exécuter**. Vous devriez voir dans `MemoOutput` :
```
Hello from Python!
Ceci fonctionne dans Lazarus !
```

**Test 2 : Calculs**

```python
import math

x = 10
y = 20
print(f"Addition : {x} + {y} = {x + y}")
print(f"Racine carrée de 16 : {math.sqrt(16)}")
```

**Test 3 : Bibliothèques externes**

```python
import sys
print(f"Version Python : {sys.version}")
print(f"Chemin d'exécution : {sys.executable}")
```

## Gestion des chemins Python sous Windows

### Problème courant : DLL introuvable

**Erreur typique :**
```
Could not load library python310.dll
```

**Solutions :**

**Solution 1 : Spécifier le chemin complet**

```pascal
PythonEngine1.DllPath := 'C:\Python310';
PythonEngine1.DllName := 'python310.dll';
```

**Solution 2 : Utiliser UseLastKnownVersion**

```pascal
PythonEngine1.UseLastKnownVersion := True;
PythonEngine1.LoadDll;
```

Cela recherche automatiquement la dernière version de Python installée.

**Solution 3 : Ajouter au PATH système**

1. Ouvrez **Panneau de configuration → Système → Paramètres système avancés**
2. Cliquez sur **Variables d'environnement**
3. Dans **Variables système**, sélectionnez **Path**, cliquez **Modifier**
4. Ajoutez : `C:\Python310` (votre chemin Python)
5. Redémarrez Lazarus

**Solution 4 : Détection automatique par code**

```pascal
function FindPythonDLL: string;
var
  PythonDir: string;
begin
  // Essayer différents emplacements
  if FileExists('C:\Python310\python310.dll') then
    Result := 'C:\Python310\python310.dll'
  else if FileExists('C:\Python39\python39.dll') then
    Result := 'C:\Python39\python39.dll'
  else if FileExists('C:\Python311\python311.dll') then
    Result := 'C:\Python311\python311.dll'
  else
    Result := ''; // Non trouvé
end;

procedure TForm1.FormCreate(Sender: TObject);
var
  PythonDLL: string;
begin
  PythonDLL := FindPythonDLL;

  if PythonDLL <> '' then
  begin
    PythonEngine1.DllPath := ExtractFilePath(PythonDLL);
    PythonEngine1.DllName := ExtractFileName(PythonDLL);
    PythonEngine1.LoadDll;
  end
  else
    ShowMessage('Python introuvable !');
end;
```

### Détection dynamique depuis le registre Windows

Python s'enregistre dans le registre. Vous pouvez le détecter :

```pascal
uses
  Registry;

function GetPythonPathFromRegistry: string;
var
  Reg: TRegistry;
begin
  Result := '';
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;

    // Python 3.10
    if Reg.OpenKeyReadOnly('SOFTWARE\Python\PythonCore\3.10\InstallPath') then
    begin
      Result := Reg.ReadString('');
      Reg.CloseKey;
    end;

    // Si 3.10 non trouvé, essayer 3.9
    if (Result = '') and Reg.OpenKeyReadOnly('SOFTWARE\Python\PythonCore\3.9\InstallPath') then
    begin
      Result := Reg.ReadString('');
      Reg.CloseKey;
    end;

  finally
    Reg.Free;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);
var
  PythonPath: string;
begin
  PythonPath := GetPythonPathFromRegistry;

  if PythonPath <> '' then
  begin
    PythonEngine1.DllPath := PythonPath;
    PythonEngine1.LoadDll;
  end;
end;
```

## Utilisation de bibliothèques Python tierces

### Installer des bibliothèques avec pip

Ouvrez l'invite de commande :

```cmd
pip install numpy
pip install pandas
pip install tensorflow
pip install scikit-learn
```

### Vérifier l'installation

```cmd
pip list
```

Vous verrez la liste des paquets installés.

### Utiliser les bibliothèques dans votre application

```pascal
procedure TForm1.ButtonTestNumpyClick(Sender: TObject);
begin
  try
    PythonEngine1.ExecString('import numpy as np');
    PythonEngine1.ExecString('arr = np.array([1, 2, 3, 4, 5])');
    PythonEngine1.ExecString('print(f"Tableau : {arr}")');
    PythonEngine1.ExecString('print(f"Moyenne : {np.mean(arr)}")');
  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

### Problème : ImportError avec des bibliothèques

**Erreur :**
```
ImportError: DLL load failed: Le module spécifié est introuvable
```

**Cause :** Bibliothèques Python qui dépendent de DLL C/C++ externes (comme NumPy, TensorFlow).

**Solutions :**

1. **Installer Microsoft Visual C++ Redistributable**
   - Téléchargez depuis [Microsoft](https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads)
   - Installez les versions x64 (2015-2022)

2. **Vérifier l'architecture (32-bit vs 64-bit)**
   - Votre application Lazarus doit correspondre à votre Python
   - Python 64-bit → Application 64-bit
   - Vérifiez avec : `python -c "import sys; print(sys.maxsize > 2**32)"`
   - True = 64-bit, False = 32-bit

3. **Utiliser une distribution Python avec tout inclus**
   - **Anaconda** : Contient NumPy, SciPy, etc. pré-compilés
   - Téléchargez depuis [anaconda.com](https://www.anaconda.com/products/distribution)

## Gestion des versions Python multiples

### Utiliser plusieurs versions de Python

Si vous avez Python 3.9, 3.10 et 3.11 installés :

```pascal
type
  TForm1 = class(TForm)
  private
    procedure LoadPythonVersion(Version: Integer);
  end;

procedure TForm1.LoadPythonVersion(Version: Integer);
begin
  case Version of
    39:
    begin
      PythonEngine1.DllPath := 'C:\Python39';
      PythonEngine1.DllName := 'python39.dll';
    end;
    310:
    begin
      PythonEngine1.DllPath := 'C:\Python310';
      PythonEngine1.DllName := 'python310.dll';
    end;
    311:
    begin
      PythonEngine1.DllPath := 'C:\Python311';
      PythonEngine1.DllName := 'python311.dll';
    end;
  end;

  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
    ShowMessage('Python ' + PythonEngine1.PyVersion + ' chargé')
  else
    ShowMessage('Échec du chargement');
end;
```

### Utiliser des environnements virtuels Python

**Créer un environnement virtuel :**

```cmd
cd C:\MonProjet
python -m venv venv
```

**Activer l'environnement :**

```cmd
venv\Scripts\activate
```

**Installer des bibliothèques dans cet environnement :**

```cmd
pip install tensorflow numpy
```

**Utiliser cet environnement dans Lazarus :**

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  // Pointer vers le Python de l'environnement virtuel
  PythonEngine1.DllPath := 'C:\MonProjet\venv\Scripts';
  PythonEngine1.DllName := 'python310.dll';
  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
  begin
    // Configurer le path Python pour trouver les modules du venv
    PythonEngine1.ExecString('import sys');
    PythonEngine1.ExecString('sys.path.insert(0, r"C:\MonProjet\venv\Lib\site-packages")');
  end;
end;
```

## Configuration avancée

### Passer des variables de Pascal à Python

**Méthode 1 : Injection directe dans le code**

```pascal
var
  UserName: string;
  Age: Integer;
begin
  UserName := 'Alice';
  Age := 25;

  PythonEngine1.ExecString(Format('name = "%s"', [UserName]));
  PythonEngine1.ExecString(Format('age = %d', [Age]));
  PythonEngine1.ExecString('print(f"Bonjour {name}, vous avez {age} ans")');
end;
```

**Méthode 2 : Via SetVarFromVariant**

```pascal
procedure TForm1.ButtonPassDataClick(Sender: TObject);
begin
  PythonEngine1.SetVar('pascal_text', VarPythonCreate('Texte depuis Pascal'));
  PythonEngine1.SetVar('pascal_number', VarPythonCreate(42));

  PythonEngine1.ExecString('print(f"Texte : {pascal_text}")');
  PythonEngine1.ExecString('print(f"Nombre : {pascal_number}")');
end;
```

### Récupérer des résultats de Python

**Méthode 1 : Via EvalString**

```pascal
var
  Result: string;
begin
  PythonEngine1.ExecString('result = 10 + 20');
  Result := PythonEngine1.EvalString('result');
  ShowMessage('Résultat : ' + Result); // "30"
end;
```

**Méthode 2 : Via GetVarAsVariant**

```pascal
var
  PyResult: Variant;
  IntResult: Integer;
begin
  PythonEngine1.ExecString('my_value = 100');
  PyResult := PythonEngine1.GetVar('my_value');
  IntResult := PyResult;
  ShowMessage(IntToStr(IntResult)); // "100"
end;
```

### Appeler des fonctions Python définies

```pascal
procedure TForm1.ButtonCallFunctionClick(Sender: TObject);
var
  ResultStr: string;
begin
  // Définir une fonction Python
  PythonEngine1.ExecString(
    'def multiply(a, b):' + sLineBreak +
    '    return a * b'
  );

  // Appeler la fonction
  PythonEngine1.ExecString('result = multiply(7, 6)');
  ResultStr := PythonEngine1.EvalString('str(result)');

  ShowMessage('7 × 6 = ' + ResultStr); // "42"
end;
```

### Charger et exécuter des scripts externes

**Script Python externe : `analysis.py`**

```python
def analyze_data(numbers):
    """Analyse une liste de nombres"""
    return {
        'sum': sum(numbers),
        'average': sum(numbers) / len(numbers),
        'max': max(numbers),
        'min': min(numbers)
    }

def main():
    data = [10, 20, 30, 40, 50]
    result = analyze_data(data)
    print(f"Somme : {result['sum']}")
    print(f"Moyenne : {result['average']}")
```

**Depuis Pascal :**

```pascal
procedure TForm1.ButtonLoadScriptClick(Sender: TObject);
var
  ScriptPath: string;
begin
  ScriptPath := ExtractFilePath(Application.ExeName) + 'analysis.py';

  if FileExists(ScriptPath) then
  begin
    // Exécuter le script
    PythonEngine1.ExecFile(ScriptPath);

    // Appeler la fonction main du script
    PythonEngine1.ExecString('main()');
  end
  else
    ShowMessage('Script introuvable : ' + ScriptPath);
end;
```

## Débogage et résolution de problèmes

### Afficher les erreurs Python détaillées

```pascal
procedure TForm1.ExecutePythonWithDebug(const Code: string);
begin
  try
    PythonEngine1.ExecString(Code);
  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('=== ERREUR PYTHON ===');
      MemoOutput.Lines.Add(E.Message);

      // Afficher le traceback Python complet
      if PythonEngine1.PyErr_Occurred <> nil then
      begin
        PythonEngine1.PyErr_Print;
        MemoOutput.Lines.Add('Voir la console pour le traceback complet');
      end;
    end;
  end;
end;
```

### Capturer stderr Python

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  PythonEngine1.LoadDll;

  // Rediriger stderr vers notre interface
  PythonEngine1.ExecString('import sys');
  PythonEngine1.ExecString('sys.stderr = sys.stdout');

  // Maintenant les erreurs apparaîtront aussi dans PythonGUIInputOutput
end;
```

### Vérifier si un module est disponible

```pascal
function TForm1.IsPythonModuleAvailable(const ModuleName: string): Boolean;
begin
  Result := False;
  try
    PythonEngine1.ExecString('import ' + ModuleName);
    Result := True;
  except
    // Module non disponible
  end;
end;

// Utilisation
if IsPythonModuleAvailable('tensorflow') then
  ShowMessage('TensorFlow est disponible !')
else
  ShowMessage('TensorFlow n''est pas installé');
```

### Logger toutes les opérations Python

```pascal
type
  TForm1 = class(TForm)
  private
    FLogFile: TextFile;
    procedure LogPythonCommand(const Command: string);
  end;

procedure TForm1.LogPythonCommand(const Command: string);
begin
  WriteLn(FLogFile, FormatDateTime('hh:nn:ss', Now) + ' - ' + Command);
  Flush(FLogFile);
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  AssignFile(FLogFile, 'python_log.txt');
  Rewrite(FLogFile);
end;

procedure TForm1.ExecuteAndLog(const Code: string);
begin
  LogPythonCommand('EXEC: ' + Code);
  try
    PythonEngine1.ExecString(Code);
    LogPythonCommand('SUCCESS');
  except
    on E: Exception do
    begin
      LogPythonCommand('ERROR: ' + E.Message);
      raise;
    end;
  end;
end;
```

## Optimisation des performances

### Éviter les ExecString répétés

**❌ Lent (multiples appels) :**

```pascal
PythonEngine1.ExecString('import numpy as np');
PythonEngine1.ExecString('data = [1, 2, 3, 4, 5]');
PythonEngine1.ExecString('result = np.mean(data)');
PythonEngine1.ExecString('print(result)');
```

**✅ Rapide (un seul appel) :**

```pascal
PythonEngine1.ExecString(
  'import numpy as np' + sLineBreak +
  'data = [1, 2, 3, 4, 5]' + sLineBreak +
  'result = np.mean(data)' + sLineBreak +
  'print(result)'
);
```

### Réutiliser des objets Python

**❌ Lent (réimporter à chaque fois) :**

```pascal
procedure TForm1.ProcessImage1Click(Sender: TObject);
begin
  PythonEngine1.ExecString('import cv2');
  PythonEngine1.ExecString('img = cv2.imread("photo1.jpg")');
  // Traitement...
end;

procedure TForm1.ProcessImage2Click(Sender: TObject);
begin
  PythonEngine1.ExecString('import cv2'); // Réimportation inutile
  PythonEngine1.ExecString('img = cv2.imread("photo2.jpg")');
  // Traitement...
end;
```

**✅ Rapide (importer une seule fois) :**

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  PythonEngine1.LoadDll;

  // Importer les bibliothèques une seule fois au démarrage
  PythonEngine1.ExecString('import cv2');
  PythonEngine1.ExecString('import numpy as np');
  PythonEngine1.ExecString('import tensorflow as tf');
end;

procedure TForm1.ProcessImage1Click(Sender: TObject);
begin
  // Les modules sont déjà chargés
  PythonEngine1.ExecString('img = cv2.imread("photo1.jpg")');
  // Traitement...
end;
```

### Charger les modèles ML une seule fois

```pascal
type
  TForm1 = class(TForm)
  private
    FModelLoaded: Boolean;
    procedure LoadMLModel;
  end;

procedure TForm1.LoadMLModel;
begin
  if FModelLoaded then
    Exit; // Déjà chargé

  MemoOutput.Lines.Add('Chargement du modèle...');

  PythonEngine1.ExecString('import tensorflow as tf');
  PythonEngine1.ExecString('model = tf.keras.models.load_model("my_model.h5")');

  FModelLoaded := True;
  MemoOutput.Lines.Add('Modèle chargé !');
end;

procedure TForm1.ButtonPredictClick(Sender: TObject);
begin
  LoadMLModel; // Ne charge que si nécessaire

  // Faire une prédiction (rapide)
  PythonEngine1.ExecString('prediction = model.predict(data)');
end;
```

### Utiliser des threads pour les opérations longues

Pour éviter de bloquer l'interface pendant un traitement Python long :

```pascal
uses
  Classes;

type
  TPythonThread = class(TThread)
  private
    FPythonCode: string;
    FOnComplete: TNotifyEvent;
  protected
    procedure Execute; override;
  public
    constructor Create(const PythonCode: string; OnComplete: TNotifyEvent);
  end;

constructor TPythonThread.Create(const PythonCode: string; OnComplete: TNotifyEvent);
begin
  inherited Create(False);
  FreeOnTerminate := True;
  FPythonCode := PythonCode;
  FOnComplete := OnComplete;
end;

procedure TPythonThread.Execute;
begin
  // IMPORTANT : Acquérir le GIL (Global Interpreter Lock) de Python
  with GetPythonEngine.PyLock do
  try
    GetPythonEngine.ExecString(FPythonCode);
  finally
    // Le GIL est libéré automatiquement
  end;

  if Assigned(FOnComplete) then
    Synchronize(procedure
    begin
      FOnComplete(Self);
    end);
end;

// Utilisation
procedure TForm1.ButtonLongProcessClick(Sender: TObject);
begin
  TPythonThread.Create(
    'import time' + sLineBreak +
    'for i in range(10):' + sLineBreak +
    '    print(f"Étape {i}")' + sLineBreak +
    '    time.sleep(1)',
    @OnPythonProcessComplete
  );

  ShowMessage('Traitement lancé en arrière-plan !');
end;

procedure TForm1.OnPythonProcessComplete(Sender: TObject);
begin
  ShowMessage('Traitement Python terminé !');
end;
```

## Création d'interfaces complexes

### Exemple : Application de classification d'images

Créons une application complète qui utilise un modèle TensorFlow pour classifier des images.

**Interface visuelle :**

```
┌────────────────────────────────────────────────────┐
│  Classification d'images - TensorFlow              │
├────────────────────────────────────────────────────┤
│                                                    │
│  [Charger modèle]  Status: ⚪ Non chargé           │
│                                                    │
│  ┌──────────────────┐                              │
│  │                  │  [Sélectionner image]        │
│  │                  │                              │
│  │   Image ici      │  [Classifier]                │
│  │                  │                              │
│  │                  │  Résultat:                   │
│  └──────────────────┘  🐱 Chat (95.3%)             │
│                                                    │
│  Historique:                                       │
│  ┌──────────────────────────────────────────────┐  │
│  │ photo1.jpg - Chien (87.2%)                   │  │
│  │ photo2.jpg - Chat (95.3%)                    │  │
│  │ photo3.jpg - Oiseau (76.1%)                  │  │
│  └──────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────┘
```

**Code Pascal complet :**

```pascal
unit MainForm;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  ExtDlgs, PythonEngine, PythonGUIInputOutput;

type
  TFormMain = class(TForm)
    ButtonLoadModel: TButton;
    ButtonSelectImage: TButton;
    ButtonClassify: TButton;
    ImagePreview: TImage;
    LabelStatus: TLabel;
    LabelResult: TLabel;
    MemoHistory: TMemo;
    OpenPictureDialog: TOpenPictureDialog;
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonLoadModelClick(Sender: TObject);
    procedure ButtonSelectImageClick(Sender: TObject);
    procedure ButtonClassifyClick(Sender: TObject);
    procedure PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);

  private
    FModelLoaded: Boolean;
    FCurrentImagePath: string;
    procedure InitializePython;
    procedure LoadTensorFlowModel;
    procedure ClassifyImage(const ImagePath: string);
    procedure UpdateStatus(const Status: string; IsReady: Boolean);
  end;

var
  FormMain: TFormMain;

implementation

{$R *.lfm}

procedure TFormMain.FormCreate(Sender: TObject);
begin
  FModelLoaded := False;
  FCurrentImagePath := '';
  InitializePython;
end;

procedure TFormMain.FormDestroy(Sender: TObject);
begin
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TFormMain.InitializePython;
begin
  try
    // Configurer le chemin Python (adapter selon votre installation)
    PythonEngine1.DllPath := 'C:\Python310';
    PythonEngine1.DllName := 'python310.dll';

    // Charger Python
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      UpdateStatus('Python ' + PythonEngine1.PyVersion + ' initialisé', False);
      ButtonLoadModel.Enabled := True;
    end
    else
    begin
      UpdateStatus('Erreur : Python non initialisé', False);
      ShowMessage('Impossible d''initialiser Python. Vérifiez le chemin DLL.');
    end;

  except
    on E: Exception do
    begin
      UpdateStatus('Erreur : ' + E.Message, False);
      ShowMessage('Erreur lors de l''initialisation de Python : ' + E.Message);
    end;
  end;
end;

procedure TFormMain.ButtonLoadModelClick(Sender: TObject);
begin
  ButtonLoadModel.Enabled := False;
  UpdateStatus('Chargement du modèle...', False);
  Application.ProcessMessages;

  try
    LoadTensorFlowModel;
  finally
    ButtonLoadModel.Enabled := not FModelLoaded;
  end;
end;

procedure TFormMain.LoadTensorFlowModel;
begin
  try
    // Importer TensorFlow et autres bibliothèques
    PythonEngine1.ExecString('import tensorflow as tf');
    PythonEngine1.ExecString('import numpy as np');
    PythonEngine1.ExecString('from PIL import Image');

    // Charger un modèle pré-entraîné (exemple : MobileNetV2)
    PythonEngine1.ExecString(
      'model = tf.keras.applications.MobileNetV2(' +
      'weights="imagenet", ' +
      'include_top=True)'
    );

    // Charger les labels ImageNet
    PythonEngine1.ExecString(
      'decode_predictions = tf.keras.applications.mobilenet_v2.decode_predictions'
    );
    PythonEngine1.ExecString(
      'preprocess_input = tf.keras.applications.mobilenet_v2.preprocess_input'
    );

    FModelLoaded := True;
    UpdateStatus('Modèle chargé et prêt', True);
    ButtonSelectImage.Enabled := True;

    MemoHistory.Lines.Add('=== Modèle TensorFlow chargé ===');
    MemoHistory.Lines.Add('Type : MobileNetV2');
    MemoHistory.Lines.Add('Dataset : ImageNet (1000 classes)');
    MemoHistory.Lines.Add('');

  except
    on E: Exception do
    begin
      FModelLoaded := False;
      UpdateStatus('Erreur de chargement', False);
      ShowMessage('Erreur lors du chargement du modèle : ' + E.Message +
                  sLineBreak + sLineBreak +
                  'Assurez-vous que TensorFlow est installé :' + sLineBreak +
                  'pip install tensorflow pillow');
      ButtonLoadModel.Enabled := True;
    end;
  end;
end;

procedure TFormMain.ButtonSelectImageClick(Sender: TObject);
begin
  if OpenPictureDialog.Execute then
  begin
    FCurrentImagePath := OpenPictureDialog.FileName;

    // Afficher l'image
    try
      ImagePreview.Picture.LoadFromFile(FCurrentImagePath);
      ButtonClassify.Enabled := True;
      LabelResult.Caption := 'Résultat : (en attente)';
    except
      on E: Exception do
        ShowMessage('Erreur lors du chargement de l''image : ' + E.Message);
    end;
  end;
end;

procedure TFormMain.ButtonClassifyClick(Sender: TObject);
begin
  if not FModelLoaded then
  begin
    ShowMessage('Veuillez d''abord charger le modèle !');
    Exit;
  end;

  if FCurrentImagePath = '' then
  begin
    ShowMessage('Veuillez d''abord sélectionner une image !');
    Exit;
  end;

  ButtonClassify.Enabled := False;
  UpdateStatus('Classification en cours...', True);
  Application.ProcessMessages;

  try
    ClassifyImage(FCurrentImagePath);
  finally
    ButtonClassify.Enabled := True;
    UpdateStatus('Modèle prêt', True);
  end;
end;

procedure TFormMain.ClassifyImage(const ImagePath: string);
var
  PredictionScript: string;
  ResultJSON: string;
  ClassName: string;
  Confidence: string;
begin
  try
    // Préparer le script Python de classification
    PredictionScript :=
      'img = Image.open(r"' + ImagePath + '")' + sLineBreak +
      'img = img.resize((224, 224))' + sLineBreak +
      'img_array = np.array(img)' + sLineBreak +
      'img_array = np.expand_dims(img_array, axis=0)' + sLineBreak +
      'img_array = preprocess_input(img_array)' + sLineBreak +
      'predictions = model.predict(img_array, verbose=0)' + sLineBreak +
      'decoded = decode_predictions(predictions, top=3)[0]' + sLineBreak +
      'result_class = decoded[0][1]' + sLineBreak +
      'result_confidence = float(decoded[0][2])';

    // Exécuter la classification
    PythonEngine1.ExecString(PredictionScript);

    // Récupérer les résultats
    ClassName := PythonEngine1.EvalString('result_class');
    Confidence := PythonEngine1.EvalString('str(round(result_confidence * 100, 1))');

    // Afficher le résultat
    LabelResult.Caption := Format('Résultat : %s (%s%%)', [ClassName, Confidence]);
    LabelResult.Font.Color := clGreen;
    LabelResult.Font.Style := [fsBold];

    // Ajouter à l'historique
    MemoHistory.Lines.Add(
      Format('%s - %s (%s%%)',
      [ExtractFileName(ImagePath), ClassName, Confidence])
    );

    // Obtenir le top 3 des prédictions
    PythonEngine1.ExecString(
      'top3 = "\n".join([f"{i+1}. {pred[1]} ({pred[2]*100:.1f}%)" for i, pred in enumerate(decoded)])'
    );

    ShowMessage('Top 3 prédictions :' + sLineBreak + sLineBreak +
                PythonEngine1.EvalString('top3'));

  except
    on E: Exception do
    begin
      LabelResult.Caption := 'Résultat : Erreur';
      LabelResult.Font.Color := clRed;
      ShowMessage('Erreur lors de la classification : ' + E.Message);
    end;
  end;
end;

procedure TFormMain.UpdateStatus(const Status: string; IsReady: Boolean);
begin
  LabelStatus.Caption := 'Status : ' + Status;

  if IsReady then
  begin
    LabelStatus.Font.Color := clGreen;
    LabelStatus.Caption := LabelStatus.Caption + ' 🟢';
  end
  else
  begin
    LabelStatus.Font.Color := clMaroon;
    LabelStatus.Caption := LabelStatus.Caption + ' 🔴';
  end;
end;

procedure TFormMain.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);
begin
  // Afficher les messages Python dans l'historique
  if Trim(Data) <> '' then
    MemoHistory.Lines.Add('[Python] ' + Data);
end;

end.
```

### Exemple : Analyseur de sentiment de texte

Application qui analyse le sentiment (positif/négatif) d'un texte.

```pascal
unit SentimentAnalyzer;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  PythonEngine, PythonGUIInputOutput;

type
  TFormSentiment = class(TForm)
    ButtonAnalyze: TButton;
    MemoInput: TMemo;
    MemoResult: TMemo;
    LabelScore: TLabel;
    ProgressBar1: TProgressBar;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure ButtonAnalyzeClick(Sender: TObject);

  private
    FModelReady: Boolean;
    procedure InitializeModel;
    function AnalyzeSentiment(const Text: string): Double;
  end;

implementation

{$R *.lfm}

procedure TFormSentiment.FormCreate(Sender: TObject);
begin
  FModelReady := False;

  // Initialiser Python
  PythonEngine1.DllPath := 'C:\Python310';
  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
    InitializeModel;
end;

procedure TFormSentiment.InitializeModel;
begin
  try
    // Utiliser TextBlob pour l'analyse de sentiment
    PythonEngine1.ExecString('from textblob import TextBlob');

    FModelReady := True;
    ButtonAnalyze.Enabled := True;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur : ' + E.Message + sLineBreak + sLineBreak +
                  'Installez TextBlob avec : pip install textblob');
      ButtonAnalyze.Enabled := False;
    end;
  end;
end;

procedure TFormSentiment.ButtonAnalyzeClick(Sender: TObject);
var
  InputText: string;
  Score: Double;
  ScorePercent: Integer;
  Sentiment: string;
begin
  InputText := MemoInput.Text;

  if Trim(InputText) = '' then
  begin
    ShowMessage('Veuillez entrer du texte à analyser');
    Exit;
  end;

  try
    Score := AnalyzeSentiment(InputText);

    // Convertir le score (-1 à 1) en pourcentage (0 à 100)
    ScorePercent := Round((Score + 1) * 50);
    ProgressBar1.Position := ScorePercent;

    // Déterminer le sentiment
    if Score > 0.3 then
      Sentiment := 'Très positif 😊'
    else if Score > 0.1 then
      Sentiment := 'Positif 🙂'
    else if Score > -0.1 then
      Sentiment := 'Neutre 😐'
    else if Score > -0.3 then
      Sentiment := 'Négatif 😞'
    else
      Sentiment := 'Très négatif 😢';

    LabelScore.Caption := Format('Sentiment : %s (Score : %.2f)', [Sentiment, Score]);

    // Détails de l'analyse
    MemoResult.Clear;
    MemoResult.Lines.Add('=== Résultats de l''analyse ===');
    MemoResult.Lines.Add('');
    MemoResult.Lines.Add('Score brut : ' + FloatToStr(Score));
    MemoResult.Lines.Add('Score normalisé : ' + IntToStr(ScorePercent) + '%');
    MemoResult.Lines.Add('Interprétation : ' + Sentiment);
    MemoResult.Lines.Add('');
    MemoResult.Lines.Add('Échelle :');
    MemoResult.Lines.Add('  -1.0 = Très négatif');
    MemoResult.Lines.Add('   0.0 = Neutre');
    MemoResult.Lines.Add('  +1.0 = Très positif');

  except
    on E: Exception do
      ShowMessage('Erreur lors de l''analyse : ' + E.Message);
  end;
end;

function TFormSentiment.AnalyzeSentiment(const Text: string): Double;
var
  EscapedText: string;
  ScoreStr: string;
begin
  // Échapper les guillemets dans le texte
  EscapedText := StringReplace(Text, '"', '\"', [rfReplaceAll]);
  EscapedText := StringReplace(EscapedText, sLineBreak, ' ', [rfReplaceAll]);

  // Analyser le sentiment
  PythonEngine1.ExecString(Format('blob = TextBlob("%s")', [EscapedText]));
  PythonEngine1.ExecString('polarity = blob.sentiment.polarity');

  ScoreStr := PythonEngine1.EvalString('str(polarity)');
  Result := StrToFloat(ScoreStr);
end;

end.
```

## Déploiement de l'application

### Option 1 : Déploiement avec Python portable

**Créer un package complet avec Python embarqué :**

1. **Télécharger Python Embedded**
   - Allez sur [python.org/downloads/windows](https://www.python.org/downloads/windows/)
   - Téléchargez "Windows embeddable package (64-bit)"
   - Exemple : `python-3.10.11-embed-amd64.zip`

2. **Structure du déploiement**

```
MonApplication\
├── MonApp.exe                    ← Votre application
├── python310.dll                 ← DLL Python
├── python\                       ← Python embarqué
│   ├── python.exe
│   ├── python310.zip
│   └── ...
├── Lib\                          ← Bibliothèques Python
│   └── site-packages\
│       ├── numpy\
│       ├── tensorflow\
│       └── ...
└── models\                       ← Vos modèles ML
    └── my_model.h5
```

3. **Configurer le chemin dans votre application**

```pascal
procedure TForm1.FormCreate(Sender: TObject);
var
  AppPath: string;
begin
  AppPath := ExtractFilePath(Application.ExeName);

  // Utiliser le Python embarqué
  PythonEngine1.DllPath := AppPath + 'python';
  PythonEngine1.DllName := 'python310.dll';

  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
  begin
    // Configurer le sys.path pour trouver les modules
    PythonEngine1.ExecString('import sys');
    PythonEngine1.ExecString(
      Format('sys.path.insert(0, r"%sLib\site-packages")', [AppPath])
    );
  end;
end;
```

4. **Copier les bibliothèques Python nécessaires**

```cmd
REM Installer les bibliothèques dans le Python embarqué
cd MonApplication\python
python.exe -m pip install --target=..\Lib\site-packages numpy tensorflow
```

### Option 2 : Installeur avec détection de Python

Créer un installeur (Inno Setup par exemple) qui :

1. Détecte si Python est installé
2. Si non, propose de l'installer
3. Installe les dépendances Python nécessaires

**Script Inno Setup basique :**

```inno
[Setup]
AppName=Mon Application IA
AppVersion=1.0
DefaultDirName={pf}\MonApplicationIA

[Files]
Source: "MonApp.exe"; DestDir: "{app}"
Source: "requirements.txt"; DestDir: "{app}"

[Run]
; Vérifier et installer Python si nécessaire
Filename: "python"; Parameters: "--version"; StatusMsg: "Vérification de Python..."; Flags: runhidden
Filename: "python"; Parameters: "-m pip install -r ""{app}\requirements.txt"""; StatusMsg: "Installation des dépendances Python..."; Flags: runhidden
```

**Fichier requirements.txt :**

```
tensorflow==2.13.0
numpy==1.24.3
pillow==10.0.0
```

### Option 3 : Application autonome avec PyInstaller

Vous pouvez même compiler vos scripts Python en exécutables :

```pascal
procedure TForm1.UseCompiledPythonScript;
var
  Process: TProcess;
begin
  // Appeler un exécutable Python compilé
  Process := TProcess.Create(nil);
  try
    Process.Executable := 'my_python_script.exe';
    Process.Parameters.Add('--input');
    Process.Parameters.Add('data.csv');
    Process.Options := [poWaitOnExit, poUsePipes];
    Process.Execute;

    // Lire la sortie
    MemoOutput.Lines.LoadFromStream(Process.Output);
  finally
    Process.Free;
  end;
end;
```

## Cas d'usage avancés

### Traitement d'images par lot

```pascal
procedure TForm1.BatchProcessImages;
var
  ImageFiles: TStringList;
  i: Integer;
  ImagePath, Result: string;
begin
  ImageFiles := TStringList.Create;
  try
    // Obtenir tous les fichiers JPG d'un dossier
    FindAllFiles(ImageFiles, 'C:\Photos', '*.jpg', False);

    ProgressBar.Max := ImageFiles.Count;
    ProgressBar.Position := 0;

    // Charger le modèle une fois
    PythonEngine1.ExecString('import tensorflow as tf');
    PythonEngine1.ExecString('model = tf.keras.models.load_model("classifier.h5")');

    // Traiter chaque image
    for i := 0 to ImageFiles.Count - 1 do
    begin
      ImagePath := ImageFiles[i];

      // Préparer et classifier
      PythonEngine1.ExecString(
        Format('img = load_and_preprocess("%s")', [ImagePath])
      );
      PythonEngine1.ExecString('prediction = model.predict(img)');
      PythonEngine1.ExecString('class_name = get_class_name(prediction)');

      Result := PythonEngine1.EvalString('class_name');

      // Sauvegarder le résultat
      MemoResults.Lines.Add(Format('%s: %s', [ExtractFileName(ImagePath), Result]));

      // Mise à jour de la barre de progression
      ProgressBar.Position := i + 1;
      LabelStatus.Caption := Format('Traitement %d/%d', [i + 1, ImageFiles.Count]);
      Application.ProcessMessages;
    end;

    ShowMessage('Traitement terminé !');

  finally
    ImageFiles.Free;
  end;
end;
```

### Serveur web Python depuis Lazarus

```pascal
unit WebServer;

interface

uses
  Classes, SysUtils, Forms, PythonEngine, Process;

type
  TPythonWebServer = class
  private
    FPythonEngine: TPythonEngine;
    FServerRunning: Boolean;
    FPort: Integer;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure Start(Port: Integer);
    procedure Stop;
    property IsRunning: Boolean read FServerRunning;
  end;

implementation

constructor TPythonWebServer.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
  FServerRunning := False;
end;

procedure TPythonWebServer.Start(Port: Integer);
var
  ServerCode: string;
begin
  FPort := Port;

  ServerCode :=
    'from flask import Flask, request, jsonify' + sLineBreak +
    'import threading' + sLineBreak +
    sLineBreak +
    'app = Flask(__name__)' + sLineBreak +
    sLineBreak +
    '@app.route("/predict", methods=["POST"])' + sLineBreak +
    'def predict():' + sLineBreak +
    '    data = request.json' + sLineBreak +
    '    # Faire la prédiction' + sLineBreak +
    '    result = {"prediction": "example"}' + sLineBreak +
    '    return jsonify(result)' + sLineBreak +
    sLineBreak +
    'def run_server():' + sLineBreak +
    Format('    app.run(port=%d, debug=False)', [FPort]) + sLineBreak +
    sLineBreak +
    'server_thread = threading.Thread(target=run_server)' + sLineBreak +
    'server_thread.daemon = True' + sLineBreak +
    'server_thread.start()';

  FPythonEngine.ExecString(ServerCode);
  FServerRunning := True;
end;

procedure TPythonWebServer.Stop;
begin
  // Arrêter le serveur (plus complexe, nécessite d'autres mécanismes)
  FServerRunning := False;
end;

end.
```

## Ressources et documentation

### Documentation officielle

- **Python4Delphi GitHub** : [github.com/pyscripter/python4delphi](https://github.com/pyscripter/python4delphi)
- **Wiki Python4Delphi** : Exemples et tutoriels
- **Forum Lazarus** : Section Python Integration

### Bibliothèques Python utiles pour l'IA

**Vision par ordinateur :**
```cmd
pip install opencv-python
pip install pillow
pip install scikit-image
```

**Machine Learning :**
```cmd
pip install tensorflow
pip install torch torchvision
pip install scikit-learn
pip install xgboost
```

**NLP (Traitement du langage) :**
```cmd
pip install transformers
pip install spacy
pip install nltk
pip install textblob
```

**Data Science :**
```cmd
pip install numpy
pip install pandas
pip install matplotlib
pip install seaborn
```

### Exemples de projets

**1. Détecteur de fraude**
```pascal
// Application qui analyse des transactions
procedure AnalyzeTransaction(Amount: Double; Location: string);
begin
  PythonEngine.ExecString(
    Format('is_fraud = fraud_model.predict([[%.2f, "%s"]])[0]',
    [Amount, Location])
  );

  if PythonEngine.EvalString('str(is_fraud)') = 'True' then
    ShowMessage('Transaction suspecte détectée !');
end;
```

**2. Recommandation de produits**
```pascal
// Système de recommandation e-commerce
function GetRecommendations(UserID: Integer): TStringList;
var
  RecommendationsJSON: string;
  JSONData: TJSONData;
  JSONArray: TJSONArray;
  i: Integer;
begin
  Result := TStringList.Create;

  try
    // Obtenir les recommandations depuis le modèle Python
    PythonEngine.ExecString(
      Format('recommendations = recommender_model.recommend(user_id=%d, n_items=5)',
      [UserID])
    );
    PythonEngine.ExecString('import json');
    PythonEngine.ExecString('recommendations_json = json.dumps(recommendations)');

    RecommendationsJSON := PythonEngine.EvalString('recommendations_json');

    // Parser le JSON en Pascal
    JSONData := GetJSON(RecommendationsJSON);
    try
      if JSONData is TJSONArray then
      begin
        JSONArray := TJSONArray(JSONData);
        for i := 0 to JSONArray.Count - 1 do
          Result.Add(JSONArray.Items[i].AsString);
      end;
    finally
      JSONData.Free;
    end;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de la recommandation : ' + E.Message);
      Result.Clear;
    end;
  end;
end;

// Utilisation dans l'interface
procedure TForm1.ButtonGetRecommendationsClick(Sender: TObject);
var
  Recommendations: TStringList;
  i: Integer;
begin
  Recommendations := GetRecommendations(StrToInt(EditUserID.Text));
  try
    ListBoxRecommendations.Clear;
    for i := 0 to Recommendations.Count - 1 do
      ListBoxRecommendations.Items.Add(Recommendations[i]);

    LabelInfo.Caption := Format('%d recommandations trouvées', [Recommendations.Count]);
  finally
    Recommendations.Free;
  end;
end;
```

### 3. Transcription audio avec Whisper

Application de reconnaissance vocale utilisant OpenAI Whisper :

```pascal
unit AudioTranscription;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  ExtCtrls, PythonEngine, PythonGUIInputOutput;

type
  TFormTranscription = class(TForm)
    ButtonLoadModel: TButton;
    ButtonSelectAudio: TButton;
    ButtonTranscribe: TButton;
    MemoTranscription: TMemo;
    ProgressBar1: TProgressBar;
    LabelStatus: TLabel;
    OpenDialog1: TOpenDialog;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure ButtonLoadModelClick(Sender: TObject);
    procedure ButtonSelectAudioClick(Sender: TObject);
    procedure ButtonTranscribeClick(Sender: TObject);

  private
    FModelLoaded: Boolean;
    FAudioFilePath: string;
    procedure LoadWhisperModel;
    procedure TranscribeAudio(const FilePath: string);
  end;

var
  FormTranscription: TFormTranscription;

implementation

{$R *.lfm}

procedure TFormTranscription.FormCreate(Sender: TObject);
begin
  FModelLoaded := False;
  FAudioFilePath := '';

  // Initialiser Python
  PythonEngine1.DllPath := 'C:\Python310';
  PythonEngine1.LoadDll;

  if not PythonEngine1.Initialized then
    ShowMessage('Erreur d''initialisation Python');
end;

procedure TFormTranscription.ButtonLoadModelClick(Sender: TObject);
begin
  ButtonLoadModel.Enabled := False;
  LabelStatus.Caption := 'Chargement du modèle Whisper...';
  Application.ProcessMessages;

  LoadWhisperModel;
end;

procedure TFormTranscription.LoadWhisperModel;
begin
  try
    LabelStatus.Caption := 'Installation/Import de Whisper...';
    Application.ProcessMessages;

    // Importer Whisper (peut prendre du temps la première fois)
    PythonEngine1.ExecString('import whisper');

    LabelStatus.Caption := 'Chargement du modèle (cela peut prendre plusieurs minutes)...';
    Application.ProcessMessages;

    // Charger le modèle (base, small, medium, large)
    PythonEngine1.ExecString('model = whisper.load_model("base")');

    FModelLoaded := True;
    ButtonSelectAudio.Enabled := True;
    LabelStatus.Caption := 'Modèle Whisper chargé et prêt !';

    MemoTranscription.Lines.Add('=== Modèle Whisper chargé ===');
    MemoTranscription.Lines.Add('Taille : Base');
    MemoTranscription.Lines.Add('Langues supportées : 99');
    MemoTranscription.Lines.Add('');

  except
    on E: Exception do
    begin
      LabelStatus.Caption := 'Erreur de chargement';
      ShowMessage('Erreur : ' + E.Message + sLineBreak + sLineBreak +
                  'Installez Whisper avec : pip install openai-whisper');
      ButtonLoadModel.Enabled := True;
    end;
  end;
end;

procedure TFormTranscription.ButtonSelectAudioClick(Sender: TObject);
begin
  OpenDialog1.Filter := 'Fichiers audio|*.mp3;*.wav;*.m4a;*.flac|Tous les fichiers|*.*';

  if OpenDialog1.Execute then
  begin
    FAudioFilePath := OpenDialog1.FileName;
    ButtonTranscribe.Enabled := True;
    LabelStatus.Caption := 'Fichier sélectionné : ' + ExtractFileName(FAudioFilePath);
  end;
end;

procedure TFormTranscription.ButtonTranscribeClick(Sender: TObject);
begin
  if not FModelLoaded then
  begin
    ShowMessage('Veuillez d''abord charger le modèle !');
    Exit;
  end;

  if FAudioFilePath = '' then
  begin
    ShowMessage('Veuillez sélectionner un fichier audio !');
    Exit;
  end;

  ButtonTranscribe.Enabled := False;
  ProgressBar1.Style := pbstMarquee;
  LabelStatus.Caption := 'Transcription en cours...';
  Application.ProcessMessages;

  try
    TranscribeAudio(FAudioFilePath);
  finally
    ButtonTranscribe.Enabled := True;
    ProgressBar1.Style := pbstNormal;
  end;
end;

procedure TFormTranscription.TranscribeAudio(const FilePath: string);
var
  TranscriptionText: string;
  Language: string;
begin
  try
    // Transcrire l'audio
    PythonEngine1.ExecString(
      Format('result = model.transcribe(r"%s")', [FilePath])
    );

    // Récupérer le texte transcrit
    PythonEngine1.ExecString('transcription_text = result["text"]');
    TranscriptionText := PythonEngine1.EvalString('transcription_text');

    // Récupérer la langue détectée
    PythonEngine1.ExecString('detected_language = result["language"]');
    Language := PythonEngine1.EvalString('detected_language');

    // Afficher les résultats
    MemoTranscription.Clear;
    MemoTranscription.Lines.Add('=== Transcription ===');
    MemoTranscription.Lines.Add('Fichier : ' + ExtractFileName(FilePath));
    MemoTranscription.Lines.Add('Langue détectée : ' + Language);
    MemoTranscription.Lines.Add('');
    MemoTranscription.Lines.Add(TranscriptionText);

    LabelStatus.Caption := 'Transcription terminée !';

  except
    on E: Exception do
    begin
      LabelStatus.Caption := 'Erreur lors de la transcription';
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;

end.
```

### 4. Générateur de texte avec GPT

Interface pour générer du texte avec des modèles de langage :

```pascal
procedure TFormTextGenerator.GenerateText;
var
  Prompt: string;
  GeneratedText: string;
  MaxTokens: Integer;
begin
  Prompt := MemoPrompt.Text;
  MaxTokens := SpinEditMaxTokens.Value;

  if Trim(Prompt) = '' then
  begin
    ShowMessage('Entrez un prompt !');
    Exit;
  end;

  ButtonGenerate.Enabled := False;
  LabelStatus.Caption := 'Génération en cours...';
  Application.ProcessMessages;

  try
    // Utiliser la bibliothèque transformers de HuggingFace
    PythonEngine1.ExecString(
      Format('prompt = """%s"""', [Prompt])
    );
    PythonEngine1.ExecString(
      Format('max_tokens = %d', [MaxTokens])
    );

    PythonEngine1.ExecString('inputs = tokenizer(prompt, return_tensors="pt")');
    PythonEngine1.ExecString(
      'outputs = model.generate(**inputs, max_length=max_tokens, ' +
      'num_return_sequences=1, temperature=0.7)'
    );
    PythonEngine1.ExecString(
      'generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)'
    );

    GeneratedText := PythonEngine1.EvalString('generated_text');

    MemoOutput.Text := GeneratedText;
    LabelStatus.Caption := 'Génération terminée !';

  except
    on E: Exception do
    begin
      ShowMessage('Erreur : ' + E.Message);
      LabelStatus.Caption := 'Erreur';
    end;
  end;

  ButtonGenerate.Enabled := True;
end;
```

## Techniques avancées

### Callback Pascal depuis Python

Permettre à Python d'appeler des fonctions Pascal :

```pascal
unit PythonCallbacks;

interface

uses
  PythonEngine;

// Fonction Pascal qui sera appelable depuis Python
function PascalCallback(Self, Args: PPyObject): PPyObject; cdecl;

procedure RegisterCallbacks(PythonModule: TPythonModule);

implementation

function PascalCallback(Self, Args: PPyObject): PPyObject; cdecl;
var
  Message: PAnsiChar;
begin
  // Récupérer l'argument passé par Python
  with GetPythonEngine do
  begin
    if PyArg_ParseTuple(Args, 's:pascal_callback', @Message) <> 0 then
    begin
      // Faire quelque chose avec le message
      ShowMessage('Appelé depuis Python : ' + string(Message));

      // Retourner une valeur à Python
      Result := PyString_FromString('Réponse depuis Pascal');
    end
    else
      Result := nil;
  end;
end;

procedure RegisterCallbacks(PythonModule: TPythonModule);
begin
  with PythonModule do
  begin
    // Enregistrer la fonction Pascal pour qu'elle soit appelable depuis Python
    AddMethod('pascal_callback', @PascalCallback,
              'pascal_callback(message) -> str');
  end;
end;

end.

// Utilisation dans le formulaire principal
procedure TForm1.FormCreate(Sender: TObject);
begin
  PythonEngine1.LoadDll;

  // Créer un module Python contenant nos fonctions Pascal
  PythonModule1 := TPythonModule.Create(Self);
  PythonModule1.Engine := PythonEngine1;
  PythonModule1.ModuleName := 'pascal_functions';
  PythonModule1.OnInitialization := @RegisterCallbacks;

  // Maintenant Python peut faire :
  // import pascal_functions
  // response = pascal_functions.pascal_callback("Hello from Python")
end;
```

### Passage de données complexes (DataFrames Pandas)

Échanger des tableaux de données entre Pascal et Python :

```pascal
uses
  fpjson, jsonparser;

procedure TForm1.SendDataFrameToPython;
var
  JSONData: TJSONObject;
  JSONArray: TJSONArray;
  JSONRow: TJSONObject;
  i: Integer;
begin
  // Créer des données en JSON
  JSONArray := TJSONArray.Create;
  try
    for i := 1 to 10 do
    begin
      JSONRow := TJSONObject.Create;
      JSONRow.Add('id', i);
      JSONRow.Add('name', 'User ' + IntToStr(i));
      JSONRow.Add('score', Random(100));
      JSONArray.Add(JSONRow);
    end;

    // Envoyer à Python et créer un DataFrame
    PythonEngine1.ExecString('import pandas as pd');
    PythonEngine1.ExecString('import json');
    PythonEngine1.ExecString(
      Format('data = json.loads(''%s'')', [JSONArray.AsJSON])
    );
    PythonEngine1.ExecString('df = pd.DataFrame(data)');
    PythonEngine1.ExecString('print(df.head())');

    // Faire des opérations sur le DataFrame
    PythonEngine1.ExecString('average_score = df["score"].mean()');

    ShowMessage('Score moyen : ' + PythonEngine1.EvalString('str(average_score)'));

  finally
    JSONArray.Free;
  end;
end;

procedure TForm1.GetDataFrameFromPython;
var
  JSONStr: string;
  JSONData: TJSONData;
  JSONArray: TJSONArray;
  i: Integer;
begin
  // Obtenir un DataFrame depuis Python au format JSON
  PythonEngine1.ExecString('result_json = df.to_json(orient="records")');
  JSONStr := PythonEngine1.EvalString('result_json');

  // Parser en Pascal
  JSONData := GetJSON(JSONStr);
  try
    if JSONData is TJSONArray then
    begin
      JSONArray := TJSONArray(JSONData);

      StringGrid1.RowCount := JSONArray.Count + 1;

      for i := 0 to JSONArray.Count - 1 do
      begin
        StringGrid1.Cells[0, i + 1] := JSONArray.Items[i].FindPath('id').AsString;
        StringGrid1.Cells[1, i + 1] := JSONArray.Items[i].FindPath('name').AsString;
        StringGrid1.Cells[2, i + 1] := JSONArray.Items[i].FindPath('score').AsString;
      end;
    end;
  finally
    JSONData.Free;
  end;
end;
```

### Streaming de données en temps réel

Pour traiter des flux de données continus :

```pascal
type
  TDataStreamProcessor = class
  private
    FPythonEngine: TPythonEngine;
    FProcessing: Boolean;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure StartProcessing;
    procedure StopProcessing;
    procedure ProcessDataPoint(const Value: Double);
  end;

constructor TDataStreamProcessor.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
  FProcessing := False;

  // Initialiser le modèle de prédiction en streaming
  FPythonEngine.ExecString('import numpy as np');
  FPythonEngine.ExecString('from collections import deque');
  FPythonEngine.ExecString('data_buffer = deque(maxlen=100)');
end;

procedure TDataStreamProcessor.StartProcessing;
begin
  FProcessing := True;
  FPythonEngine.ExecString('data_buffer.clear()');
end;

procedure TDataStreamProcessor.StopProcessing;
begin
  FProcessing := False;
end;

procedure TDataStreamProcessor.ProcessDataPoint(const Value: Double);
var
  Prediction: string;
begin
  if not FProcessing then
    Exit;

  // Ajouter la valeur au buffer Python
  FPythonEngine.ExecString(Format('data_buffer.append(%.4f)', [Value]));

  // Si on a assez de données, faire une prédiction
  FPythonEngine.ExecString(
    'if len(data_buffer) >= 10:' + sLineBreak +
    '    recent_data = list(data_buffer)[-10:]' + sLineBreak +
    '    prediction = predict_next_value(recent_data)' + sLineBreak +
    'else:' + sLineBreak +
    '    prediction = None'
  );

  Prediction := FPythonEngine.EvalString('str(prediction)');

  if Prediction <> 'None' then
    Form1.LabelPrediction.Caption := 'Prédiction : ' + Prediction;
end;

// Utilisation avec un timer
procedure TForm1.Timer1Timer(Sender: TObject);
var
  SensorValue: Double;
begin
  // Lire une valeur de capteur (exemple)
  SensorValue := ReadSensorData();

  // Traiter en temps réel
  DataStreamProcessor.ProcessDataPoint(SensorValue);
end;
```

### Visualisations matplotlib intégrées

Afficher des graphiques matplotlib dans votre application :

```pascal
procedure TForm1.GeneratePlotClick(Sender: TObject);
var
  PlotPath: string;
begin
  PlotPath := GetTempDir + 'plot.png';

  try
    // Créer un graphique avec matplotlib
    PythonEngine1.ExecString('import matplotlib.pyplot as plt');
    PythonEngine1.ExecString('import numpy as np');

    PythonEngine1.ExecString('x = np.linspace(0, 10, 100)');
    PythonEngine1.ExecString('y = np.sin(x)');

    PythonEngine1.ExecString('plt.figure(figsize=(10, 6))');
    PythonEngine1.ExecString('plt.plot(x, y, linewidth=2)');
    PythonEngine1.ExecString('plt.title("Fonction sinus")');
    PythonEngine1.ExecString('plt.xlabel("x")');
    PythonEngine1.ExecString('plt.ylabel("sin(x)")');
    PythonEngine1.ExecString('plt.grid(True)');

    // Sauvegarder dans un fichier temporaire
    PythonEngine1.ExecString(
      Format('plt.savefig(r"%s", dpi=150, bbox_inches="tight")', [PlotPath])
    );
    PythonEngine1.ExecString('plt.close()');

    // Afficher dans un TImage
    if FileExists(PlotPath) then
    begin
      ImagePlot.Picture.LoadFromFile(PlotPath);
      DeleteFile(PlotPath);
    end;

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;

// Version avec graphiques interactifs multiples
procedure TForm1.GenerateMultiplePlots;
var
  PlotTypes: array[0..2] of string = ('line', 'scatter', 'bar');
  i: Integer;
  PlotPath: string;
begin
  for i := 0 to High(PlotTypes) do
  begin
    PlotPath := GetTempDir + 'plot_' + PlotTypes[i] + '.png';

    PythonEngine1.ExecString('plt.figure()');

    case PlotTypes[i] of
      'line':
      begin
        PythonEngine1.ExecString('plt.plot([1,2,3,4], [1,4,2,3])');
        PythonEngine1.ExecString('plt.title("Line Plot")');
      end;
      'scatter':
      begin
        PythonEngine1.ExecString('plt.scatter([1,2,3,4], [1,4,2,3])');
        PythonEngine1.ExecString('plt.title("Scatter Plot")');
      end;
      'bar':
      begin
        PythonEngine1.ExecString('plt.bar([1,2,3,4], [1,4,2,3])');
        PythonEngine1.ExecString('plt.title("Bar Chart")');
      end;
    end;

    PythonEngine1.ExecString(Format('plt.savefig(r"%s")', [PlotPath]));
    PythonEngine1.ExecString('plt.close()');

    // Charger dans différents TImage selon le type
    case i of
      0: ImageLine.Picture.LoadFromFile(PlotPath);
      1: ImageScatter.Picture.LoadFromFile(PlotPath);
      2: ImageBar.Picture.LoadFromFile(PlotPath);
    end;

    DeleteFile(PlotPath);
  end;
end;
```

## Bonnes pratiques et astuces

### 1. Gestion de la mémoire

```pascal
// ❌ Mauvais : Charger un gros modèle à chaque utilisation
procedure ProcessData;
begin
  PythonEngine.ExecString('model = load_huge_model()'); // Lent !
  PythonEngine.ExecString('result = model.predict(data)');
end;

// ✅ Bon : Charger une fois au démarrage
procedure TForm1.FormCreate(Sender: TObject);
begin
  PythonEngine.LoadDll;
  PythonEngine.ExecString('model = load_huge_model()'); // Une seule fois
end;

procedure ProcessData;
begin
  PythonEngine.ExecString('result = model.predict(data)'); // Rapide
end;
```

### 2. Gestion des chemins Windows

```pascal
// Toujours utiliser des chemins raw strings ou échapper les backslashes
procedure LoadFile(const FilePath: string);
var
  SafePath: string;
begin
  // Option 1 : Remplacer \ par /
  SafePath := StringReplace(FilePath, '\', '/', [rfReplaceAll]);
  PythonEngine.ExecString(Format('data = load_file("%s")', [SafePath]));

  // Option 2 : Utiliser raw string (r"...")
  PythonEngine.ExecString(Format('data = load_file(r"%s")', [FilePath]));

  // Option 3 : Doubler les backslashes
  SafePath := StringReplace(FilePath, '\', '\\', [rfReplaceAll]);
  PythonEngine.ExecString(Format('data = load_file("%s")', [SafePath]));
end;
```

### 3. Logging et debugging

```pascal
procedure TForm1.EnablePythonLogging;
begin
  // Configurer le logging Python
  PythonEngine1.ExecString('import logging');
  PythonEngine1.ExecString('logging.basicConfig(level=logging.DEBUG)');
  PythonEngine1.ExecString(
    'logging.basicConfig(' +
    '    filename="python_debug.log", ' +
    '    level=logging.DEBUG, ' +
    '    format="%(asctime)s - %(levelname)s - %(message)s")'
  );

  // Utiliser dans votre code Python
  PythonEngine1.ExecString('logging.info("Application démarrée")');
  PythonEngine1.ExecString('logging.debug("Valeur de x: " + str(x))');
end;
```

### 4. Timeout pour opérations longues

```pascal
uses
  DateUtils;

function ExecutePythonWithTimeout(const Code: string; TimeoutSeconds: Integer): Boolean;
var
  StartTime: TDateTime;
  ThreadFinished: Boolean;
begin
  Result := False;
  ThreadFinished := False;
  StartTime := Now;

  // Lancer dans un thread
  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        PythonEngine.ExecString(Code);
        ThreadFinished := True;
      except
        ThreadFinished := True;
      end;
    end
  ).Start;

  // Attendre avec timeout
  while not ThreadFinished do
  begin
    Application.ProcessMessages;
    Sleep(100);

    if SecondsBetween(Now, StartTime) > TimeoutSeconds then
    begin
      ShowMessage('Timeout : opération trop longue');
      Exit(False);
    end;
  end;

  Result := ThreadFinished;
end;
```

### 5. Vérification de disponibilité des modules

```pascal
procedure TForm1.CheckRequiredModules;
var
  RequiredModules: array of string;
  i: Integer;
  ModuleOK: Boolean;
  MissingModules: TStringList;
begin
  RequiredModules := ['numpy', 'pandas', 'tensorflow', 'opencv'];
  MissingModules := TStringList.Create;
  try
    for i := 0 to High(RequiredModules) do
    begin
      try
        PythonEngine1.ExecString('import ' + RequiredModules[i]);
        ModuleOK := True;
      except
        ModuleOK := False;
      end;

      if not ModuleOK then
        MissingModules.Add(RequiredModules[i]);
    end;

    if MissingModules.Count > 0 then
    begin
      ShowMessage(
        'Modules Python manquants :' + sLineBreak +
        MissingModules.Text + sLineBreak +
        'Installez-les avec :' + sLineBreak +
        'pip install ' + StringReplace(MissingModules.Text, sLineBreak, ' ', [rfReplaceAll])
      );
    end
    else
      ShowMessage('Tous les modules requis sont installés !');

  finally
    MissingModules.Free;
  end;
end;
```

## Résolution de problèmes courants

### Problème 1 : "ImportError: DLL load failed"

**Symptôme :** Python s'initialise mais l'import de bibliothèques échoue.

**Solutions :**

```pascal
// 1. Vérifier l'architecture (32/64 bits)
procedure CheckArchitecture;
var
  Is64Bit: Boolean;
begin
  PythonEngine.ExecString('import sys');
  Is64Bit := PythonEngine.EvalString('sys.maxsize > 2**32') = 'True';

  ShowMessage(Format('Python est %d-bit', [IfThen(Is64Bit, 64, 32)]));
  ShowMessage(Format('Application est %d-bit', [IfThen(SizeOf(Pointer) = 8, 64, 32)]));

  if Is64Bit <> (SizeOf(Pointer) = 8) then
    ShowMessage('INCOMPATIBILITÉ : Python et application doivent être de même architecture !');
end;

// 2. Ajouter le PATH des DLL
procedure AddDLLPath;
begin
  PythonEngine.ExecString('import os');
  PythonEngine.ExecString('import sys');

  // Ajouter le chemin des DLL NumPy par exemple
  PythonEngine.ExecString(
    'dll_path = r"C:\Python310\Lib\site-packages\numpy\.libs"'
  );
  PythonEngine.ExecString('os.add_dll_directory(dll_path)');
end;
```

### Problème 2 : Performance lente

**Optimisations :**

```pascal
// Éviter les conversions répétées
// ❌ Lent
for i := 1 to 1000 do
begin
  PythonEngine.ExecString(Format('process_value(%d)', [i]));
end;

// ✅ Rapide : Construire une liste et traiter en une fois
var
  ValuesList: string;
  i: Integer;
begin
  ValuesList := '[';
  for i := 1 to 1000 do
  begin
    ValuesList := ValuesList + IntToStr(i);
    if i < 1000 then
      ValuesList := ValuesList + ',';
  end;
  ValuesList := ValuesList + ']';

  PythonEngine.ExecString(Format('process_values(%s)', [ValuesList]));
end;
```

### Problème 3 : Fuite mémoire

```pascal
// ❌ Fuite mémoire : Créer des objets Python sans les libérer
procedure LeakMemory;
begin
  PythonEngine.ExecString('big_array = [0] * 10000000');
  // big_array reste en mémoire !
end;

// ✅ Libérer explicitement
procedure NoLeak;
begin
  PythonEngine.ExecString('big_array = [0] * 10000000');
  // Utiliser...
  PythonEngine.ExecString('del big_array'); // Libérer
  PythonEngine.ExecString('import gc; gc.collect()'); // Garbage collection
end;
```

## Conclusion

Python4Lazarus sur Windows offre une intégration puissante et flexible pour développer des applications d'Intelligence Artificielle avec FreePascal. Les points clés à retenir :

### ✅ Avantages
- Accès à tout l'écosystème IA Python
- Interface native Windows avec Lazarus
- Performance du code Pascal pour la logique métier
- Déploiement flexible (avec ou sans Python embarqué)

### ⚠️ Points d'attention
- Configuration initiale demande de l'attention (chemins, DLL)
- Gestion de l'architecture 32/64 bits
- Performance de l'interopérabilité à considérer
- Tester le déploiement sur machine cible

### 🎯 Cas d'usage idéaux
- Applications desktop avec ML/IA
- Outils d'analyse de données avec interface riche
- Prototypes rapides combinant Python et Pascal
- Migration progressive d'applications existantes

### 📚 Ressources essentielles
- Documentation Python4Delphi GitHub
- Forums Lazarus (section Python)
- Documentation Python officielle

## Projets complets

### Projet 1 : Dashboard d'analyse de données en temps réel

Une application complète qui combine visualisation de données, analyse statistique et prédictions ML.

**Architecture du projet :**

```
DataDashboard\
├── main.pas                    # Formulaire principal
├── data_processor.pas          # Traitement des données
├── ml_predictor.pas           # Modèles ML
├── chart_generator.pas        # Génération de graphiques
├── python_scripts\            # Scripts Python réutilisables
│   ├── analyze.py
│   ├── predict.py
│   └── visualize.py
└── models\                    # Modèles pré-entraînés
    └── predictor.pkl
```

**Code principal - main.pas :**

```pascal
unit Main;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  ComCtrls, Grids, PythonEngine, PythonGUIInputOutput,
  DataProcessor, MLPredictor, ChartGenerator;

type
  TMainForm = class(TForm)
    // Composants visuels
    PageControl1: TPageControl;
    TabSheetData: TTabSheet;
    TabSheetAnalysis: TTabSheet;
    TabSheetPrediction: TTabSheet;

    // Onglet Données
    ButtonLoadCSV: TButton;
    StringGridData: TStringGrid;
    LabelRowCount: TLabel;

    // Onglet Analyse
    ImageHistogram: TImage;
    ImageScatter: TImage;
    MemoStats: TMemo;
    ButtonAnalyze: TButton;

    // Onglet Prédiction
    ComboBoxModel: TComboBox;
    ButtonTrain: TButton;
    ButtonPredict: TButton;
    EditInput: TEdit;
    LabelPrediction: TLabel;
    ProgressBarTraining: TProgressBar;

    // Python
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonLoadCSVClick(Sender: TObject);
    procedure ButtonAnalyzeClick(Sender: TObject);
    procedure ButtonTrainClick(Sender: TObject);
    procedure ButtonPredictClick(Sender: TObject);

  private
    FDataProcessor: TDataProcessor;
    FMLPredictor: TMLPredictor;
    FChartGenerator: TChartGenerator;
    FDataLoaded: Boolean;

    procedure InitializePython;
    procedure LoadDataToGrid(const CSVPath: string);
  end;

var
  MainForm: TMainForm;

implementation

{$R *.lfm}

procedure TMainForm.FormCreate(Sender: TObject);
begin
  FDataLoaded := False;

  InitializePython;

  // Créer les objets de traitement
  FDataProcessor := TDataProcessor.Create(PythonEngine1);
  FMLPredictor := TMLPredictor.Create(PythonEngine1);
  FChartGenerator := TChartGenerator.Create(PythonEngine1);

  // Configurer la grille
  StringGridData.ColCount := 5;
  StringGridData.RowCount := 1;
  StringGridData.Cells[0, 0] := 'ID';
  StringGridData.Cells[1, 0] := 'Date';
  StringGridData.Cells[2, 0] := 'Valeur';
  StringGridData.Cells[3, 0] := 'Catégorie';
  StringGridData.Cells[4, 0] := 'Score';

  // Remplir la liste des modèles
  ComboBoxModel.Items.Add('Régression Linéaire');
  ComboBoxModel.Items.Add('Random Forest');
  ComboBoxModel.Items.Add('Réseau de Neurones');
  ComboBoxModel.ItemIndex := 0;
end;

procedure TMainForm.FormDestroy(Sender: TObject);
begin
  FDataProcessor.Free;
  FMLPredictor.Free;
  FChartGenerator.Free;

  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TMainForm.InitializePython;
begin
  try
    PythonEngine1.DllPath := 'C:\Python310';
    PythonEngine1.DllName := 'python310.dll';
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      // Charger les bibliothèques communes
      PythonEngine1.ExecString('import pandas as pd');
      PythonEngine1.ExecString('import numpy as np');
      PythonEngine1.ExecString('import matplotlib.pyplot as plt');
      PythonEngine1.ExecString('from sklearn.model_selection import train_test_split');
      PythonEngine1.ExecString('from sklearn.preprocessing import StandardScaler');

      Caption := 'Data Dashboard - Python ' + PythonEngine1.PyVersion;
    end
    else
      ShowMessage('Erreur : Impossible d''initialiser Python');

  except
    on E: Exception do
      ShowMessage('Erreur Python : ' + E.Message);
  end;
end;

procedure TMainForm.ButtonLoadCSVClick(Sender: TObject);
var
  OpenDialog: TOpenDialog;
begin
  OpenDialog := TOpenDialog.Create(nil);
  try
    OpenDialog.Filter := 'Fichiers CSV|*.csv|Tous les fichiers|*.*';

    if OpenDialog.Execute then
    begin
      LoadDataToGrid(OpenDialog.FileName);
      FDataLoaded := True;
      ButtonAnalyze.Enabled := True;
      ButtonTrain.Enabled := True;
    end;
  finally
    OpenDialog.Free;
  end;
end;

procedure TMainForm.LoadDataToGrid(const CSVPath: string);
var
  RowCount, ColCount: Integer;
  RowCountStr, ColCountStr: string;
begin
  try
    // Charger le CSV avec Pandas
    PythonEngine1.ExecString(
      Format('df = pd.read_csv(r"%s")', [CSVPath])
    );

    // Obtenir les dimensions
    RowCountStr := PythonEngine1.EvalString('str(len(df))');
    ColCountStr := PythonEngine1.EvalString('str(len(df.columns))');

    RowCount := StrToInt(RowCountStr);
    ColCount := StrToInt(ColCountStr);

    // Redimensionner la grille
    StringGridData.RowCount := RowCount + 1;
    StringGridData.ColCount := ColCount;

    // Charger les en-têtes
    PythonEngine1.ExecString('headers = df.columns.tolist()');
    PythonEngine1.ExecString('headers_str = "|".join(headers)');

    var Headers := PythonEngine1.EvalString('headers_str');
    var HeaderList := Headers.Split('|');

    for var i := 0 to High(HeaderList) do
      StringGridData.Cells[i, 0] := HeaderList[i];

    // Charger les données (limiter à 100 premières lignes pour la performance)
    var MaxRows := Min(RowCount, 100);

    for var row := 0 to MaxRows - 1 do
    begin
      PythonEngine1.ExecString(
        Format('row_data = df.iloc[%d].tolist()', [row])
      );
      PythonEngine1.ExecString('row_str = "|".join(map(str, row_data))');

      var RowData := PythonEngine1.EvalString('row_str');
      var CellList := RowData.Split('|');

      for var col := 0 to High(CellList) do
        StringGridData.Cells[col, row + 1] := CellList[col];
    end;

    LabelRowCount.Caption := Format('%d lignes × %d colonnes', [RowCount, ColCount]);

    if RowCount > 100 then
      LabelRowCount.Caption := LabelRowCount.Caption + ' (100 premières affichées)';

  except
    on E: Exception do
      ShowMessage('Erreur lors du chargement : ' + E.Message);
  end;
end;

procedure TMainForm.ButtonAnalyzeClick(Sender: TObject);
begin
  if not FDataLoaded then
  begin
    ShowMessage('Veuillez d''abord charger des données !');
    Exit;
  end;

  ButtonAnalyze.Enabled := False;
  try
    // Générer les statistiques
    MemoStats.Clear;
    MemoStats.Lines.Add('=== ANALYSE STATISTIQUE ===');
    MemoStats.Lines.Add('');

    PythonEngine1.ExecString('stats = df.describe().to_string()');
    MemoStats.Lines.Add(PythonEngine1.EvalString('stats'));

    // Générer l'histogramme
    FChartGenerator.GenerateHistogram(ImageHistogram, 'df');

    // Générer le scatter plot
    FChartGenerator.GenerateScatterPlot(ImageScatter, 'df');

    PageControl1.ActivePage := TabSheetAnalysis;

  finally
    ButtonAnalyze.Enabled := True;
  end;
end;

procedure TMainForm.ButtonTrainClick(Sender: TObject);
var
  ModelType: string;
begin
  if not FDataLoaded then
  begin
    ShowMessage('Veuillez d''abord charger des données !');
    Exit;
  end;

  ModelType := ComboBoxModel.Text;

  ButtonTrain.Enabled := False;
  ProgressBarTraining.Position := 0;
  ProgressBarTraining.Style := pbstMarquee;

  try
    FMLPredictor.TrainModel(ModelType);

    ProgressBarTraining.Style := pbstNormal;
    ProgressBarTraining.Position := 100;

    ShowMessage('Modèle entraîné avec succès !');
    ButtonPredict.Enabled := True;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de l''entraînement : ' + E.Message);
      ProgressBarTraining.Style := pbstNormal;
      ProgressBarTraining.Position := 0;
    end;
  end;

  ButtonTrain.Enabled := True;
end;

procedure TMainForm.ButtonPredictClick(Sender: TObject);
var
  InputValue: Double;
  Prediction: Double;
begin
  try
    InputValue := StrToFloat(EditInput.Text);
    Prediction := FMLPredictor.Predict(InputValue);

    LabelPrediction.Caption := Format('Prédiction : %.2f', [Prediction]);
    LabelPrediction.Font.Color := clGreen;

  except
    on E: Exception do
    begin
      LabelPrediction.Caption := 'Erreur de prédiction';
      LabelPrediction.Font.Color := clRed;
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;

end.
```

**Module de traitement - data_processor.pas :**

```pascal
unit DataProcessor;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TDataProcessor = class
  private
    FPythonEngine: TPythonEngine;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure CleanData;
    procedure NormalizeData;
    procedure HandleMissingValues(const Strategy: string);
    function GetColumnStats(const ColumnName: string): string;
    function FilterData(const Condition: string): Integer;
  end;

implementation

constructor TDataProcessor.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
end;

procedure TDataProcessor.CleanData;
begin
  // Supprimer les doublons
  FPythonEngine.ExecString('df = df.drop_duplicates()');

  // Supprimer les lignes avec trop de valeurs manquantes
  FPythonEngine.ExecString('df = df.dropna(thresh=len(df.columns) * 0.7)');
end;

procedure TDataProcessor.NormalizeData;
begin
  FPythonEngine.ExecString('from sklearn.preprocessing import StandardScaler');
  FPythonEngine.ExecString('numeric_cols = df.select_dtypes(include=[np.number]).columns');
  FPythonEngine.ExecString('scaler = StandardScaler()');
  FPythonEngine.ExecString('df[numeric_cols] = scaler.fit_transform(df[numeric_cols])');
end;

procedure TDataProcessor.HandleMissingValues(const Strategy: string);
begin
  case Strategy of
    'mean':
      FPythonEngine.ExecString('df = df.fillna(df.mean())');
    'median':
      FPythonEngine.ExecString('df = df.fillna(df.median())');
    'mode':
      FPythonEngine.ExecString('df = df.fillna(df.mode().iloc[0])');
    'drop':
      FPythonEngine.ExecString('df = df.dropna()');
  end;
end;

function TDataProcessor.GetColumnStats(const ColumnName: string): string;
begin
  FPythonEngine.ExecString(
    Format('stats = df["%s"].describe().to_string()', [ColumnName])
  );
  Result := FPythonEngine.EvalString('stats');
end;

function TDataProcessor.FilterData(const Condition: string): Integer;
var
  CountStr: string;
begin
  FPythonEngine.ExecString(
    Format('filtered_df = df[%s]', [Condition])
  );
  CountStr := FPythonEngine.EvalString('str(len(filtered_df))');
  Result := StrToInt(CountStr);
end;

end.
```

**Module ML - ml_predictor.pas :**

```pascal
unit MLPredictor;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TMLPredictor = class
  private
    FPythonEngine: TPythonEngine;
    FModelTrained: Boolean;
    FCurrentModel: string;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure TrainModel(const ModelType: string);
    function Predict(const InputValue: Double): Double;
    function PredictBatch(const InputValues: array of Double): TArray<Double>;
    function GetModelAccuracy: Double;
    procedure SaveModel(const FilePath: string);
    procedure LoadModel(const FilePath: string);
  end;

implementation

constructor TMLPredictor.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
  FModelTrained := False;
  FCurrentModel := '';
end;

procedure TMLPredictor.TrainModel(const ModelType: string);
begin
  FCurrentModel := ModelType;

  // Préparer les données
  FPythonEngine.ExecString('X = df.iloc[:, :-1].values');
  FPythonEngine.ExecString('y = df.iloc[:, -1].values');
  FPythonEngine.ExecString(
    'X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)'
  );

  // Sélectionner et entraîner le modèle
  case ModelType of
    'Régression Linéaire':
    begin
      FPythonEngine.ExecString('from sklearn.linear_model import LinearRegression');
      FPythonEngine.ExecString('model = LinearRegression()');
    end;

    'Random Forest':
    begin
      FPythonEngine.ExecString('from sklearn.ensemble import RandomForestRegressor');
      FPythonEngine.ExecString('model = RandomForestRegressor(n_estimators=100, random_state=42)');
    end;

    'Réseau de Neurones':
    begin
      FPythonEngine.ExecString('from sklearn.neural_network import MLPRegressor');
      FPythonEngine.ExecString(
        'model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, random_state=42)'
      );
    end;
  end;

  // Entraîner
  FPythonEngine.ExecString('model.fit(X_train, y_train)');

  // Évaluer
  FPythonEngine.ExecString('score = model.score(X_test, y_test)');

  FModelTrained := True;
end;

function TMLPredictor.Predict(const InputValue: Double): Double;
var
  PredictionStr: string;
begin
  if not FModelTrained then
    raise Exception.Create('Modèle non entraîné !');

  FPythonEngine.ExecString(
    Format('prediction = model.predict([[%.4f]])[0]', [InputValue])
  );

  PredictionStr := FPythonEngine.EvalString('str(prediction)');
  Result := StrToFloat(PredictionStr);
end;

function TMLPredictor.PredictBatch(const InputValues: array of Double): TArray<Double>;
var
  i: Integer;
  InputList: string;
  PredictionsStr: string;
  Predictions: TStringArray;
begin
  if not FModelTrained then
    raise Exception.Create('Modèle non entraîné !');

  // Construire la liste Python
  InputList := '[';
  for i := 0 to High(InputValues) do
  begin
    InputList := InputList + Format('[%.4f]', [InputValues[i]]);
    if i < High(InputValues) then
      InputList := InputList + ',';
  end;
  InputList := InputList + ']';

  FPythonEngine.ExecString(
    Format('predictions = model.predict(%s)', [InputList])
  );
  FPythonEngine.ExecString('predictions_str = "|".join(map(str, predictions))');

  PredictionsStr := FPythonEngine.EvalString('predictions_str');
  Predictions := PredictionsStr.Split('|');

  SetLength(Result, Length(Predictions));
  for i := 0 to High(Predictions) do
    Result[i] := StrToFloat(Predictions[i]);
end;

function TMLPredictor.GetModelAccuracy: Double;
var
  ScoreStr: string;
begin
  if not FModelTrained then
    raise Exception.Create('Modèle non entraîné !');

  ScoreStr := FPythonEngine.EvalString('str(score)');
  Result := StrToFloat(ScoreStr);
end;

procedure TMLPredictor.SaveModel(const FilePath: string);
begin
  if not FModelTrained then
    raise Exception.Create('Modèle non entraîné !');

  FPythonEngine.ExecString('import pickle');
  FPythonEngine.ExecString(
    Format('with open(r"%s", "wb") as f: pickle.dump(model, f)', [FilePath])
  );
end;

procedure TMLPredictor.LoadModel(const FilePath: string);
begin
  FPythonEngine.ExecString('import pickle');
  FPythonEngine.ExecString(
    Format('with open(r"%s", "rb") as f: model = pickle.load(f)', [FilePath])
  );
  FModelTrained := True;
end;

end.
```

**Module graphiques - chart_generator.pas :**

```pascal
unit ChartGenerator;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Graphics, ExtCtrls, PythonEngine;

type
  TChartGenerator = class
  private
    FPythonEngine: TPythonEngine;
    function GetTempImagePath: string;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure GenerateHistogram(TargetImage: TImage; const DataFrameName: string);
    procedure GenerateScatterPlot(TargetImage: TImage; const DataFrameName: string);
    procedure GenerateLinePlot(TargetImage: TImage; const XColumn, YColumn: string);
    procedure GenerateBoxPlot(TargetImage: TImage; const ColumnName: string);
    procedure GenerateHeatmap(TargetImage: TImage; const DataFrameName: string);
  end;

implementation

constructor TChartGenerator.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;

  // Configurer matplotlib
  FPythonEngine.ExecString('import matplotlib');
  FPythonEngine.ExecString('matplotlib.use("Agg")'); // Backend sans GUI
  FPythonEngine.ExecString('import matplotlib.pyplot as plt');
  FPythonEngine.ExecString('import seaborn as sns');
  FPythonEngine.ExecString('sns.set_style("whitegrid")');
end;

function TChartGenerator.GetTempImagePath: string;
begin
  Result := GetTempDir + 'chart_' + FormatDateTime('yyyymmddhhnnsszzz', Now) + '.png';
end;

procedure TChartGenerator.GenerateHistogram(TargetImage: TImage; const DataFrameName: string);
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(10, 6))');
    FPythonEngine.ExecString(
      Format('%s.hist(bins=30, edgecolor="black")', [DataFrameName])
    );
    FPythonEngine.ExecString('plt.title("Distribution des données")');
    FPythonEngine.ExecString('plt.xlabel("Valeur")');
    FPythonEngine.ExecString('plt.ylabel("Fréquence")');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur génération histogramme : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateScatterPlot(TargetImage: TImage; const DataFrameName: string);
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(10, 6))');
    FPythonEngine.ExecString(
      Format('numeric_cols = %s.select_dtypes(include=[np.number]).columns', [DataFrameName])
    );
    FPythonEngine.ExecString(
      Format('if len(numeric_cols) >= 2: plt.scatter(%s[numeric_cols[0]], %s[numeric_cols[1]])',
      [DataFrameName, DataFrameName])
    );
    FPythonEngine.ExecString('plt.title("Scatter Plot")');
    FPythonEngine.ExecString('plt.xlabel("Variable 1")');
    FPythonEngine.ExecString('plt.ylabel("Variable 2")');
    FPythonEngine.ExecString('plt.grid(True, alpha=0.3)');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur génération scatter plot : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateLinePlot(TargetImage: TImage; const XColumn, YColumn: string);
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(12, 6))');
    FPythonEngine.ExecString(
      Format('plt.plot(df["%s"], df["%s"], linewidth=2, marker="o")', [XColumn, YColumn])
    );
    FPythonEngine.ExecString(Format('plt.title("%s vs %s")', [YColumn, XColumn]));
    FPythonEngine.ExecString(Format('plt.xlabel("%s")', [XColumn]));
    FPythonEngine.ExecString(Format('plt.ylabel("%s")', [YColumn]));
    FPythonEngine.ExecString('plt.grid(True, alpha=0.3)');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur génération line plot : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateBoxPlot(TargetImage: TImage; const ColumnName: string);
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(8, 6))');
    FPythonEngine.ExecString(
      Format('df[["%s"]].boxplot()', [ColumnName])
    );
    FPythonEngine.ExecString(Format('plt.title("Box Plot - %s")', [ColumnName]));
    FPythonEngine.ExecString('plt.ylabel("Valeur")');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur génération box plot : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateHeatmap(TargetImage: TImage; const DataFrameName: string);
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(10, 8))');
    FPythonEngine.ExecString(
      Format('correlation = %s.corr()', [DataFrameName])
    );
    FPythonEngine.ExecString(
      'sns.heatmap(correlation, annot=True, cmap="coolwarm", center=0)'
    );
    FPythonEngine.ExecString('plt.title("Matrice de corrélation")');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur génération heatmap : ' + E.Message);
  end;
end;

end.
```

## Conclusion et synthèse

### Ce que vous avez appris

Dans cette section complète sur Python4Lazarus pour Windows, vous avez découvert :

✅ **Installation et configuration** complète de Python et Python4Lazarus
✅ **Intégration basique** : exécution de code Python depuis Pascal
✅ **Échange de données** : passage de variables entre les deux langages
✅ **Projets avancés** : applications ML complètes avec interface graphique
✅ **Optimisations** : meilleures pratiques pour la performance
✅ **Déploiement** : stratégies pour distribuer vos applications
✅ **Résolution de problèmes** : solutions aux erreurs courantes

### Compétences acquises

Vous êtes maintenant capable de :

- Créer des applications Windows avec interface Lazarus et moteur IA Python
- Intégrer TensorFlow, scikit-learn et autres bibliothèques ML
- Construire des dashboards d'analyse de données
- Générer des visualisations matplotlib dans vos applications
- Déployer des applications hybrides Pascal/Python
- Optimiser les performances de l'interopérabilité
- Déboguer efficacement les erreurs d'intégration

### Prochaines étapes

**Section suivante : 15.7.2 Python4Lazarus sur Ubuntu**

La prochaine section couvrira les spécificités de l'intégration Python sous Linux/Ubuntu, notamment :

- Installation via apt et pip
- Configuration des chemins Unix
- Gestion des bibliothèques partagées .so
- Différences avec Windows
- Scripts de déploiement Linux

### Ressources complémentaires

**Documentation officielle :**
- Python4Delphi : [github.com/pyscripter/python4delphi](https://github.com/pyscripter/python4delphi)
- Wiki Python4Delphi : Exemples et FAQ
- Python Documentation : [docs.python.org](https://docs.python.org)
- Lazarus Forums : Section "Third Party" pour Python

**Bibliothèques Python essentielles :**

```cmd
# Data Science
pip install numpy pandas matplotlib seaborn scipy

# Machine Learning
pip install scikit-learn tensorflow torch xgboost

# Computer Vision
pip install opencv-python pillow scikit-image

# NLP
pip install transformers spacy nltk textblob

# Autres utilitaires
pip install requests beautifulsoup4 sqlalchemy
```

**Tutoriels vidéo et articles :**
- YouTube : "Python4Delphi tutorials"
- Medium : Articles sur l'intégration Python/Pascal
- Stack Overflow : Tag "python4delphi"

## Checklist de déploiement

Avant de déployer votre application sur Windows, vérifiez :

### ✅ Configuration Python

- [ ] Python installé dans un emplacement cohérent
- [ ] Version Python testée (3.9, 3.10 ou 3.11)
- [ ] Architecture cohérente (32-bit ou 64-bit)
- [ ] Bibliothèques Python installées via requirements.txt
- [ ] Chemins Python configurables (fichier de configuration)

### ✅ Application Lazarus

- [ ] Gestion d'erreur robuste pour l'initialisation Python
- [ ] Chemins relatifs ou configurables pour les scripts
- [ ] Libération correcte des ressources Python
- [ ] Tests sur machine propre (sans environnement de développement)
- [ ] Documentation utilisateur pour l'installation Python

### ✅ Fichiers de déploiement

```
MonApplication\
├── MonApp.exe
├── config.ini                    # Configuration Python
├── readme.txt                    # Instructions installation
├── requirements.txt              # Dépendances Python
├── scripts\                      # Scripts Python
│   ├── __init__.py
│   ├── preprocessing.py
│   └── models.py
├── models\                       # Modèles ML
│   └── trained_model.pkl
└── python_embedded\              # (Optionnel) Python portable
    ├── python.exe
    └── ...
```

**Exemple config.ini :**

```ini
[Python]
DllPath=C:\Python310
DllName=python310.dll
UseSystemPython=1

[Paths]
ScriptsFolder=.\scripts
ModelsFolder=.\models
TempFolder=%TEMP%\MonApp

[Models]
DefaultModel=.\models\trained_model.pkl
AutoLoadModel=1
```

**Code pour lire la configuration :**

```pascal
uses
  IniFiles;

procedure TForm1.LoadPythonConfig;
var
  Config: TIniFile;
  DllPath, DllName: string;
  UseSystemPython: Boolean;
begin
  Config := TIniFile.Create(ExtractFilePath(Application.ExeName) + 'config.ini');
  try
    DllPath := Config.ReadString('Python', 'DllPath', 'C:\Python310');
    DllName := Config.ReadString('Python', 'DllName', 'python310.dll');
    UseSystemPython := Config.ReadBool('Python', 'UseSystemPython', True);

    if UseSystemPython then
    begin
      // Laisser Python4Lazarus trouver Python dans le PATH
      PythonEngine1.UseLastKnownVersion := True;
    end
    else
    begin
      // Utiliser le chemin spécifié
      PythonEngine1.DllPath := DllPath;
      PythonEngine1.DllName := DllName;
    end;

    PythonEngine1.LoadDll;

  finally
    Config.Free;
  end;
end;
```

### ✅ Tests de déploiement

- [ ] Test sur Windows 10 propre
- [ ] Test sur Windows 11
- [ ] Test avec et sans Python pré-installé
- [ ] Test avec différentes versions Python
- [ ] Test de la gestion des erreurs (Python manquant, bibliothèques manquantes)
- [ ] Test de performance avec données réelles
- [ ] Test de la consommation mémoire

## Patterns de conception recommandés

### Pattern Singleton pour PythonEngine

Éviter de créer plusieurs instances de PythonEngine :

```pascal
unit PythonManager;

{$mode objfpc}{$H+}

interface

uses
  PythonEngine;

type
  TPythonManager = class
  private
    class var FInstance: TPythonManager;
    FEngine: TPythonEngine;
    constructor Create;
  public
    destructor Destroy; override;
    class function Instance: TPythonManager;
    property Engine: TPythonEngine read FEngine;
  end;

implementation

var
  _Instance: TPythonManager = nil;

constructor TPythonManager.Create;
begin
  inherited Create;
  FEngine := TPythonEngine.Create(nil);
  FEngine.DllPath := 'C:\Python310';
  FEngine.LoadDll;
end;

destructor TPythonManager.Destroy;
begin
  if FEngine.Initialized then
    FEngine.Finalize;
  FEngine.Free;
  inherited Destroy;
end;

class function TPythonManager.Instance: TPythonManager;
begin
  if _Instance = nil then
    _Instance := TPythonManager.Create;
  Result := _Instance;
end;

initialization

finalization
  if _Instance <> nil then
    _Instance.Free;

end.

// Utilisation partout dans l'application
var
  Python: TPythonEngine;
begin
  Python := TPythonManager.Instance.Engine;
  Python.ExecString('print("Hello!")');
end;
```

### Pattern Factory pour les modèles ML

```pascal
unit MLModelFactory;

interface

uses
  PythonEngine;

type
  IMLModel = interface
    ['{12345678-1234-1234-1234-123456789012}']
    procedure Train(const Data: string);
    function Predict(const Input: string): string;
    function GetAccuracy: Double;
  end;

  TLinearRegressionModel = class(TInterfacedObject, IMLModel)
  private
    FPythonEngine: TPythonEngine;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure Train(const Data: string);
    function Predict(const Input: string): string;
    function GetAccuracy: Double;
  end;

  TRandomForestModel = class(TInterfacedObject, IMLModel)
  private
    FPythonEngine: TPythonEngine;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure Train(const Data: string);
    function Predict(const Input: string): string;
    function GetAccuracy: Double;
  end;

  TMLModelFactory = class
  public
    class function CreateModel(const ModelType: string;
                               APythonEngine: TPythonEngine): IMLModel;
  end;

implementation

{ TLinearRegressionModel }

constructor TLinearRegressionModel.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
  FPythonEngine.ExecString('from sklearn.linear_model import LinearRegression');
  FPythonEngine.ExecString('model = LinearRegression()');
end;

procedure TLinearRegressionModel.Train(const Data: string);
begin
  FPythonEngine.ExecString(Format('model.fit(%s)', [Data]));
end;

function TLinearRegressionModel.Predict(const Input: string): string;
begin
  FPythonEngine.ExecString(Format('prediction = model.predict(%s)', [Input]));
  Result := FPythonEngine.EvalString('str(prediction)');
end;

function TLinearRegressionModel.GetAccuracy: Double;
begin
  Result := StrToFloat(FPythonEngine.EvalString('str(model.score(X_test, y_test))'));
end;

{ TRandomForestModel }

constructor TRandomForestModel.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;
  FPythonEngine.ExecString('from sklearn.ensemble import RandomForestRegressor');
  FPythonEngine.ExecString('model = RandomForestRegressor()');
end;

procedure TRandomForestModel.Train(const Data: string);
begin
  FPythonEngine.ExecString(Format('model.fit(%s)', [Data]));
end;

function TRandomForestModel.Predict(const Input: string): string;
begin
  FPythonEngine.ExecString(Format('prediction = model.predict(%s)', [Input]));
  Result := FPythonEngine.EvalString('str(prediction)');
end;

function TRandomForestModel.GetAccuracy: Double;
begin
  Result := StrToFloat(FPythonEngine.EvalString('str(model.score(X_test, y_test))'));
end;

{ TMLModelFactory }

class function TMLModelFactory.CreateModel(const ModelType: string;
                                          APythonEngine: TPythonEngine): IMLModel;
begin
  if ModelType = 'LinearRegression' then
    Result := TLinearRegressionModel.Create(APythonEngine)
  else if ModelType = 'RandomForest' then
    Result := TRandomForestModel.Create(APythonEngine)
  else
    raise Exception.Create('Type de modèle inconnu : ' + ModelType);
end;

end.

// Utilisation
var
  Model: IMLModel;
begin
  Model := TMLModelFactory.CreateModel('RandomForest', PythonEngine);
  Model.Train('X_train, y_train');
  ShowMessage('Prédiction : ' + Model.Predict('[1.5, 2.3, 4.1]'));
end;
```

### Pattern Observer pour les notifications Python

```pascal
unit PythonObserver;

interface

uses
  Classes, SysUtils;

type
  IPythonObserver = interface
    ['{87654321-4321-4321-4321-210987654321}']
    procedure OnPythonOutput(const Output: string);
    procedure OnPythonError(const Error: string);
    procedure OnPythonProgress(const Progress: Integer);
  end;

  TPythonSubject = class
  private
    FObservers: TInterfaceList;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Attach(Observer: IPythonObserver);
    procedure Detach(Observer: IPythonObserver);
    procedure NotifyOutput(const Output: string);
    procedure NotifyError(const Error: string);
    procedure NotifyProgress(const Progress: Integer);
  end;

implementation

constructor TPythonSubject.Create;
begin
  inherited Create;
  FObservers := TInterfaceList.Create;
end;

destructor TPythonSubject.Destroy;
begin
  FObservers.Free;
  inherited Destroy;
end;

procedure TPythonSubject.Attach(Observer: IPythonObserver);
begin
  FObservers.Add(Observer);
end;

procedure TPythonSubject.Detach(Observer: IPythonObserver);
begin
  FObservers.Remove(Observer);
end;

procedure TPythonSubject.NotifyOutput(const Output: string);
var
  i: Integer;
  Observer: IPythonObserver;
begin
  for i := 0 to FObservers.Count - 1 do
  begin
    Observer := FObservers[i] as IPythonObserver;
    Observer.OnPythonOutput(Output);
  end;
end;

procedure TPythonSubject.NotifyError(const Error: string);
var
  i: Integer;
  Observer: IPythonObserver;
begin
  for i := 0 to FObservers.Count - 1 do
  begin
    Observer := FObservers[i] as IPythonObserver;
    Observer.OnPythonError(Error);
  end;
end;

procedure TPythonSubject.NotifyProgress(const Progress: Integer);
var
  i: Integer;
  Observer: IPythonObserver;
begin
  for i := 0 to FObservers.Count - 1 do
  begin
    Observer := FObservers[i] as IPythonObserver;
    Observer.OnPythonProgress(Progress);
  end;
end;

end.
```

## Exemples d'utilisation professionnelle

### Cas d'usage 1 : Application médicale d'analyse d'images

```pascal
// Analyse d'images médicales avec détection de pathologies
procedure TFormMedical.AnalyzeMedicalImage(const ImagePath: string);
begin
  try
    // Charger le modèle de détection (une seule fois au démarrage)
    if not FModelLoaded then
    begin
      PythonEngine.ExecString('import tensorflow as tf');
      PythonEngine.ExecString('model = tf.keras.models.load_model("medical_detector.h5")');
      FModelLoaded := True;
    end;

    // Prétraiter l'image
    PythonEngine.ExecString(Format('img = preprocess_medical_image(r"%s")', [ImagePath]));

    // Faire la prédiction
    PythonEngine.ExecString('prediction = model.predict(img)');
    PythonEngine.ExecString('pathology_detected = prediction[0][0] > 0.7');
    PythonEngine.ExecString('confidence = float(prediction[0][0])');

    // Récupérer les résultats
    var Detected := PythonEngine.EvalString('str(pathology_detected)') = 'True';
    var Confidence := StrToFloat(PythonEngine.EvalString('str(confidence)'));

    // Afficher dans l'interface
    if Detected then
    begin
      LabelResult.Caption := Format('⚠️ Pathologie détectée (confiance: %.1f%%)',
                                    [Confidence * 100]);
      LabelResult.Font.Color := clRed;

      // Générer un rapport
      GenerateMedicalReport(ImagePath, Confidence);
    end
    else
    begin
      LabelResult.Caption := 'Aucune pathologie détectée';
      LabelResult.Font.Color := clGreen;
    end;

  except
    on E: Exception do
      ShowMessage('Erreur analyse : ' + E.Message);
  end;
end;
```

### Cas d'usage 2 : Système de trading algorithmique

```pascal
unit TradingBot;

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TTradingBot = class
  private
    FPythonEngine: TPythonEngine;
    FStrategy: string;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure LoadStrategy(const StrategyName: string);
    function AnalyzeMarket(const Symbol: string): string;
    function ShouldBuy(const Symbol: string; const Price: Double): Boolean;
    function ShouldSell(const Symbol: string; const Price: Double): Boolean;
    function CalculatePosition(const Capital: Double): Double;
  end;

implementation

constructor TTradingBot.Create(APythonEngine: TPythonEngine);
begin
  FPythonEngine := APythonEngine;

  // Initialiser les bibliothèques de trading
  FPythonEngine.ExecString('import pandas as pd');
  FPythonEngine.ExecString('import numpy as np');
  FPythonEngine.ExecString('import ta'); // Technical Analysis library
end;

procedure TTradingBot.LoadStrategy(const StrategyName: string);
begin
  FStrategy := StrategyName;

  case StrategyName of
    'MA_Crossover':
    begin
      FPythonEngine.ExecString(
        'def strategy(data):' + sLineBreak +
        '    data["MA20"] = data["Close"].rolling(20).mean()' + sLineBreak +
        '    data["MA50"] = data["Close"].rolling(50).mean()' + sLineBreak +
        '    signal = "BUY" if data["MA20"].iloc[-1] > data["MA50"].iloc[-1] else "SELL"' + sLineBreak +
        '    return signal'
      );
    end;

    'RSI':
    begin
      FPythonEngine.ExecString(
        'def strategy(data):' + sLineBreak +
        '    rsi = ta.momentum.RSIIndicator(data["Close"]).rsi()' + sLineBreak +
        '    if rsi.iloc[-1] < 30:' + sLineBreak +
        '        return "BUY"' + sLineBreak +
        '    elif rsi.iloc[-1] > 70:' + sLineBreak +
        '        return "SELL"' + sLineBreak +
        '    else:' + sLineBreak +
        '        return "HOLD"'
      );
    end;
  end;
end;

function TTradingBot.AnalyzeMarket(const Symbol: string): string;
begin
  FPythonEngine.ExecString(Format('data = get_market_data("%s")', [Symbol]));
  FPythonEngine.ExecString('signal = strategy(data)');
  Result := FPythonEngine.EvalString('signal');
end;

function TTradingBot.ShouldBuy(const Symbol: string; const Price: Double): Boolean;
begin
  Result := AnalyzeMarket(Symbol) = 'BUY';
end;

function TTradingBot.ShouldSell(const Symbol: string; const Price: Double): Boolean;
begin
  Result := AnalyzeMarket(Symbol) = 'SELL';
end;

function TTradingBot.CalculatePosition(const Capital: Double): Double;
var
  RiskPercent: Double;
begin
  RiskPercent := 0.02; // 2% du capital
  Result := Capital * RiskPercent;
end;

end.
```

### Cas d'usage 3 : Analyse de sentiment sur réseaux sociaux

```pascal
procedure TFormSocialMedia.AnalyzeSocialSentiment(const Topic: string);
var
  TweetCount: Integer;
  PositivePercent: Double;
  NegativePercent: Double;
  NeutralPercent: Double;
begin
  try
    // Collecter les tweets (simulation, en réalité utiliser l'API Twitter)
    PythonEngine.ExecString(
      Format('tweets = collect_tweets("%s", count=100)', [Topic])
    );

    // Analyser le sentiment avec un modèle pré-entraîné
    PythonEngine.ExecString('from transformers import pipeline');
    PythonEngine.ExecString('sentiment_analyzer = pipeline("sentiment-analysis")');

    PythonEngine.ExecString(
      'sentiments = [sentiment_analyzer(tweet)[0] for tweet in tweets]'
    );

    // Calculer les statistiques
    PythonEngine.ExecString(
      'positive = sum(1 for s in sentiments if s["label"] == "POSITIVE")' + sLineBreak +
      'negative = sum(1 for s in sentiments if s["label"] == "NEGATIVE")' + sLineBreak +
      'neutral = len(sentiments) - positive - negative' + sLineBreak +
      'total = len(sentiments)'
    );

    TweetCount := StrToInt(PythonEngine.EvalString('str(total)'));
    PositivePercent := StrToFloat(PythonEngine.EvalString('str(positive/total*100)'));
    NegativePercent := StrToFloat(PythonEngine.EvalString('str(negative/total*100)'));
    NeutralPercent := StrToFloat(PythonEngine.EvalString('str(neutral/total*100)'));

    // Afficher les résultats
    MemoResults.Lines.Clear;
    MemoResults.Lines.Add(Format('=== Analyse de sentiment : %s ===', [Topic]));
    MemoResults.Lines.Add(Format('Tweets analysés : %d', [TweetCount]));
    MemoResults.Lines.Add('');
    MemoResults.Lines.Add(Format('😊 Positif : %.1f%%', [PositivePercent]));
    MemoResults.Lines.Add(Format('😞 Négatif : %.1f%%', [NegativePercent]));
    MemoResults.Lines.Add(Format('😐 Neutre : %.1f%%', [NeutralPercent]));

    // Générer un graphique
    GenerateSentimentChart(PositivePercent, NegativePercent, NeutralPercent);

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

## Récapitulatif final

### Points clés à retenir

1. **Installation** : Python 3.9-3.11, architecture cohérente, PATH configuré
2. **Configuration** : DllPath, DllName, UseLastKnownVersion
3. **Initialisation** : LoadDll en FormCreate, gestion d'erreurs robuste
4. **Échange de données** : ExecString, EvalString, JSON pour structures complexes
5. **Performance** : Charger modèles une fois, minimiser les appels, threading
6. **Déploiement** : Python embarqué ou requirements.txt, configuration flexible
7. **Debugging** : Logging Python, capture stderr, gestion d'exceptions

### Erreurs à éviter

❌ Ne pas gérer les erreurs d'initialisation Python
❌ Réimporter des bibliothèques à chaque utilisation
❌ Oublier de libérer les ressources (Finalize)
❌ Mélanger architectures 32/64 bits
❌ Chemins Windows avec backslashes non échappés
❌ Tester uniquement sur machine de développement
❌ Ne pas vérifier la disponibilité des modules Python

### Avantages de cette approche

✅ Interface native Windows rapide et professionnelle
✅ Accès complet à l'écosystème Python pour l'IA
✅ Performance optimale pour la logique métier
✅ Déploiement flexible selon les besoins
✅ Maintenance facilitée (Python pour IA, Pascal pour UI)
✅ Évolutivité progressive (prototypage → production)

## Pour aller plus loin

### Prochaine section

**15.7.2 Python4Lazarus sur Ubuntu** couvrira :
- Installation via apt-get et pip
- Gestion des bibliothèques partagées (.so)
- Chemins Unix et permissions
- Différences avec Windows
- Scripts de déploiement Linux
- Empaquetage .deb et AppImage

### Sujets avancés à explorer

- **Async/Await** : Intégration asyncio Python avec threading Pascal
- **Microservices** : Application Pascal + API Python séparées
- **GPU Computing** : CUDA/OpenCL via Python depuis Pascal
- **Real-time** : Streaming de données avec ZeroMQ
- **Edge AI** : Déploiement sur Raspberry Pi

### Communauté et support

- **Forum Lazarus** : [forum.lazarus.freepascal.org](https://forum.lazarus.freepascal.org)
- **Python4Delphi GitHub** : Issues et discussions
- **Discord FreePascal** : Canal #python-integration
- **Stack Overflow** : Tags "freepascal" + "python"

---

**Félicitations !** Vous maîtrisez maintenant l'intégration Python/FreePascal sur Windows. Vous êtes prêt à créer des applications professionnelles combinant la puissance de l'IA Python avec la performance et l'ergonomie de Lazarus.

**Prochaine étape** : Section 15.7.2 pour découvrir les spécificités Ubuntu/Linux ! 🐧🐍

⏭️ [Python4Lazarus sur Ubuntu](/15-intelligence-artificielle-machine-learning/07.2-python4lazarus-ubuntu.md)
