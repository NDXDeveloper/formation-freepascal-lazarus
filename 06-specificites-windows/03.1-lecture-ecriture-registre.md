üîù Retour au [Sommaire](/SOMMAIRE.md)

# Lecture/√©criture dans le Registre Windows avec FreePascal/Lazarus

## Introduction : Les bases de l'acc√®s au Registre

Acc√©der au Registre Windows avec FreePascal/Lazarus est simple gr√¢ce √† l'unit√© `Registry`. Cette unit√© encapsule toute la complexit√© de l'API Windows et offre une interface orient√©e objet facile √† utiliser.

### La classe TRegistry

La classe `TRegistry` est votre point d'entr√©e pour toutes les op√©rations sur le Registre :

```pascal
uses
  Registry;

var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;  // Cr√©er l'objet
  try
    // Utiliser le Registre
  finally
    Reg.Free;  // TOUJOURS lib√©rer l'objet
  end;
end;
```

## Configuration de base

### D√©finir la ruche racine

Avant toute op√©ration, vous devez d√©finir dans quelle ruche vous voulez travailler :

```pascal
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    // Choisir la ruche
    Reg.RootKey := HKEY_CURRENT_USER;    // Pour l'utilisateur actuel
    // ou
    Reg.RootKey := HKEY_LOCAL_MACHINE;   // Pour tout le syst√®me (n√©cessite admin)
    // ou
    Reg.RootKey := HKEY_CLASSES_ROOT;    // Pour les associations de fichiers

  finally
    Reg.Free;
  end;
end;
```

### Mode d'acc√®s

Par d√©faut, TRegistry ouvre les cl√©s en lecture/√©criture. Vous pouvez changer ce comportement :

```pascal
Reg := TRegistry.Create(KEY_READ);  // Lecture seule
// ou
Reg := TRegistry.Create(KEY_WRITE); // √âcriture seule
// ou
Reg := TRegistry.Create(KEY_ALL_ACCESS); // Acc√®s complet
```

## Op√©rations de lecture

### Lire une valeur simple

```pascal
procedure LireConfigurationSimple;
var
  Reg: TRegistry;
  MaValeur: string;
begin
  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    // Ouvrir la cl√© (false = ne pas cr√©er si elle n'existe pas)
    if Reg.OpenKey('Software\MonEntreprise\MonApplication', False) then
    begin
      try
        // V√©rifier que la valeur existe avant de la lire
        if Reg.ValueExists('NomUtilisateur') then
          MaValeur := Reg.ReadString('NomUtilisateur')
        else
          MaValeur := 'Utilisateur par d√©faut';

        ShowMessage('Bonjour ' + MaValeur);

      finally
        Reg.CloseKey;  // Toujours fermer la cl√©
      end;
    end
    else
      ShowMessage('Application non configur√©e');

  finally
    Reg.Free;
  end;
end;
```

### Lire diff√©rents types de donn√©es

```pascal
procedure LireTousLesTypes;
var
  Reg: TRegistry;
  TexteSimple: string;
  Nombre: Integer;
  NombreGrand: Int64;
  Booleen: Boolean;
  DateHeure: TDateTime;
  DonneesBinaires: array of Byte;
  ListeChaines: TStringList;
  Taille: Integer;
begin
  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software\MonApp\Config', False) then
    begin
      try
        // Lire une cha√Æne (REG_SZ)
        if Reg.ValueExists('Theme') then
          TexteSimple := Reg.ReadString('Theme');

        // Lire un entier 32 bits (REG_DWORD)
        if Reg.ValueExists('TaillePolice') then
          Nombre := Reg.ReadInteger('TaillePolice');

        // Lire un bool√©en (stock√© comme DWORD 0 ou 1)
        if Reg.ValueExists('ModeNuit') then
          Booleen := Reg.ReadBool('ModeNuit');

        // Lire une date/heure (stock√©e comme REG_BINARY)
        if Reg.ValueExists('DerniereLancement') then
          DateHeure := Reg.ReadDateTime('DerniereLancement');

        // Lire un entier 64 bits (REG_QWORD) - Windows Vista+
        if Reg.ValueExists('EspaceUtilise') then
        begin
          // ReadInt64 n'existe pas toujours, alternative :
          Taille := Reg.GetDataSize('EspaceUtilise');
          if Taille = SizeOf(Int64) then
          begin
            SetLength(DonneesBinaires, Taille);
            Reg.ReadBinaryData('EspaceUtilise', DonneesBinaires[0], Taille);
            Move(DonneesBinaires[0], NombreGrand, SizeOf(Int64));
          end;
        end;

        // Lire des donn√©es binaires (REG_BINARY)
        if Reg.ValueExists('CleSecrete') then
        begin
          Taille := Reg.GetDataSize('CleSecrete');
          SetLength(DonneesBinaires, Taille);
          Reg.ReadBinaryData('CleSecrete', DonneesBinaires[0], Taille);
        end;

        // Lire une cha√Æne expansible (REG_EXPAND_SZ)
        // Les variables d'environnement sont automatiquement expand√©es
        if Reg.ValueExists('CheminDonnees') then
          TexteSimple := Reg.ReadString('CheminDonnees');
          // Si la valeur √©tait "%APPDATA%\MonApp", elle devient
          // "C:\Users\NomUtilisateur\AppData\Roaming\MonApp"

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    Reg.Free;
  end;
end;
```

### Lire toutes les valeurs d'une cl√©

```pascal
procedure ListerToutesLesValeurs;
var
  Reg: TRegistry;
  ListeValeurs: TStringList;
  i: Integer;
  TypeValeur: TRegDataType;
  TypeStr: string;
begin
  Reg := TRegistry.Create(KEY_READ);
  ListeValeurs := TStringList.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software\MonApp\Settings', False) then
    begin
      try
        // Obtenir la liste de toutes les valeurs
        Reg.GetValueNames(ListeValeurs);

        WriteLn('Valeurs trouv√©es dans la cl√© :');
        WriteLn('================================');

        for i := 0 to ListeValeurs.Count - 1 do
        begin
          // Obtenir le type de chaque valeur
          TypeValeur := Reg.GetDataType(ListeValeurs[i]);

          case TypeValeur of
            rdString:       TypeStr := 'Cha√Æne';
            rdExpandString: TypeStr := 'Cha√Æne expansible';
            rdInteger:      TypeStr := 'Entier 32 bits';
            rdBinary:       TypeStr := 'Binaire';
            rdUnknown:      TypeStr := 'Inconnu';
          else
            TypeStr := 'Autre';
          end;

          WriteLn(Format('  %s [%s]', [ListeValeurs[i], TypeStr]));

          // Lire et afficher la valeur selon son type
          case TypeValeur of
            rdString, rdExpandString:
              WriteLn('    Valeur : ' + Reg.ReadString(ListeValeurs[i]));

            rdInteger:
              WriteLn('    Valeur : ' + IntToStr(Reg.ReadInteger(ListeValeurs[i])));

            rdBinary:
              WriteLn('    Valeur : [Donn√©es binaires, ' +
                      IntToStr(Reg.GetDataSize(ListeValeurs[i])) + ' octets]');
          end;
        end;

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    ListeValeurs.Free;
    Reg.Free;
  end;
end;
```

### Parcourir les sous-cl√©s

```pascal
procedure ParcourirSousCl√©s;
var
  Reg: TRegistry;
  ListeCl√©s: TStringList;
  i: Integer;
begin
  Reg := TRegistry.Create(KEY_READ);
  ListeCl√©s := TStringList.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software', False) then
    begin
      try
        // Obtenir toutes les sous-cl√©s
        Reg.GetKeyNames(ListeCl√©s);

        WriteLn('Applications install√©es pour cet utilisateur :');
        WriteLn('=============================================');

        for i := 0 to ListeCl√©s.Count - 1 do
        begin
          WriteLn('  - ' + ListeCl√©s[i]);

          // On peut ouvrir chaque sous-cl√© pour plus d'infos
          if Reg.OpenKey('Software\' + ListeCl√©s[i], False) then
          begin
            if Reg.ValueExists('DisplayName') then
              WriteLn('      Nom : ' + Reg.ReadString('DisplayName'));
            if Reg.ValueExists('Version') then
              WriteLn('      Version : ' + Reg.ReadString('Version'));

            // Revenir √† la cl√© parent
            Reg.OpenKey('Software', False);
          end;
        end;

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    ListeCl√©s.Free;
    Reg.Free;
  end;
end;
```

## Op√©rations d'√©criture

### √âcrire une valeur simple

```pascal
procedure EcrireConfigurationSimple;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    // Ouvrir ou cr√©er la cl√© (true = cr√©er si elle n'existe pas)
    if Reg.OpenKey('Software\MonEntreprise\MonApplication', True) then
    begin
      try
        // √âcrire une valeur cha√Æne
        Reg.WriteString('NomUtilisateur', 'Jean Dupont');

        ShowMessage('Configuration sauvegard√©e');

      finally
        Reg.CloseKey;
      end;
    end
    else
      ShowMessage('Erreur : Impossible de cr√©er la cl√©');

  finally
    Reg.Free;
  end;
end;
```

### √âcrire diff√©rents types de donn√©es

```pascal
procedure EcrireTousLesTypes;
var
  Reg: TRegistry;
  DonneesBinaires: array[0..15] of Byte;
  i: Integer;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software\MonApp\Config', True) then
    begin
      try
        // √âcrire une cha√Æne simple (REG_SZ)
        Reg.WriteString('Theme', 'Dark');

        // √âcrire un entier 32 bits (REG_DWORD)
        Reg.WriteInteger('TaillePolice', 12);

        // √âcrire un bool√©en (stock√© comme DWORD)
        Reg.WriteBool('ModeNuit', True);

        // √âcrire une date/heure (stock√©e comme REG_BINARY)
        Reg.WriteDateTime('DerniereLancement', Now);

        // √âcrire une cha√Æne avec variables d'environnement (REG_EXPAND_SZ)
        Reg.WriteExpandString('CheminDonnees', '%APPDATA%\MonApp');

        // √âcrire des donn√©es binaires (REG_BINARY)
        for i := 0 to 15 do
          DonneesBinaires[i] := Random(256);
        Reg.WriteBinaryData('CleSecrete', DonneesBinaires, SizeOf(DonneesBinaires));

        // √âcrire un flottant (pas de type natif, on utilise Binary)
        var ValeurFloat: Single := 3.14159;
        Reg.WriteBinaryData('Pi', ValeurFloat, SizeOf(ValeurFloat));

        // √âcrire un Int64 (REG_QWORD sur Vista+, sinon REG_BINARY)
        var GrandNombre: Int64 := 9999999999;
        Reg.WriteBinaryData('GrandNombre', GrandNombre, SizeOf(GrandNombre));

        ShowMessage('Toutes les valeurs ont √©t√© √©crites');

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    Reg.Free;
  end;
end;
```

### Cr√©er une structure de configuration compl√®te

```pascal
procedure CreerConfigurationComplete;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    // Cr√©er la structure principale
    if Reg.OpenKey('Software\MonEntreprise', True) then
    begin
      Reg.WriteString('Company', 'Mon Entreprise SARL');
      Reg.CloseKey;
    end;

    // Cr√©er la cl√© de l'application
    if Reg.OpenKey('Software\MonEntreprise\MonApp', True) then
    begin
      Reg.WriteString('Version', '1.0.0');
      Reg.WriteString('InstallPath', ExtractFilePath(ParamStr(0)));
      Reg.WriteDateTime('InstallDate', Now);
      Reg.CloseKey;
    end;

    // Cr√©er les param√®tres utilisateur
    if Reg.OpenKey('Software\MonEntreprise\MonApp\UserSettings', True) then
    begin
      // Param√®tres par d√©faut
      Reg.WriteString('Language', 'FR');
      Reg.WriteString('Theme', 'Default');
      Reg.WriteInteger('FontSize', 10);
      Reg.WriteBool('AutoSave', True);
      Reg.WriteInteger('AutoSaveInterval', 5); // minutes
      Reg.WriteBool('ShowTips', True);
      Reg.CloseKey;
    end;

    // Cr√©er les param√®tres de fen√™tre
    if Reg.OpenKey('Software\MonEntreprise\MonApp\Window', True) then
    begin
      Reg.WriteInteger('Left', 100);
      Reg.WriteInteger('Top', 100);
      Reg.WriteInteger('Width', 800);
      Reg.WriteInteger('Height', 600);
      Reg.WriteBool('Maximized', False);
      Reg.CloseKey;
    end;

    // Cr√©er la liste des fichiers r√©cents
    if Reg.OpenKey('Software\MonEntreprise\MonApp\RecentFiles', True) then
    begin
      Reg.WriteString('File1', '');
      Reg.WriteString('File2', '');
      Reg.WriteString('File3', '');
      Reg.WriteString('File4', '');
      Reg.WriteString('File5', '');
      Reg.CloseKey;
    end;

    ShowMessage('Structure de configuration cr√©√©e avec succ√®s');

  finally
    Reg.Free;
  end;
end;
```

## Suppression de cl√©s et valeurs

### Supprimer une valeur

```pascal
procedure SupprimerValeur;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software\MonApp\Settings', False) then
    begin
      try
        // V√©rifier que la valeur existe avant de la supprimer
        if Reg.ValueExists('ValeurObsolete') then
        begin
          if Reg.DeleteValue('ValeurObsolete') then
            ShowMessage('Valeur supprim√©e')
          else
            ShowMessage('Erreur lors de la suppression');
        end
        else
          ShowMessage('La valeur n''existe pas');

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    Reg.Free;
  end;
end;
```

### Supprimer une cl√© et toutes ses sous-cl√©s

```pascal
procedure SupprimerCleComplete;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    // V√©rifier que la cl√© existe
    if Reg.KeyExists('Software\MonEntreprise\ApplicationObsolete') then
    begin
      if MessageDlg('√ätes-vous s√ªr de vouloir supprimer cette application du registre ?',
                    mtConfirmation, [mbYes, mbNo], 0) = mrYes then
      begin
        // DeleteKey supprime une cl√© et toutes ses sous-cl√©s
        if Reg.DeleteKey('Software\MonEntreprise\ApplicationObsolete') then
          ShowMessage('Application supprim√©e du registre')
        else
          ShowMessage('Erreur lors de la suppression');
      end;
    end
    else
      ShowMessage('La cl√© n''existe pas');

  finally
    Reg.Free;
  end;
end;
```

## Gestion des erreurs

### Gestion robuste avec try-except

```pascal
procedure LectureSecurisee;
var
  Reg: TRegistry;
  Valeur: string;
begin
  Reg := TRegistry.Create(KEY_READ);
  try
    try
      Reg.RootKey := HKEY_CURRENT_USER;

      if not Reg.OpenKey('Software\MonApp', False) then
      begin
        ShowMessage('L''application n''est pas encore configur√©e');
        Exit;
      end;

      try
        // V√©rifier l'existence avant de lire
        if Reg.ValueExists('Configuration') then
        begin
          Valeur := Reg.ReadString('Configuration');

          // Valider la valeur lue
          if Valeur = '' then
          begin
            ShowMessage('Configuration vide, utilisation des valeurs par d√©faut');
            Valeur := 'Default';
          end;
        end
        else
        begin
          ShowMessage('Configuration non trouv√©e, utilisation des valeurs par d√©faut');
          Valeur := 'Default';
        end;

      finally
        Reg.CloseKey;
      end;

    except
      on E: ERegistryException do
      begin
        ShowMessage('Erreur de registre : ' + E.Message);
        WriteLn('D√©tails : ' + E.ClassName);
      end;

      on E: Exception do
      begin
        ShowMessage('Erreur inattendue : ' + E.Message);
      end;
    end;

  finally
    Reg.Free;
  end;
end;
```

### V√©rification des permissions

```pascal
function VerifierPermissions: Boolean;
var
  Reg: TRegistry;
begin
  Result := False;

  Reg := TRegistry.Create;
  try
    // Test d'√©criture dans HKEY_LOCAL_MACHINE (n√©cessite admin)
    Reg.RootKey := HKEY_LOCAL_MACHINE;

    try
      // Essayer d'ouvrir en √©criture
      if Reg.OpenKey('SOFTWARE\MonEntreprise\Test', True) then
      begin
        try
          Reg.WriteString('TestPermission', 'OK');
          Reg.DeleteValue('TestPermission');
          Result := True;
        finally
          Reg.CloseKey;
          // Nettoyer la cl√© de test
          Reg.DeleteKey('SOFTWARE\MonEntreprise\Test');
        end;
      end;
    except
      // Pas de permissions administrateur
      Result := False;
    end;

  finally
    Reg.Free;
  end;

  if not Result then
    ShowMessage('Cette op√©ration n√©cessite les droits administrateur');
end;
```

## Cas pratiques complets

### Sauvegarder et restaurer la position d'une fen√™tre

```pascal
type
  TFormAvecRegistre = class(TForm)
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
    procedure SauvegarderPosition;
    procedure RestaurerPosition;
  end;

procedure TFormAvecRegistre.FormCreate(Sender: TObject);
begin
  RestaurerPosition;
end;

procedure TFormAvecRegistre.FormDestroy(Sender: TObject);
begin
  SauvegarderPosition;
end;

procedure TFormAvecRegistre.RestaurerPosition;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software\MonApp\Window', False) then
    begin
      try
        // Lire la position si elle existe
        if Reg.ValueExists('Left') then
          Self.Left := Reg.ReadInteger('Left');
        if Reg.ValueExists('Top') then
          Self.Top := Reg.ReadInteger('Top');
        if Reg.ValueExists('Width') then
          Self.Width := Reg.ReadInteger('Width');
        if Reg.ValueExists('Height') then
          Self.Height := Reg.ReadInteger('Height');

        // G√©rer l'√©tat maximis√©
        if Reg.ValueExists('Maximized') then
        begin
          if Reg.ReadBool('Maximized') then
            Self.WindowState := wsMaximized;
        end;

      finally
        Reg.CloseKey;
      end;
    end
    else
    begin
      // Premi√®re ex√©cution : centrer la fen√™tre
      Self.Position := poScreenCenter;
    end;

  finally
    Reg.Free;
  end;
end;

procedure TFormAvecRegistre.SauvegarderPosition;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey('Software\MonApp\Window', True) then
    begin
      try
        // Sauvegarder l'√©tat maximis√©
        Reg.WriteBool('Maximized', Self.WindowState = wsMaximized);

        // Si pas maximis√©, sauvegarder la position
        if Self.WindowState = wsNormal then
        begin
          Reg.WriteInteger('Left', Self.Left);
          Reg.WriteInteger('Top', Self.Top);
          Reg.WriteInteger('Width', Self.Width);
          Reg.WriteInteger('Height', Self.Height);
        end;

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    Reg.Free;
  end;
end;
```

### G√©rer une liste de fichiers r√©cents

```pascal
type
  TRecentFilesManager = class
  private
    FMaxFiles: Integer;
    FRegistryPath: string;
  public
    constructor Create(MaxFiles: Integer = 10);
    procedure AddFile(const FileName: string);
    procedure GetFiles(List: TStrings);
    procedure ClearAll;
  end;

constructor TRecentFilesManager.Create(MaxFiles: Integer);
begin
  FMaxFiles := MaxFiles;
  FRegistryPath := 'Software\MonApp\RecentFiles';
end;

procedure TRecentFilesManager.AddFile(const FileName: string);
var
  Reg: TRegistry;
  Files: TStringList;
  i: Integer;
begin
  Files := TStringList.Create;
  try
    // Obtenir la liste actuelle
    GetFiles(Files);

    // Retirer le fichier s'il existe d√©j√†
    i := Files.IndexOf(FileName);
    if i >= 0 then
      Files.Delete(i);

    // Ajouter en t√™te de liste
    Files.Insert(0, FileName);

    // Limiter √† MaxFiles
    while Files.Count > FMaxFiles do
      Files.Delete(Files.Count - 1);

    // Sauvegarder dans le registre
    Reg := TRegistry.Create;
    try
      Reg.RootKey := HKEY_CURRENT_USER;

      if Reg.OpenKey(FRegistryPath, True) then
      begin
        try
          // Effacer les anciennes entr√©es
          for i := 1 to FMaxFiles do
            if Reg.ValueExists('File' + IntToStr(i)) then
              Reg.DeleteValue('File' + IntToStr(i));

          // √âcrire les nouvelles
          for i := 0 to Files.Count - 1 do
            Reg.WriteString('File' + IntToStr(i + 1), Files[i]);

        finally
          Reg.CloseKey;
        end;
      end;

    finally
      Reg.Free;
    end;

  finally
    Files.Free;
  end;
end;

procedure TRecentFilesManager.GetFiles(List: TStrings);
var
  Reg: TRegistry;
  i: Integer;
  FileName: string;
begin
  List.Clear;

  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.OpenKey(FRegistryPath, False) then
    begin
      try
        for i := 1 to FMaxFiles do
        begin
          if Reg.ValueExists('File' + IntToStr(i)) then
          begin
            FileName := Reg.ReadString('File' + IntToStr(i));
            if (FileName <> '') and FileExists(FileName) then
              List.Add(FileName);
          end;
        end;

      finally
        Reg.CloseKey;
      end;
    end;

  finally
    Reg.Free;
  end;
end;

procedure TRecentFilesManager.ClearAll;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;

    if Reg.KeyExists(FRegistryPath) then
      Reg.DeleteKey(FRegistryPath);

  finally
    Reg.Free;
  end;
end;
```

## Bonnes pratiques

### 1. Toujours utiliser try-finally

```pascal
// MAUVAIS
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_CURRENT_USER;
  // Si une exception se produit ici, Reg ne sera jamais lib√©r√© !
  Reg.OpenKey('Software\MonApp', True);
  Reg.Free;
end;

// BON
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\MonApp', True);
  finally
    Reg.Free;  // Toujours ex√©cut√©, m√™me en cas d'exception
  end;
end;
```

### 2. V√©rifier l'existence avant de lire

```pascal
// MAUVAIS
Value := Reg.ReadString('MaValeur');  // Exception si n'existe pas

// BON
if Reg.ValueExists('MaValeur') then
  Value := Reg.ReadString('MaValeur')
else
  Value := 'Valeur par d√©faut';
```

### 3. Utiliser des chemins constants

```pascal
const
  REG_KEY_COMPANY = 'Software\MonEntreprise';
  REG_KEY_APP = 'Software\MonEntreprise\MonApp';
  REG_KEY_SETTINGS = 'Software\MonEntreprise\MonApp\Settings';

// Utilisation
if Reg.OpenKey(REG_KEY_SETTINGS, True) then
  // ...
```

### 4. Privil√©gier HKEY_CURRENT_USER

```pascal
// √âviter HKEY_LOCAL_MACHINE sauf si n√©cessaire
// (n√©cessite les droits administrateur)

// Pr√©f√©rer
Reg.RootKey := HKEY_CURRENT_USER;
Reg.OpenKey('Software\MonApp', True);

// √Ä
Reg.RootKey := HKEY_LOCAL_MACHINE;  // N√©cessite admin !
Reg.OpenKey('SOFTWARE\MonApp', True);
```

### 5. Nettoyer lors de la d√©sinstallation

```pascal
procedure DesinstallerApplication;
var
  Reg: TRegistry;
begin
  if MessageDlg('Supprimer tous les param√®tres ?',
                mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    Reg := TRegistry.Create;
    try
      Reg.RootKey := HKEY_CURRENT_USER;

      // Supprimer toute la branche de l'application
      if Reg.KeyExists('Software\MonEntreprise\MonApp') then
        Reg.DeleteKey('Software\MonEntreprise\MonApp');

      // Si c'√©tait la seule application de l'entreprise
      if Reg.OpenKey('Software\MonEntreprise', False) then
      begin
        var SubKeys := TStringList.Create;
        try
          Reg.GetKeyNames(SubKeys);
          Reg.CloseKey;

          if SubKeys.Count = 0 then
            Reg.DeleteKey('Software\MonEntreprise');
        finally
          SubKeys.Free;
        end;
      end;

    finally
      Reg.Free;
    end;
  end;
end;
```

## R√©sum√© des points cl√©s

1. **Toujours utiliser try-finally** pour garantir la lib√©ration de TRegistry
2. **V√©rifier l'existence** des cl√©s et valeurs avant de les lire
3. **Fermer les cl√©s** apr√®s utilisation avec CloseKey
4. **Utiliser HKEY_CURRENT_USER** quand possible (pas besoin d'admin)
5. **G√©rer les erreurs** avec try-except et ERegistryException
6. **Valider les donn√©es lues** (peuvent √™tre corrompues ou absentes)
7. **Utiliser des constantes** pour les chemins de registre
8. **Nettoyer √† la d√©sinstallation** pour ne pas polluer le registre

## Aide-m√©moire rapide

### Lecture
```pascal
Reg := TRegistry.Create(KEY_READ);
try
  Reg.RootKey := HKEY_CURRENT_USER;
  if Reg.OpenKey('Software\MonApp', False) then
  begin
    try
      if Reg.ValueExists('Setting') then
        Value := Reg.ReadString('Setting');
    finally
      Reg.CloseKey;
    end;
  end;
finally
  Reg.Free;
end;
```

### √âcriture
```pascal
Reg := TRegistry.Create;
try
  Reg.RootKey := HKEY_CURRENT_USER;
  if Reg.OpenKey('Software\MonApp', True) then
  begin
    try
      Reg.WriteString('Setting', 'Value');
    finally
      Reg.CloseKey;
    end;
  end;
finally
  Reg.Free;
end;
```

### Types de donn√©es et m√©thodes

| Type de donn√©e | M√©thode lecture | M√©thode √©criture | Type registre |
|----------------|-----------------|------------------|---------------|
| String | ReadString | WriteString | REG_SZ |
| Integer | ReadInteger | WriteInteger | REG_DWORD |
| Boolean | ReadBool | WriteBool | REG_DWORD |
| DateTime | ReadDateTime | WriteDateTime | REG_BINARY |
| Binary | ReadBinaryData | WriteBinaryData | REG_BINARY |
| ExpandString | ReadString | WriteExpandString | REG_EXPAND_SZ |

Avec ces bases solides, vous √™tes maintenant capable de lire et √©crire efficacement dans le Registre Windows avec FreePascal/Lazarus !

‚è≠Ô∏è [Surveillance des modifications](/06-specificites-windows/03.2-surveillance-modifications.md)
