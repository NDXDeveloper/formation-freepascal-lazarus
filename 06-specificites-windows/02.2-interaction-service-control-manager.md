🔝 Retour au [Sommaire](/SOMMAIRE.md)

# Interaction avec le Service Control Manager (SCM)

## Introduction : Qu'est-ce que le Service Control Manager ?

Le Service Control Manager (SCM) est le chef d'orchestre de tous les services Windows. C'est un composant système qui gère le cycle de vie de tous les services : il les démarre, les arrête, les surveille et gère leurs interactions. Comprendre comment votre service communique avec le SCM est essentiel pour créer des services robustes.

### Analogie simple

Imaginez le SCM comme le directeur d'un hôtel qui gère tout le personnel de service :
- Il **embauche** les employés (installe les services)
- Il leur dit **quand commencer** leur travail (démarre les services)
- Il **surveille** qu'ils travaillent correctement
- Il leur demande de **faire une pause** si nécessaire
- Il leur dit quand **arrêter** leur service
- Il peut les **licencier** (désinstaller les services)
- Il **communique** avec eux via des messages standardisés

## Architecture de la communication SCM-Service

### Le flux de communication

```
     Service Control Manager (SCM)
              |
              | Messages de contrôle
              | (Start, Stop, Pause, etc.)
              ↓
     ┌─────────────────────┐
     │   Votre Service      │
     │                      │
     │  ┌───────────────┐  │
     │  │ Handler SCM   │  │──→ Réponses d'état
     │  └───────────────┘  │    (Running, Stopped, etc.)
     │          ↓          │
     │  ┌───────────────┐  │
     │  │ Logique métier│  │
     │  └───────────────┘  │
     └─────────────────────┘
```

### Les acteurs principaux

1. **Le SCM (services.exe)** : Le processus système qui gère tous les services
2. **Votre service** : Votre application qui s'enregistre auprès du SCM
3. **Le handler de contrôle** : La fonction dans votre service qui reçoit les commandes du SCM
4. **La table de dispatch** : La structure qui lie votre service au SCM

## Les messages du SCM

Le SCM envoie différents types de messages à votre service. Voici les principaux :

### Messages de contrôle de base

```pascal
const
  // Messages principaux
  SERVICE_CONTROL_STOP           = $00000001;  // Arrêter le service
  SERVICE_CONTROL_PAUSE          = $00000002;  // Mettre en pause
  SERVICE_CONTROL_CONTINUE       = $00000003;  // Reprendre après pause
  SERVICE_CONTROL_INTERROGATE    = $00000004;  // Demander l'état actuel
  SERVICE_CONTROL_SHUTDOWN       = $00000005;  // Windows s'arrête

  // Messages étendus
  SERVICE_CONTROL_PARAMCHANGE    = $00000006;  // Paramètres changés
  SERVICE_CONTROL_NETBINDADD     = $00000007;  // Binding réseau ajouté
  SERVICE_CONTROL_NETBINDREMOVE  = $00000008;  // Binding réseau retiré
  SERVICE_CONTROL_NETBINDENABLE  = $00000009;  // Binding réseau activé
  SERVICE_CONTROL_NETBINDDISABLE = $0000000A;  // Binding réseau désactivé
```

### Messages de gestion d'alimentation

```pascal
const
  SERVICE_CONTROL_POWEREVENT     = $0000000D;  // Événement d'alimentation

  // Sous-types d'événements d'alimentation
  PBT_APMSUSPEND                = $0004;  // Système entre en veille
  PBT_APMRESUMESUSPEND          = $0007;  // Système sort de veille
  PBT_APMBATTERYLOW             = $0009;  // Batterie faible
  PBT_APMPOWERSTATUSCHANGE      = $000A;  // Changement alimentation AC/Batterie
```

### Messages de session utilisateur

```pascal
const
  SERVICE_CONTROL_SESSIONCHANGE  = $0000000E;  // Changement de session

  // Types de changements de session
  WTS_SESSION_LOGON     = $05;  // Un utilisateur se connecte
  WTS_SESSION_LOGOFF    = $06;  // Un utilisateur se déconnecte
  WTS_SESSION_LOCK      = $07;  // Session verrouillée
  WTS_SESSION_UNLOCK    = $08;  // Session déverrouillée
```

## Implémentation de base avec FreePascal

### Structure minimale d'interaction

```pascal
unit ServiceSCMHandler;

{$mode objfpc}{$H+}

interface

uses
  Windows, Classes, SysUtils;

type
  TServiceController = class
  private
    FServiceStatus: SERVICE_STATUS;
    FStatusHandle: SERVICE_STATUS_HANDLE;
    FServiceName: string;

    procedure UpdateServiceStatus(State: DWORD);
    function RegisterWithSCM: Boolean;

  public
    constructor Create(const ServiceName: string);
    destructor Destroy; override;

    procedure ReportStatus(CurrentState, ExitCode, WaitHint: DWORD);
    procedure HandleControlMessage(ControlCode: DWORD);
  end;

implementation

constructor TServiceController.Create(const ServiceName: string);
begin
  inherited Create;
  FServiceName := ServiceName;

  // Initialiser la structure de statut
  FillChar(FServiceStatus, SizeOf(FServiceStatus), 0);
  FServiceStatus.dwServiceType := SERVICE_WIN32_OWN_PROCESS;
  FServiceStatus.dwCurrentState := SERVICE_START_PENDING;
  FServiceStatus.dwControlsAccepted := SERVICE_ACCEPT_STOP or
                                       SERVICE_ACCEPT_PAUSE_CONTINUE;

  RegisterWithSCM;
end;

function TServiceController.RegisterWithSCM: Boolean;
begin
  // Enregistrer le handler auprès du SCM
  FStatusHandle := RegisterServiceCtrlHandler(
    PChar(FServiceName),
    @ServiceControlHandler
  );

  Result := FStatusHandle <> 0;

  if Result then
    WriteLn('Service enregistré avec succès auprès du SCM')
  else
    WriteLn('Erreur lors de l''enregistrement : ', GetLastError);
end;

procedure TServiceController.ReportStatus(CurrentState, ExitCode, WaitHint: DWORD);
begin
  FServiceStatus.dwCurrentState := CurrentState;
  FServiceStatus.dwWin32ExitCode := ExitCode;
  FServiceStatus.dwWaitHint := WaitHint;

  // Incrémenter le checkpoint pour montrer la progression
  if CurrentState = SERVICE_START_PENDING then
    Inc(FServiceStatus.dwCheckPoint)
  else
    FServiceStatus.dwCheckPoint := 0;

  // Envoyer le statut au SCM
  if not SetServiceStatus(FStatusHandle, @FServiceStatus) then
    WriteLn('Erreur lors de la mise à jour du statut : ', GetLastError);
end;

procedure TServiceController.HandleControlMessage(ControlCode: DWORD);
begin
  case ControlCode of
    SERVICE_CONTROL_STOP:
      begin
        WriteLn('SCM demande l''arrêt du service');
        ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 3000);
        // Effectuer l'arrêt
        // ...
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_PAUSE:
      begin
        WriteLn('SCM demande la pause du service');
        ReportStatus(SERVICE_PAUSE_PENDING, NO_ERROR, 1000);
        // Effectuer la pause
        // ...
        ReportStatus(SERVICE_PAUSED, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_CONTINUE:
      begin
        WriteLn('SCM demande la reprise du service');
        ReportStatus(SERVICE_CONTINUE_PENDING, NO_ERROR, 1000);
        // Effectuer la reprise
        // ...
        ReportStatus(SERVICE_RUNNING, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_INTERROGATE:
      begin
        // Le SCM demande juste l'état actuel
        ReportStatus(FServiceStatus.dwCurrentState, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_SHUTDOWN:
      begin
        WriteLn('Windows s''arrête - arrêt rapide du service');
        // Arrêt d'urgence - sauvegarder rapidement l'état
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;
  end;
end;
```

## États du service et transitions

### Les états possibles

Un service peut être dans l'un de ces états :

```pascal
const
  SERVICE_STOPPED          = $00000001;  // Arrêté
  SERVICE_START_PENDING    = $00000002;  // Démarrage en cours
  SERVICE_STOP_PENDING     = $00000003;  // Arrêt en cours
  SERVICE_RUNNING          = $00000004;  // En cours d'exécution
  SERVICE_CONTINUE_PENDING = $00000005;  // Reprise en cours
  SERVICE_PAUSE_PENDING    = $00000006;  // Pause en cours
  SERVICE_PAUSED           = $00000007;  // En pause
```

### Diagramme des transitions d'état

```
                    ┌─────────────┐
                    │   STOPPED   │
                    └──────┬──────┘
                           │ Start
                           ↓
                    ┌──────────────────┐
                    │ START_PENDING    │
                    └──────┬───────────┘
                           │
                           ↓
        Pause      ┌──────────────┐      Stop
    ┌──────────────┤   RUNNING    ├──────────────┐
    ↓              └──────────────┘              ↓
┌────────────────┐                      ┌──────────────┐
│ PAUSE_PENDING  │                      │ STOP_PENDING │
└────────┬───────┘                      └──────┬───────┘
         ↓                                      ↓
    ┌─────────┐         Continue          ┌─────────┐
    │ PAUSED  │─────────────────→         │ STOPPED │
    └─────────┘    CONTINUE_PENDING       └─────────┘
```

### Gestion correcte des transitions

```pascal
type
  TServiceStateManager = class
  private
    FCurrentState: DWORD;
    FStatusHandle: SERVICE_STATUS_HANDLE;
    FLogger: TLogger;
    FCriticalSection: TCriticalSection;

    procedure SetState(NewState: DWORD);
    function ValidateTransition(FromState, ToState: DWORD): Boolean;

  public
    constructor Create(StatusHandle: SERVICE_STATUS_HANDLE);
    destructor Destroy; override;

    procedure TransitionTo(NewState: DWORD);
    property CurrentState: DWORD read FCurrentState;
  end;

implementation

procedure TServiceStateManager.TransitionTo(NewState: DWORD);
begin
  FCriticalSection.Enter;
  try
    // Vérifier que la transition est valide
    if not ValidateTransition(FCurrentState, NewState) then
    begin
      FLogger.LogError(Format('Transition invalide : %s -> %s',
        [StateToString(FCurrentState), StateToString(NewState)]));
      Exit;
    end;

    FLogger.Log(Format('Transition d''état : %s -> %s',
      [StateToString(FCurrentState), StateToString(NewState)]));

    // Effectuer la transition
    SetState(NewState);

    // Notifier le SCM
    ReportStatusToSCM(NewState);

  finally
    FCriticalSection.Leave;
  end;
end;

function TServiceStateManager.ValidateTransition(FromState, ToState: DWORD): Boolean;
begin
  Result := False;

  case FromState of
    SERVICE_STOPPED:
      Result := (ToState = SERVICE_START_PENDING);

    SERVICE_START_PENDING:
      Result := (ToState in [SERVICE_RUNNING, SERVICE_STOPPED]);

    SERVICE_RUNNING:
      Result := (ToState in [SERVICE_PAUSE_PENDING, SERVICE_STOP_PENDING]);

    SERVICE_PAUSE_PENDING:
      Result := (ToState in [SERVICE_PAUSED, SERVICE_RUNNING]);

    SERVICE_PAUSED:
      Result := (ToState in [SERVICE_CONTINUE_PENDING, SERVICE_STOP_PENDING]);

    SERVICE_CONTINUE_PENDING:
      Result := (ToState in [SERVICE_RUNNING, SERVICE_PAUSED]);

    SERVICE_STOP_PENDING:
      Result := (ToState = SERVICE_STOPPED);
  end;
end;
```

## Communication avancée avec le SCM

### Envoi d'informations détaillées

```pascal
type
  TExtendedServiceStatus = class
  private
    FServiceStatus: SERVICE_STATUS_EX;
    FStatusHandle: SERVICE_STATUS_HANDLE;

  public
    procedure ReportProgress(PercentComplete: Integer; Message: string);
    procedure ReportCheckpoint(CheckPoint: DWORD; WaitHint: DWORD);
    procedure ReportError(ErrorCode: DWORD; ErrorMessage: string);
  end;

implementation

procedure TExtendedServiceStatus.ReportProgress(PercentComplete: Integer;
                                                Message: string);
var
  EventLog: THandle;
  Messages: array[0..1] of PChar;
begin
  // Mettre à jour le checkpoint pour montrer la progression
  FServiceStatus.dwCheckPoint := PercentComplete;
  FServiceStatus.dwWaitHint := 3000; // 3 secondes avant le prochain update

  SetServiceStatus(FStatusHandle, @FServiceStatus.ServiceStatus);

  // Logger dans l'Event Log Windows
  EventLog := RegisterEventSource(nil, PChar(FServiceName));
  if EventLog <> 0 then
  begin
    Messages[0] := PChar(Format('Progression : %d%%', [PercentComplete]));
    Messages[1] := PChar(Message);

    ReportEvent(EventLog,
                EVENTLOG_INFORMATION_TYPE,
                0,     // Category
                1000,  // Event ID
                nil,   // User SID
                2,     // Number of strings
                0,     // Data size
                @Messages,
                nil);  // Raw data

    DeregisterEventSource(EventLog);
  end;
end;

procedure TExtendedServiceStatus.ReportCheckpoint(CheckPoint: DWORD;
                                                  WaitHint: DWORD);
begin
  // Le checkpoint indique la progression pendant START_PENDING ou STOP_PENDING
  FServiceStatus.dwCheckPoint := CheckPoint;
  FServiceStatus.dwWaitHint := WaitHint;

  if not SetServiceStatus(FStatusHandle, @FServiceStatus.ServiceStatus) then
  begin
    // Erreur critique - le SCM pourrait tuer notre service
    RaiseLastOSError;
  end;
end;
```

### Gestion des messages personnalisés

Windows permet d'envoyer des messages personnalisés aux services (codes 128-255) :

```pascal
const
  // Messages personnalisés (128-255)
  SERVICE_CONTROL_CUSTOM_RELOAD_CONFIG = 128;
  SERVICE_CONTROL_CUSTOM_DUMP_STATE    = 129;
  SERVICE_CONTROL_CUSTOM_CLEAR_CACHE   = 130;

type
  TCustomMessageHandler = class
  private
    FHandlers: TDictionary<DWORD, TServiceControlHandler>;

  public
    constructor Create;
    destructor Destroy; override;

    procedure RegisterHandler(ControlCode: DWORD;
                            Handler: TServiceControlHandler);
    procedure ProcessMessage(ControlCode: DWORD);
  end;

implementation

procedure TCustomMessageHandler.RegisterHandler(ControlCode: DWORD;
                                               Handler: TServiceControlHandler);
begin
  if (ControlCode >= 128) and (ControlCode <= 255) then
    FHandlers.Add(ControlCode, Handler)
  else
    raise Exception.Create('Code de contrôle invalide (doit être 128-255)');
end;

procedure TCustomMessageHandler.ProcessMessage(ControlCode: DWORD);
var
  Handler: TServiceControlHandler;
begin
  if FHandlers.TryGetValue(ControlCode, Handler) then
  begin
    WriteLn(Format('Traitement du message personnalisé %d', [ControlCode]));
    Handler(ControlCode);
  end
  else if (ControlCode >= 128) and (ControlCode <= 255) then
  begin
    WriteLn(Format('Message personnalisé non géré : %d', [ControlCode]));
  end;
end;

// Utilisation
procedure InitializeCustomHandlers;
var
  CustomHandler: TCustomMessageHandler;
begin
  CustomHandler := TCustomMessageHandler.Create;

  // Enregistrer un handler pour recharger la configuration
  CustomHandler.RegisterHandler(SERVICE_CONTROL_CUSTOM_RELOAD_CONFIG,
    procedure(ControlCode: DWORD)
    begin
      WriteLn('Rechargement de la configuration...');
      ReloadConfiguration;
      WriteLn('Configuration rechargée');
    end
  );

  // Enregistrer un handler pour vider le cache
  CustomHandler.RegisterHandler(SERVICE_CONTROL_CUSTOM_CLEAR_CACHE,
    procedure(ControlCode: DWORD)
    begin
      WriteLn('Vidage du cache...');
      ClearAllCaches;
      WriteLn('Cache vidé');
    end
  );
end;
```

### Envoi de commandes personnalisées au service

```pascal
program SendCustomCommand;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils;

procedure SendControlToService(const ServiceName: string; ControlCode: DWORD);
var
  SCManager, Service: SC_HANDLE;
  ServiceStatus: SERVICE_STATUS;
begin
  // Ouvrir le gestionnaire de services
  SCManager := OpenSCManager(nil, nil, SC_MANAGER_CONNECT);
  if SCManager = 0 then
  begin
    WriteLn('Erreur : Impossible d''ouvrir le SCM');
    Exit;
  end;

  try
    // Ouvrir le service
    Service := OpenService(SCManager, PChar(ServiceName),
                          SERVICE_USER_DEFINED_CONTROL);
    if Service = 0 then
    begin
      WriteLn('Erreur : Service non trouvé');
      Exit;
    end;

    try
      // Envoyer la commande
      if ControlService(Service, ControlCode, ServiceStatus) then
      begin
        WriteLn(Format('Commande %d envoyée avec succès', [ControlCode]));
        WriteLn(Format('État actuel du service : %d',
                      [ServiceStatus.dwCurrentState]));
      end
      else
        WriteLn('Erreur lors de l''envoi de la commande : ', GetLastError);

    finally
      CloseServiceHandle(Service);
    end;

  finally
    CloseServiceHandle(SCManager);
  end;
end;

begin
  if ParamCount < 2 then
  begin
    WriteLn('Usage : SendCustomCommand <ServiceName> <ControlCode>');
    WriteLn('Exemple : SendCustomCommand MonService 128');
    Exit;
  end;

  SendControlToService(ParamStr(1), StrToInt(ParamStr(2)));
end.
```

## Gestion des dépendances de services

### Déclaration des dépendances

```pascal
type
  TServiceDependencyManager = class
  private
    FServiceName: string;
    FDependencies: TStringList;

  public
    constructor Create(const ServiceName: string);
    destructor Destroy; override;

    procedure AddDependency(const DependencyName: string);
    function CheckDependencies: Boolean;
    function WaitForDependencies(TimeoutSeconds: Integer): Boolean;
  end;

implementation

function TServiceDependencyManager.CheckDependencies: Boolean;
var
  i: Integer;
  SCManager, Service: SC_HANDLE;
  ServiceStatus: SERVICE_STATUS;
begin
  Result := True;

  SCManager := OpenSCManager(nil, nil, SC_MANAGER_ENUMERATE_SERVICE);
  if SCManager = 0 then
    Exit(False);

  try
    for i := 0 to FDependencies.Count - 1 do
    begin
      Service := OpenService(SCManager, PChar(FDependencies[i]),
                           SERVICE_QUERY_STATUS);
      if Service = 0 then
      begin
        WriteLn(Format('Service dépendant non trouvé : %s',
                      [FDependencies[i]]));
        Result := False;
        Continue;
      end;

      try
        if QueryServiceStatus(Service, ServiceStatus) then
        begin
          if ServiceStatus.dwCurrentState <> SERVICE_RUNNING then
          begin
            WriteLn(Format('Service dépendant pas démarré : %s (état=%d)',
                          [FDependencies[i], ServiceStatus.dwCurrentState]));
            Result := False;
          end;
        end;
      finally
        CloseServiceHandle(Service);
      end;
    end;
  finally
    CloseServiceHandle(SCManager);
  end;
end;

function TServiceDependencyManager.WaitForDependencies(TimeoutSeconds: Integer): Boolean;
var
  StartTime: TDateTime;
  ElapsedSeconds: Integer;
begin
  StartTime := Now;

  WriteLn('Attente des services dépendants...');

  repeat
    if CheckDependencies then
    begin
      WriteLn('Tous les services dépendants sont démarrés');
      Exit(True);
    end;

    Sleep(1000); // Attendre 1 seconde

    ElapsedSeconds := SecondsBetween(Now, StartTime);

    // Informer le SCM qu'on est toujours en démarrage
    ReportCheckpoint(ElapsedSeconds, 3000);

  until ElapsedSeconds >= TimeoutSeconds;

  WriteLn('Timeout : tous les services dépendants ne sont pas démarrés');
  Result := False;
end;
```

## Gestion des événements système

### Réaction aux changements de session

```pascal
type
  TSessionChangeHandler = class
  private
    FLogger: TLogger;
    FActiveUsers: Integer;

    procedure HandleSessionChange(EventType: DWORD; SessionId: DWORD);

  public
    constructor Create(Logger: TLogger);
    procedure ProcessSessionChangeMessage(EventType, SessionId: DWORD);
  end;

implementation

procedure TSessionChangeHandler.ProcessSessionChangeMessage(EventType,
                                                           SessionId: DWORD);
begin
  case EventType of
    WTS_SESSION_LOGON:
      begin
        Inc(FActiveUsers);
        FLogger.Log(Format('Utilisateur connecté (Session %d). Total actifs : %d',
                          [SessionId, FActiveUsers]));

        // Adapter le comportement du service
        if FActiveUsers = 1 then
        begin
          // Premier utilisateur connecté
          FLogger.Log('Premier utilisateur - activation des fonctionnalités interactives');
          EnableInteractiveFeatures;
        end;
      end;

    WTS_SESSION_LOGOFF:
      begin
        Dec(FActiveUsers);
        FLogger.Log(Format('Utilisateur déconnecté (Session %d). Total actifs : %d',
                          [SessionId, FActiveUsers]));

        if FActiveUsers = 0 then
        begin
          // Plus aucun utilisateur
          FLogger.Log('Aucun utilisateur - mode maintenance');
          EnterMaintenanceMode;
        end;
      end;

    WTS_SESSION_LOCK:
      begin
        FLogger.Log(Format('Session %d verrouillée', [SessionId]));
        // Peut-être suspendre certaines opérations sensibles
      end;

    WTS_SESSION_UNLOCK:
      begin
        FLogger.Log(Format('Session %d déverrouillée', [SessionId]));
        // Reprendre les opérations
      end;

    WTS_REMOTE_CONNECT:
      begin
        FLogger.Log(Format('Connexion Bureau à distance (Session %d)', [SessionId]));
        // Adapter pour connexion distante (performances, sécurité)
      end;
  end;
end;
```

### Gestion des événements d'alimentation

```pascal
type
  TPowerEventHandler = class
  private
    FLogger: TLogger;
    FOnBattery: Boolean;
    FSuspending: Boolean;

    procedure SaveStateBeforeSuspend;
    procedure RestoreStateAfterResume;

  public
    procedure HandlePowerEvent(EventType: DWORD; EventData: DWORD);
  end;

implementation

procedure TPowerEventHandler.HandlePowerEvent(EventType: DWORD; EventData: DWORD);
begin
  case EventType of
    PBT_APMSUSPEND:
      begin
        FLogger.Log('Système entre en veille - sauvegarde de l''état');
        FSuspending := True;

        // Sauvegarder l'état critique
        SaveStateBeforeSuspend;

        // Fermer les connexions réseau
        CloseNetworkConnections;

        // Libérer les ressources non essentielles
        ReleaseNonEssentialResources;
      end;

    PBT_APMRESUMESUSPEND:
      begin
        FLogger.Log('Système sort de veille - restauration');
        FSuspending := False;

        // Restaurer l'état
        RestoreStateAfterResume;

        // Reconnecter au réseau
        ReestablishNetworkConnections;

        // Vérifier l'intégrité
        PerformIntegrityCheck;
      end;

    PBT_APMBATTERYLOW:
      begin
        FLogger.LogWarning('Batterie faible détectée');
        FOnBattery := True;

        // Passer en mode économie d'énergie
        EnterPowerSavingMode;

        // Réduire la fréquence des opérations
        ReduceOperationFrequency;
      end;

    PBT_APMPOWERSTATUSCHANGE:
      begin
        // Vérifier si on est sur secteur ou batterie
        var PowerStatus: SYSTEM_POWER_STATUS;
        if GetSystemPowerStatus(PowerStatus) then
        begin
          FOnBattery := PowerStatus.ACLineStatus = 0;

          if FOnBattery then
            FLogger.Log('Passage sur batterie')
          else
          begin
            FLogger.Log('Passage sur secteur');
            // Reprendre les opérations normales
            ResumeNormalOperations;
          end;
        end;
      end;
  end;
end;
```

## Optimisation de la communication SCM

### Réponse rapide aux commandes

```pascal
type
  TOptimizedSCMHandler = class
  private
    FCommandQueue: TThreadSafeQueue<DWORD>;
    FWorkerThread: TThread;
    FQuickResponse: Boolean;

    procedure ProcessCommandAsync(Command: DWORD);

  public
    constructor Create;
    destructor Destroy; override;

    procedure HandleSCMCommand(Command: DWORD);
  end;

implementation

procedure TOptimizedSCMHandler.HandleSCMCommand(Command: DWORD);
begin
  // Répondre immédiatement au SCM pour éviter les timeouts
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Répondre immédiatement que l'arrêt est en cours
        ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 5000);

        // Traiter l'arrêt de manière asynchrone
        FCommandQueue.Enqueue(Command);
      end;

    SERVICE_CONTROL_PAUSE:
      begin
        ReportStatus(SERVICE_PAUSE_PENDING, NO_ERROR, 2000);
        FCommandQueue.Enqueue(Command);
      end;

    SERVICE_CONTROL_INTERROGATE:
      begin
        // Réponse immédiate requise
        ReportCurrentStatus;
      end;

    else
      // Autres commandes traitées de manière asynchrone
      FCommandQueue.Enqueue(Command);
  end;
end;

procedure TOptimizedSCMHandler.ProcessCommandAsync(Command: DWORD);
begin
  // Traitement réel de la commande (peut prendre du temps)
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Arrêt propre du service
        StopAllOperations;
        SaveState;
        CloseAllConnections;

        // Informer le SCM que l'arrêt est terminé
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_PAUSE:
      begin
        // Mise en pause
        PauseAllOperations;
        ReportStatus(SERVICE_PAUSED, NO_ERROR, 0);
      end;
  end;
end;
```

## Débogage de l'interaction SCM

### Logger tous les messages SCM

```pascal
type
  TSCMDebugger = class
  private
    FLogFile: TextFile;
    FEnabled: Boolean;

    function ControlCodeToString(Code: DWORD): string;
    function StateToString(State: DWORD): string;

  public
    constructor Create(const LogFileName: string);
    destructor Destroy; override;

    procedure LogSCMMessage(ControlCode: DWORD);
    procedure LogStatusChange(OldState, NewState: DWORD);
    procedure LogError(const Operation: string; ErrorCode: DWORD);
  end;

implementation

function TSCMDebugger.ControlCodeToString(Code: DWORD): string;
begin
  case Code of
    SERVICE_CONTROL_STOP:           Result := 'STOP';
    SERVICE_CONTROL_PAUSE:          Result := 'PAUSE';
    SERVICE_CONTROL_CONTINUE:       Result := 'CONTINUE';
    SERVICE_CONTROL_INTERROGATE:    Result := 'INTERROGATE';
    SERVICE_CONTROL_SHUTDOWN:       Result := 'SHUTDOWN';
    SERVICE_CONTROL_PARAMCHANGE:    Result := 'PARAMCHANGE';
    SERVICE_CONTROL_NETBINDADD:     Result := 'NETBINDADD';
    SERVICE_CONTROL_NETBINDREMOVE:  Result := 'NETBINDREMOVE';
    SERVICE_CONTROL_NETBINDENABLE:  Result := 'NETBINDENABLE';
    SERVICE_CONTROL_NETBINDDISABLE: Result := 'NETBINDDISABLE';
    SERVICE_CONTROL_DEVICEEVENT:    Result := 'DEVICEEVENT';
    SERVICE_CONTROL_HARDWAREPROFILECHANGE: Result := 'HARDWAREPROFILECHANGE';
    SERVICE_CONTROL_POWEREVENT:     Result := 'POWEREVENT';
    SERVICE_CONTROL_SESSIONCHANGE:  Result := 'SESSIONCHANGE';
    SERVICE_CONTROL_PRESHUTDOWN:    Result := 'PRESHUTDOWN';
    SERVICE_CONTROL_TIMECHANGE:     Result := 'TIMECHANGE';
    128..255: Result := Format('CUSTOM_%d', [Code]);
  else
    Result := Format('UNKNOWN_%d', [Code]);
  end;
end;

function TSCMDebugger.StateToString(State: DWORD): string;
begin
  case State of
    SERVICE_STOPPED:          Result := 'STOPPED';
    SERVICE_START_PENDING:    Result := 'START_PENDING';
    SERVICE_STOP_PENDING:     Result := 'STOP_PENDING';
    SERVICE_RUNNING:          Result := 'RUNNING';
    SERVICE_CONTINUE_PENDING: Result := 'CONTINUE_PENDING';
    SERVICE_PAUSE_PENDING:    Result := 'PAUSE_PENDING';
    SERVICE_PAUSED:           Result := 'PAUSED';
  else
    Result := Format('UNKNOWN_%d', [State]);
  end;
end;

constructor TSCMDebugger.Create(const LogFileName: string);
begin
  inherited Create;
  AssignFile(FLogFile, LogFileName);

  if FileExists(LogFileName) then
    Append(FLogFile)
  else
    Rewrite(FLogFile);

  FEnabled := True;

  WriteLn(FLogFile, '=== SCM Debug Log Started: ' +
                    FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' ===');
  Flush(FLogFile);
end;

destructor TSCMDebugger.Destroy;
begin
  if FEnabled then
  begin
    WriteLn(FLogFile, '=== SCM Debug Log Ended: ' +
                      FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' ===');
    CloseFile(FLogFile);
  end;
  inherited;
end;

procedure TSCMDebugger.LogSCMMessage(ControlCode: DWORD);
var
  Timestamp: string;
  ThreadId: DWORD;
begin
  if not FEnabled then Exit;

  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);
  ThreadId := GetCurrentThreadId;

  WriteLn(FLogFile, Format('[%s] [Thread %d] SCM Message: %s (0x%x)',
    [Timestamp, ThreadId, ControlCodeToString(ControlCode), ControlCode]));

  // Si c'est un message avec données supplémentaires
  if ControlCode = SERVICE_CONTROL_POWEREVENT then
    WriteLn(FLogFile, '  -> Power event details needed')
  else if ControlCode = SERVICE_CONTROL_SESSIONCHANGE then
    WriteLn(FLogFile, '  -> Session change details needed');

  Flush(FLogFile);
end;

procedure TSCMDebugger.LogStatusChange(OldState, NewState: DWORD);
var
  Timestamp: string;
begin
  if not FEnabled then Exit;

  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);

  WriteLn(FLogFile, Format('[%s] Status Change: %s -> %s',
    [Timestamp, StateToString(OldState), StateToString(NewState)]));

  // Vérifier si la transition est valide
  if not IsValidTransition(OldState, NewState) then
    WriteLn(FLogFile, '  WARNING: This transition may be invalid!');

  Flush(FLogFile);
end;

procedure TSCMDebugger.LogError(const Operation: string; ErrorCode: DWORD);
var
  Timestamp: string;
  ErrorMessage: string;
begin
  if not FEnabled then Exit;

  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);
  ErrorMessage := SysErrorMessage(ErrorCode);

  WriteLn(FLogFile, Format('[%s] ERROR in %s: %d - %s',
    [Timestamp, Operation, ErrorCode, ErrorMessage]));

  // Ajouter des conseils de résolution pour les erreurs courantes
  case ErrorCode of
    ERROR_SERVICE_REQUEST_TIMEOUT:
      WriteLn(FLogFile, '  -> HINT: Service took too long to respond. ' +
                        'Consider using asynchronous processing.');
    ERROR_SERVICE_NO_THREAD:
      WriteLn(FLogFile, '  -> HINT: Cannot create thread. ' +
                        'Check system resources.');
    ERROR_SERVICE_DATABASE_LOCKED:
      WriteLn(FLogFile, '  -> HINT: Service database is locked. ' +
                        'Another installation may be in progress.');
  end;

  Flush(FLogFile);
end;
```

### Simulateur SCM pour tests

```pascal
program SCMSimulator;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils, Classes;

type
  TSCMSimulator = class
  private
    FServiceHandle: THandle;
    FServiceName: string;
    FCurrentState: DWORD;
    FLogger: TStringList;

    procedure SimulateStartSequence;
    procedure SimulateStopSequence;
    procedure SimulatePauseResumeSequence;
    procedure SimulateFailureScenarios;

  public
    constructor Create(const ServiceName: string);
    destructor Destroy; override;

    procedure RunSimulation;
    procedure SaveLog(const FileName: string);
  end;

implementation

constructor TSCMSimulator.Create(const ServiceName: string);
begin
  inherited Create;
  FServiceName := ServiceName;
  FLogger := TStringList.Create;
  FCurrentState := SERVICE_STOPPED;

  FLogger.Add('=== SCM Simulator Started ===');
  FLogger.Add('Service: ' + ServiceName);
  FLogger.Add('Time: ' + DateTimeToStr(Now));
  FLogger.Add('');
end;

destructor TSCMSimulator.Destroy;
begin
  FLogger.Free;
  inherited;
end;

procedure TSCMSimulator.SimulateStartSequence;
begin
  FLogger.Add('--- Simulating Normal Start Sequence ---');

  // 1. Envoi de la commande START
  FLogger.Add('SCM -> Service: START command');
  FCurrentState := SERVICE_START_PENDING;
  FLogger.Add('Service -> SCM: Status = START_PENDING');

  // 2. Simulation des checkpoints pendant le démarrage
  var i: Integer;
  for i := 1 to 5 do
  begin
    Sleep(500);
    FLogger.Add(Format('Service -> SCM: Checkpoint %d/5, WaitHint=3000ms', [i]));
  end;

  // 3. Service démarré
  FCurrentState := SERVICE_RUNNING;
  FLogger.Add('Service -> SCM: Status = RUNNING');
  FLogger.Add('Start sequence completed successfully');
  FLogger.Add('');
end;

procedure TSCMSimulator.SimulateStopSequence;
begin
  FLogger.Add('--- Simulating Normal Stop Sequence ---');

  // 1. Envoi de la commande STOP
  FLogger.Add('SCM -> Service: STOP command');
  FCurrentState := SERVICE_STOP_PENDING;
  FLogger.Add('Service -> SCM: Status = STOP_PENDING');

  // 2. Simulation de l'arrêt progressif
  FLogger.Add('Service: Saving state...');
  Sleep(1000);
  FLogger.Add('Service -> SCM: Checkpoint 1, WaitHint=5000ms');

  FLogger.Add('Service: Closing connections...');
  Sleep(1000);
  FLogger.Add('Service -> SCM: Checkpoint 2, WaitHint=3000ms');

  FLogger.Add('Service: Cleanup...');
  Sleep(500);

  // 3. Service arrêté
  FCurrentState := SERVICE_STOPPED;
  FLogger.Add('Service -> SCM: Status = STOPPED');
  FLogger.Add('Stop sequence completed successfully');
  FLogger.Add('');
end;

procedure TSCMSimulator.SimulatePauseResumeSequence;
begin
  FLogger.Add('--- Simulating Pause/Resume Sequence ---');

  // Pause
  FLogger.Add('SCM -> Service: PAUSE command');
  FCurrentState := SERVICE_PAUSE_PENDING;
  FLogger.Add('Service -> SCM: Status = PAUSE_PENDING');
  Sleep(1000);
  FCurrentState := SERVICE_PAUSED;
  FLogger.Add('Service -> SCM: Status = PAUSED');

  // Interrogate pendant la pause
  FLogger.Add('SCM -> Service: INTERROGATE command');
  FLogger.Add('Service -> SCM: Status = PAUSED (current status)');

  // Resume
  Sleep(2000);
  FLogger.Add('SCM -> Service: CONTINUE command');
  FCurrentState := SERVICE_CONTINUE_PENDING;
  FLogger.Add('Service -> SCM: Status = CONTINUE_PENDING');
  Sleep(1000);
  FCurrentState := SERVICE_RUNNING;
  FLogger.Add('Service -> SCM: Status = RUNNING');
  FLogger.Add('Pause/Resume sequence completed');
  FLogger.Add('');
end;

procedure TSCMSimulator.SimulateFailureScenarios;
begin
  FLogger.Add('--- Simulating Failure Scenarios ---');

  // Scénario 1 : Timeout au démarrage
  FLogger.Add('Scenario 1: Start timeout');
  FLogger.Add('SCM -> Service: START command');
  FLogger.Add('Service -> SCM: Status = START_PENDING');
  FLogger.Add('... 30 seconds pass without update ...');
  FLogger.Add('SCM: ERROR - Service did not start in time (Error 1053)');
  FLogger.Add('SCM: Killing service process');
  FLogger.Add('');

  // Scénario 2 : Service ne répond pas à STOP
  FLogger.Add('Scenario 2: Stop not responding');
  FLogger.Add('SCM -> Service: STOP command');
  FLogger.Add('Service -> SCM: Status = STOP_PENDING');
  FLogger.Add('... No further updates ...');
  FLogger.Add('SCM: WARNING - Service not responding to stop');
  FLogger.Add('SCM: Force terminating process after timeout');
  FLogger.Add('');

  // Scénario 3 : Transition invalide
  FLogger.Add('Scenario 3: Invalid state transition');
  FLogger.Add('Current state: PAUSED');
  FLogger.Add('Service attempts: Status = RUNNING (invalid!)');
  FLogger.Add('SCM: ERROR - Invalid state transition');
  FLogger.Add('SCM: Service state inconsistent');
  FLogger.Add('');
end;

procedure TSCMSimulator.RunSimulation;
begin
  FLogger.Add('Starting complete SCM interaction simulation...');
  FLogger.Add('');

  SimulateStartSequence;
  Sleep(2000);

  SimulatePauseResumeSequence;
  Sleep(2000);

  SimulateStopSequence;
  Sleep(1000);

  SimulateFailureScenarios;

  FLogger.Add('=== Simulation Complete ===');
end;

procedure TSCMSimulator.SaveLog(const FileName: string);
begin
  FLogger.SaveToFile(FileName);
  WriteLn('Simulation log saved to: ', FileName);
end;

// Programme principal
var
  Simulator: TSCMSimulator;
begin
  Simulator := TSCMSimulator.Create('TestService');
  try
    Simulator.RunSimulation;
    Simulator.SaveLog('scm_simulation.log');
  finally
    Simulator.Free;
  end;

  WriteLn('Press Enter to exit...');
  ReadLn;
end.
```

## Cas pratiques d'interaction SCM

### Cas 1 : Service avec démarrage long

```pascal
type
  TLongStartupService = class(TCustomDaemon)
  private
    FInitThread: TThread;
    FInitProgress: Integer;
    FStatusHandle: SERVICE_STATUS_HANDLE;

    procedure ReportInitProgress;

  public
    function Start: Boolean; override;
    function Stop: Boolean; override;
  end;

implementation

function TLongStartupService.Start: Boolean;
begin
  Result := True;

  // Informer le SCM que le démarrage va prendre du temps
  ReportStatus(SERVICE_START_PENDING, NO_ERROR, 30000); // 30 secondes

  // Créer un thread pour l'initialisation longue
  FInitThread := TThread.CreateAnonymousThread(
    procedure
    var
      i: Integer;
    begin
      try
        // Phase 1 : Chargement de la configuration
        FInitProgress := 10;
        ReportInitProgress;
        LoadComplexConfiguration;

        // Phase 2 : Connexion aux bases de données
        FInitProgress := 30;
        ReportInitProgress;
        ConnectToMultipleDatabases;

        // Phase 3 : Chargement du cache
        FInitProgress := 50;
        ReportInitProgress;
        LoadLargeCache;

        // Phase 4 : Initialisation des composants
        FInitProgress := 70;
        ReportInitProgress;
        InitializeComponents;

        // Phase 5 : Vérifications finales
        FInitProgress := 90;
        ReportInitProgress;
        PerformStartupChecks;

        // Démarrage terminé
        FInitProgress := 100;
        ReportStatus(SERVICE_RUNNING, NO_ERROR, 0);

      except
        on E: Exception do
        begin
          LogError('Startup failed: ' + E.Message);
          ReportStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR, 0);
        end;
      end;
    end
  );

  FInitThread.Start;
end;

procedure TLongStartupService.ReportInitProgress;
var
  ServiceStatus: SERVICE_STATUS;
begin
  FillChar(ServiceStatus, SizeOf(ServiceStatus), 0);
  ServiceStatus.dwServiceType := SERVICE_WIN32_OWN_PROCESS;
  ServiceStatus.dwCurrentState := SERVICE_START_PENDING;
  ServiceStatus.dwControlsAccepted := 0; // Pas de contrôle pendant le démarrage
  ServiceStatus.dwWin32ExitCode := NO_ERROR;
  ServiceStatus.dwCheckPoint := FInitProgress;
  ServiceStatus.dwWaitHint := 5000; // 5 secondes avant le prochain update

  SetServiceStatus(FStatusHandle, @ServiceStatus);

  // Logger la progression
  EventLog(etInfo, Format('Startup progress: %d%%', [FInitProgress]));
end;
```

### Cas 2 : Service avec arrêt complexe

```pascal
type
  TComplexShutdownService = class(TCustomDaemon)
  private
    FShutdownRequested: Boolean;
    FActiveOperations: Integer;
    FShutdownTimeout: Integer;

    procedure WaitForOperationsToComplete;
    procedure ForceTerminateOperations;

  public
    function Stop: Boolean; override;
    procedure GracefulShutdown;
  end;

implementation

function TComplexShutdownService.Stop: Boolean;
var
  StartTime: TDateTime;
  Phase: Integer;
begin
  Result := True;
  FShutdownRequested := True;
  StartTime := Now;
  Phase := 0;

  // Informer le SCM que l'arrêt va prendre du temps
  ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 20000);

  try
    // Phase 1 : Arrêter l'acceptation de nouvelles requêtes
    Inc(Phase);
    ReportCheckpoint(Phase, 5000);
    StopAcceptingNewRequests;
    EventLog(etInfo, 'Phase 1: Stopped accepting new requests');

    // Phase 2 : Attendre la fin des opérations en cours
    Inc(Phase);
    ReportCheckpoint(Phase, 10000);
    WaitForOperationsToComplete;
    EventLog(etInfo, Format('Phase 2: %d operations completed',
                            [FActiveOperations]));

    // Phase 3 : Sauvegarder l'état
    Inc(Phase);
    ReportCheckpoint(Phase, 5000);
    SaveServiceState;
    EventLog(etInfo, 'Phase 3: State saved');

    // Phase 4 : Fermer les connexions
    Inc(Phase);
    ReportCheckpoint(Phase, 5000);
    CloseAllConnections;
    EventLog(etInfo, 'Phase 4: Connections closed');

    // Phase 5 : Nettoyage final
    Inc(Phase);
    ReportCheckpoint(Phase, 3000);
    PerformFinalCleanup;
    EventLog(etInfo, 'Phase 5: Cleanup completed');

    // Arrêt terminé
    ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);

    var ElapsedTime := SecondsBetween(Now, StartTime);
    EventLog(etInfo, Format('Service stopped gracefully in %d seconds',
                            [ElapsedTime]));

  except
    on E: Exception do
    begin
      EventLog(etError, 'Error during shutdown: ' + E.Message);

      // Forcer l'arrêt si l'arrêt gracieux échoue
      ForceTerminateOperations;

      ReportStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR, 0);
      Result := False;
    end;
  end;
end;

procedure TComplexShutdownService.WaitForOperationsToComplete;
var
  WaitStart: TDateTime;
  WaitTime: Integer;
begin
  WaitStart := Now;
  FShutdownTimeout := 15; // 15 secondes max

  while (FActiveOperations > 0) and
        (SecondsBetween(Now, WaitStart) < FShutdownTimeout) do
  begin
    Sleep(500);

    // Mettre à jour le SCM
    WaitTime := FShutdownTimeout - SecondsBetween(Now, WaitStart);
    ReportCheckpoint(2, WaitTime * 1000);

    EventLog(etInfo, Format('Waiting for %d operations (timeout in %d sec)',
                           [FActiveOperations, WaitTime]));
  end;

  if FActiveOperations > 0 then
  begin
    EventLog(etWarning, Format('%d operations still active after timeout',
                              [FActiveOperations]));
    ForceTerminateOperations;
  end;
end;
```

### Cas 3 : Service interactif avec le bureau

```pascal
type
  TInteractiveService = class(TCustomDaemon)
  private
    FCanInteractWithDesktop: Boolean;
    FSessionMonitor: TSessionMonitor;

    procedure CheckInteractiveCapability;
    procedure ShowUserNotification(const Message: string);

  public
    function Start: Boolean; override;
    procedure NotifyUser(SessionId: DWORD; const Message: string);
  end;

implementation

function TInteractiveService.Start: Boolean;
begin
  Result := inherited Start;

  // Vérifier si le service peut interagir avec le bureau
  CheckInteractiveCapability;

  if FCanInteractWithDesktop then
  begin
    EventLog(etInfo, 'Service has interactive capability');

    // Créer un moniteur de sessions
    FSessionMonitor := TSessionMonitor.Create;
    FSessionMonitor.OnSessionChange := HandleSessionChange;
  end
  else
  begin
    EventLog(etWarning, 'Service cannot interact with desktop - ' +
                        'running in isolated mode');
  end;
end;

procedure TInteractiveService.CheckInteractiveCapability;
var
  SCManager, Service: SC_HANDLE;
  ServiceConfig: LPQUERY_SERVICE_CONFIG;
  BytesNeeded: DWORD;
begin
  FCanInteractWithDesktop := False;

  SCManager := OpenSCManager(nil, nil, SC_MANAGER_CONNECT);
  if SCManager = 0 then Exit;

  try
    Service := OpenService(SCManager, PChar(ServiceName), SERVICE_QUERY_CONFIG);
    if Service = 0 then Exit;

    try
      // Obtenir la configuration du service
      QueryServiceConfig(Service, nil, 0, BytesNeeded);
      GetMem(ServiceConfig, BytesNeeded);
      try
        if QueryServiceConfig(Service, ServiceConfig, BytesNeeded, BytesNeeded) then
        begin
          // Vérifier le flag SERVICE_INTERACTIVE_PROCESS
          FCanInteractWithDesktop :=
            (ServiceConfig^.dwServiceType and SERVICE_INTERACTIVE_PROCESS) <> 0;
        end;
      finally
        FreeMem(ServiceConfig);
      end;
    finally
      CloseServiceHandle(Service);
    end;
  finally
    CloseServiceHandle(SCManager);
  end;
end;

procedure TInteractiveService.NotifyUser(SessionId: DWORD; const Message: string);
var
  Response: DWORD;
begin
  if not FCanInteractWithDesktop then
  begin
    EventLog(etWarning, 'Cannot show notification - not interactive');
    Exit;
  end;

  // Utiliser WTSSendMessage pour envoyer un message à une session
  WTSSendMessage(
    WTS_CURRENT_SERVER,
    SessionId,
    PChar('Service Notification'),
    Length('Service Notification') * SizeOf(Char),
    PChar(Message),
    Length(Message) * SizeOf(Char),
    MB_OK or MB_ICONINFORMATION,
    0, // Timeout (0 = pas de timeout)
    Response,
    False // Don't wait for response
  );

  EventLog(etInfo, Format('Notification sent to session %d: %s',
                          [SessionId, Message]));
end;
```

## Gestion avancée des privilèges

### Ajustement des privilèges du service

```pascal
type
  TServicePrivilegeManager = class
  private
    FRequiredPrivileges: TStringList;

    function EnablePrivilege(const PrivilegeName: string): Boolean;
    function CheckPrivilege(const PrivilegeName: string): Boolean;

  public
    constructor Create;
    destructor Destroy; override;

    procedure RequirePrivilege(const PrivilegeName: string);
    function ValidateAllPrivileges: Boolean;
    procedure AdjustServicePrivileges;
  end;

implementation

const
  // Privilèges Windows courants
  SE_BACKUP_NAME           = 'SeBackupPrivilege';
  SE_RESTORE_NAME          = 'SeRestorePrivilege';
  SE_SHUTDOWN_NAME         = 'SeShutdownPrivilege';
  SE_DEBUG_NAME            = 'SeDebugPrivilege';
  SE_SYSTEM_ENVIRONMENT_NAME = 'SeSystemEnvironmentPrivilege';
  SE_CHANGE_NOTIFY_NAME    = 'SeChangeNotifyPrivilege';
  SE_UNDOCK_NAME          = 'SeUndockPrivilege';
  SE_MANAGE_VOLUME_NAME   = 'SeManageVolumePrivilege';

procedure TServicePrivilegeManager.AdjustServicePrivileges;
var
  i: Integer;
  PrivName: string;
begin
  EventLog(etInfo, 'Adjusting service privileges...');

  for i := 0 to FRequiredPrivileges.Count - 1 do
  begin
    PrivName := FRequiredPrivileges[i];

    if EnablePrivilege(PrivName) then
      EventLog(etInfo, Format('Privilege enabled: %s', [PrivName]))
    else
      EventLog(etWarning, Format('Failed to enable privilege: %s', [PrivName]));
  end;
end;

function TServicePrivilegeManager.EnablePrivilege(const PrivilegeName: string): Boolean;
var
  Token: THandle;
  TokenPriv: TOKEN_PRIVILEGES;
  PrevTokenPriv: TOKEN_PRIVILEGES;
  ReturnLength: Cardinal;
begin
  Result := False;

  // Ouvrir le token du processus
  if not OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES or TOKEN_QUERY,
                          Token) then
    Exit;

  try
    // Rechercher le LUID du privilège
    if not LookupPrivilegeValue(nil, PChar(PrivilegeName),
                                TokenPriv.Privileges[0].Luid) then
      Exit;

    TokenPriv.PrivilegeCount := 1;
    TokenPriv.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;

    // Ajuster les privilèges
    Result := AdjustTokenPrivileges(Token, False, TokenPriv,
                                   SizeOf(PrevTokenPriv),
                                   PrevTokenPriv, ReturnLength);

    // Vérifier que l'ajustement a réussi
    Result := Result and (GetLastError() = ERROR_SUCCESS);

  finally
    CloseHandle(Token);
  end;
end;
```

## Bonnes pratiques pour l'interaction SCM

### 1. Toujours répondre rapidement

```pascal
// MAUVAIS - Risque de timeout
procedure HandleSCMCommand(Command: DWORD);
begin
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Traitement long sans feedback
        PerformLongShutdownProcess; // 45 secondes
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;
  end;
end;

// BON - Réponse immédiate avec updates
procedure HandleSCMCommand(Command: DWORD);
begin
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Informer immédiatement le SCM
        ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 10000);

        // Lancer l'arrêt en asynchrone
        TThread.CreateAnonymousThread(
          procedure
          begin
            PerformLongShutdownProcess;
            ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
          end
        ).Start;
      end;
  end;
end;
```

### 2. Gérer les checkpoints correctement

```pascal
procedure PerformLongOperation;
var
  TotalSteps: Integer;
  CurrentStep: Integer;
begin
  TotalSteps := 10;

  for CurrentStep := 1 to TotalSteps do
  begin
    // Faire une partie du travail
    ProcessStep(CurrentStep);

    // Informer le SCM de la progression
    ReportCheckpoint(CurrentStep, 5000); // 5 secondes pour le prochain

    // Important : Le checkpoint doit augmenter
    // sinon le SCM pensera que le service est bloqué
  end;
end;
```

### 3. Gérer proprement les arrêts d'urgence

```pascal
procedure HandleShutdown;
begin
  // Windows s'arrête - on a très peu de temps

  // 1. Sauvegarder seulement l'essentiel
  QuickSaveEssentialState;

  // 2. Pas de nettoyage complexe
  // Skip: CloseAllConnections, FreeAllResources, etc.

  // 3. Informer immédiatement le SCM
  ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);

  // Windows forcera la terminaison de toute façon
end;
```

### 4. Logger sans bloquer

```pascal
type
  TAsyncLogger = class
  private
    FLogQueue: TThreadedQueue<string>;
    FLogThread: TThread;

  public
    procedure LogSCMInteraction(const Message: string);
  end;

procedure TAsyncLogger.LogSCMInteraction(const Message: string);
begin
  // Ne jamais bloquer dans le handler SCM
  FLogQueue.PushItem(FormatDateTime('hh:nn:ss.zzz', Now) + ' ' + Message);

  // Le thread de log écrira quand il pourra
  // sans bloquer le traitement des messages SCM
end;
```

## Résumé : Points clés de l'interaction SCM

1. **Le SCM est impatient** : Répondez toujours rapidement (< 30 secondes)
2. **Les transitions d'état doivent être logiques** : Respectez le diagramme d'états
3. **Les checkpoints sont vitaux** : Augmentez-les pendant les opérations longues
4. **L'asynchrone est votre ami** : Ne bloquez jamais le thread du handler SCM
5. **Loggez tout** : Les problèmes SCM sont difficiles à déboguer sans logs
6. **Gérez les cas d'urgence** : SHUTDOWN nécessite une réponse immédiate
7. **Testez les scénarios d'échec** : Timeouts, crashes, arrêts forcés
8. **Respectez les privilèges** : Demandez seulement ce dont vous avez besoin

## Guide de référence rapide

### Codes de contrôle SCM essentiels

```pascal
// Messages de base (obligatoires à gérer)
SERVICE_CONTROL_STOP           = $00000001;  // DOIT être géré
SERVICE_CONTROL_INTERROGATE    = $00000004;  // DOIT être géré
SERVICE_CONTROL_SHUTDOWN       = $00000005;  // DOIT être géré si accepté

// Messages optionnels
SERVICE_CONTROL_PAUSE          = $00000002;  // Si SERVICE_ACCEPT_PAUSE_CONTINUE
SERVICE_CONTROL_CONTINUE       = $00000003;  // Si SERVICE_ACCEPT_PAUSE_CONTINUE
SERVICE_CONTROL_PARAMCHANGE    = $00000006;  // Si SERVICE_ACCEPT_PARAMCHANGE

// Messages système
SERVICE_CONTROL_POWEREVENT     = $0000000D;  // Si SERVICE_ACCEPT_POWEREVENT
SERVICE_CONTROL_SESSIONCHANGE  = $0000000E;  // Si SERVICE_ACCEPT_SESSIONCHANGE
SERVICE_CONTROL_PRESHUTDOWN    = $0000000F;  // Si SERVICE_ACCEPT_PRESHUTDOWN

// Messages personnalisés
// 128-255 : Disponibles pour votre usage
```

### États du service

```pascal
SERVICE_STOPPED          = $00000001;  // Initial et final
SERVICE_START_PENDING    = $00000002;  // Démarrage en cours
SERVICE_STOP_PENDING     = $00000003;  // Arrêt en cours
SERVICE_RUNNING          = $00000004;  // État normal de fonctionnement
SERVICE_CONTINUE_PENDING = $00000005;  // Reprise après pause
SERVICE_PAUSE_PENDING    = $00000006;  // Mise en pause
SERVICE_PAUSED           = $00000007;  // En pause
```

### Drapeaux d'acceptation de contrôle

```pascal
// À définir dans dwControlsAccepted
SERVICE_ACCEPT_STOP                  = $00000001;  // Toujours recommandé
SERVICE_ACCEPT_PAUSE_CONTINUE        = $00000002;  // Pour pause/reprise
SERVICE_ACCEPT_SHUTDOWN              = $00000004;  // Arrêt Windows
SERVICE_ACCEPT_PARAMCHANGE           = $00000008;  // Changement paramètres
SERVICE_ACCEPT_NETBINDCHANGE         = $00000010;  // Changements réseau
SERVICE_ACCEPT_HARDWAREPROFILECHANGE = $00000020;  // Profil matériel
SERVICE_ACCEPT_POWEREVENT            = $00000040;  // Événements alimentation
SERVICE_ACCEPT_SESSIONCHANGE         = $00000080;  // Sessions utilisateur
SERVICE_ACCEPT_PRESHUTDOWN           = $00000100;  // Pré-arrêt (Vista+)
SERVICE_ACCEPT_TIMECHANGE            = $00000200;  // Changement heure système
```

## Template complet d'interaction SCM

```pascal
unit ServiceSCMTemplate;

{$mode objfpc}{$H+}

interface

uses
  Windows, Classes, SysUtils, DaemonApp;

type
  { TServiceWithSCM }
  TServiceWithSCM = class(TCustomDaemon)
  private
    // SCM
    FStatusHandle: SERVICE_STATUS_HANDLE;
    FServiceStatus: SERVICE_STATUS;
    FServiceName: string;

    // État
    FShutdownRequested: Boolean;
    FPaused: Boolean;

    // Debug et logs
    FSCMDebugger: TSCMDebugger;

    // Threads
    FMainThread: TThread;
    FShutdownThread: TThread;

    // Méthodes SCM
    procedure RegisterWithSCM;
    procedure UpdateServiceStatus(NewState: DWORD; ExitCode: DWORD = NO_ERROR;
      WaitHint: DWORD = 0);
    procedure ReportCheckpoint(CheckPoint: DWORD; WaitHint: DWORD);

    // Handlers
    procedure HandleStart;
    procedure HandleStop;
    procedure HandlePause;
    procedure HandleContinue;
    procedure HandleShutdown;
    procedure HandleInterrogate;
    procedure HandleSessionChange(EventType, SessionId: DWORD);
    procedure HandlePowerEvent(EventType, EventData: DWORD);
    procedure HandleCustomCommand(Command: DWORD);

  protected
    function GetServiceControlHandler: TServiceControlHandler;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function Start: Boolean; override;
    function Stop: Boolean; override;
    function Pause: Boolean; override;
    function Continue: Boolean; override;
    function Execute: Boolean; override;

    procedure ServiceControlHandler(CtrlCode: DWORD); virtual;
  end;

implementation

{ TServiceWithSCM }

constructor TServiceWithSCM.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  FServiceName := 'MyServiceWithSCM';
  FShutdownRequested := False;
  FPaused := False;

  // Initialiser le debugger SCM
  FSCMDebugger := TSCMDebugger.Create(
    ExtractFilePath(ParamStr(0)) + 'scm_debug.log'
  );

  // Initialiser la structure de statut
  FillChar(FServiceStatus, SizeOf(FServiceStatus), 0);
  FServiceStatus.dwServiceType := SERVICE_WIN32_OWN_PROCESS;
  FServiceStatus.dwCurrentState := SERVICE_STOPPED;

  // Définir ce que le service accepte
  FServiceStatus.dwControlsAccepted :=
    SERVICE_ACCEPT_STOP or
    SERVICE_ACCEPT_PAUSE_CONTINUE or
    SERVICE_ACCEPT_SHUTDOWN or
    SERVICE_ACCEPT_SESSIONCHANGE or
    SERVICE_ACCEPT_POWEREVENT;
end;

destructor TServiceWithSCM.Destroy;
begin
  FSCMDebugger.Free;
  inherited;
end;

procedure TServiceWithSCM.RegisterWithSCM;
begin
  FSCMDebugger.Log('Registering with SCM...');

  FStatusHandle := RegisterServiceCtrlHandlerEx(
    PChar(FServiceName),
    @ServiceControlHandlerEx,
    Self  // Contexte passé au handler
  );

  if FStatusHandle = 0 then
  begin
    FSCMDebugger.LogError('RegisterServiceCtrlHandlerEx', GetLastError);
    raise Exception.Create('Failed to register with SCM');
  end;

  FSCMDebugger.Log('Successfully registered with SCM');
end;

procedure TServiceWithSCM.UpdateServiceStatus(NewState: DWORD;
  ExitCode: DWORD; WaitHint: DWORD);
var
  OldState: DWORD;
begin
  OldState := FServiceStatus.dwCurrentState;

  // Mettre à jour la structure
  FServiceStatus.dwCurrentState := NewState;
  FServiceStatus.dwWin32ExitCode := ExitCode;
  FServiceStatus.dwWaitHint := WaitHint;

  // Réinitialiser le checkpoint si on n'est plus en pending
  if not (NewState in [SERVICE_START_PENDING, SERVICE_STOP_PENDING,
                       SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING]) then
    FServiceStatus.dwCheckPoint := 0;

  // Ajuster les contrôles acceptés selon l'état
  case NewState of
    SERVICE_START_PENDING:
      FServiceStatus.dwControlsAccepted := 0;  // Rien pendant le démarrage

    SERVICE_STOP_PENDING:
      FServiceStatus.dwControlsAccepted := 0;  // Rien pendant l'arrêt

    SERVICE_PAUSED:
      FServiceStatus.dwControlsAccepted :=
        SERVICE_ACCEPT_STOP or
        SERVICE_ACCEPT_CONTINUE;

    SERVICE_RUNNING:
      FServiceStatus.dwControlsAccepted :=
        SERVICE_ACCEPT_STOP or
        SERVICE_ACCEPT_PAUSE_CONTINUE or
        SERVICE_ACCEPT_SHUTDOWN or
        SERVICE_ACCEPT_SESSIONCHANGE or
        SERVICE_ACCEPT_POWEREVENT;
  end;

  // Envoyer au SCM
  if not SetServiceStatus(FStatusHandle, @FServiceStatus) then
    FSCMDebugger.LogError('SetServiceStatus', GetLastError)
  else
    FSCMDebugger.LogStatusChange(OldState, NewState);
end;

procedure TServiceWithSCM.ReportCheckpoint(CheckPoint: DWORD; WaitHint: DWORD);
begin
  FServiceStatus.dwCheckPoint := CheckPoint;
  FServiceStatus.dwWaitHint := WaitHint;

  if not SetServiceStatus(FStatusHandle, @FServiceStatus) then
    FSCMDebugger.LogError('ReportCheckpoint', GetLastError)
  else
    FSCMDebugger.Log(Format('Checkpoint %d reported (WaitHint=%dms)',
      [CheckPoint, WaitHint]));
end;

function TServiceWithSCM.Start: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Start method called');

  try
    // S'enregistrer auprès du SCM
    RegisterWithSCM;

    // Informer le SCM que le démarrage commence
    UpdateServiceStatus(SERVICE_START_PENDING, NO_ERROR, 10000);

    // Lancer le démarrage asynchrone
    HandleStart;

  except
    on E: Exception do
    begin
      FSCMDebugger.LogError('Start', E.Message);
      UpdateServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
      Result := False;
    end;
  end;
end;

procedure TServiceWithSCM.HandleStart;
begin
  FSCMDebugger.Log('HandleStart: Beginning startup sequence');

  // Créer un thread pour l'initialisation
  FMainThread := TThread.CreateAnonymousThread(
    procedure
    var
      Step: Integer;
    begin
      try
        // Phase 1 : Initialisation de base
        Step := 1;
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Startup phase 1: Basic initialization');
        Sleep(1000); // Simuler initialisation

        // Phase 2 : Chargement de la configuration
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Startup phase 2: Loading configuration');
        LoadConfiguration;

        // Phase 3 : Connexions
        Inc(Step);
        ReportCheckpoint(Step, 8000);
        FSCMDebugger.Log('Startup phase 3: Establishing connections');
        EstablishConnections;

        // Phase 4 : Démarrage des workers
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Startup phase 4: Starting workers');
        StartWorkers;

        // Démarrage terminé
        UpdateServiceStatus(SERVICE_RUNNING);
        FSCMDebugger.Log('Service started successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandleStart', E.Message);
          UpdateServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
        end;
      end;
    end
  );

  FMainThread.Start;
end;

function TServiceWithSCM.Stop: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Stop method called');
  FShutdownRequested := True;

  HandleStop;
end;

procedure TServiceWithSCM.HandleStop;
begin
  FSCMDebugger.Log('HandleStop: Beginning shutdown sequence');

  // Informer le SCM
  UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 15000);

  // Créer un thread pour l'arrêt
  FShutdownThread := TThread.CreateAnonymousThread(
    procedure
    var
      Step: Integer;
    begin
      try
        Step := 1;

        // Phase 1 : Arrêter les nouveaux travaux
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Shutdown phase 1: Stopping new work');
        StopAcceptingWork;

        // Phase 2 : Attendre la fin des travaux en cours
        Inc(Step);
        ReportCheckpoint(Step, 10000);
        FSCMDebugger.Log('Shutdown phase 2: Waiting for current work');
        WaitForWorkCompletion;

        // Phase 3 : Sauvegarder l'état
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Shutdown phase 3: Saving state');
        SaveState;

        // Phase 4 : Fermer les connexions
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Shutdown phase 4: Closing connections');
        CloseConnections;

        // Phase 5 : Nettoyage
        Inc(Step);
        ReportCheckpoint(Step, 3000);
        FSCMDebugger.Log('Shutdown phase 5: Cleanup');
        Cleanup;

        // Arrêt terminé
        UpdateServiceStatus(SERVICE_STOPPED);
        FSCMDebugger.Log('Service stopped successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandleStop', E.Message);
          // Forcer l'arrêt même en cas d'erreur
          UpdateServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
        end;
      end;
    end
  );

  FShutdownThread.Start;
end;

function TServiceWithSCM.Pause: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Pause method called');

  HandlePause;
end;

procedure TServiceWithSCM.HandlePause;
begin
  FSCMDebugger.Log('HandlePause: Pausing service');

  UpdateServiceStatus(SERVICE_PAUSE_PENDING, NO_ERROR, 5000);

  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        // Suspendre les opérations
        SuspendOperations;
        FPaused := True;

        UpdateServiceStatus(SERVICE_PAUSED);
        FSCMDebugger.Log('Service paused successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandlePause', E.Message);
          // Retourner à l'état running en cas d'échec
          UpdateServiceStatus(SERVICE_RUNNING);
        end;
      end;
    end
  ).Start;
end;

function TServiceWithSCM.Continue: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Continue method called');

  HandleContinue;
end;

procedure TServiceWithSCM.HandleContinue;
begin
  FSCMDebugger.Log('HandleContinue: Resuming service');

  UpdateServiceStatus(SERVICE_CONTINUE_PENDING, NO_ERROR, 5000);

  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        // Reprendre les opérations
        ResumeOperations;
        FPaused := False;

        UpdateServiceStatus(SERVICE_RUNNING);
        FSCMDebugger.Log('Service resumed successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandleContinue', E.Message);
          // Rester en pause en cas d'échec
          UpdateServiceStatus(SERVICE_PAUSED);
        end;
      end;
    end
  ).Start;
end;

procedure TServiceWithSCM.HandleShutdown;
begin
  FSCMDebugger.Log('HandleShutdown: Windows is shutting down');

  // Arrêt d'urgence - pas le temps pour un arrêt gracieux
  UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 5000);

  TThread.CreateAnonymousThread(
    procedure
    begin
      // Sauvegarder seulement l'essentiel
      QuickSaveEssentialData;

      // Arrêt immédiat
      UpdateServiceStatus(SERVICE_STOPPED);
      FSCMDebugger.Log('Emergency shutdown completed');
    end
  ).Start;
end;

procedure TServiceWithSCM.HandleInterrogate;
begin
  FSCMDebugger.Log('HandleInterrogate: SCM requesting current status');

  // Juste renvoyer l'état actuel
  SetServiceStatus(FStatusHandle, @FServiceStatus);
end;

procedure TServiceWithSCM.HandleSessionChange(EventType, SessionId: DWORD);
var
  EventName: string;
begin
  case EventType of
    WTS_SESSION_LOGON:     EventName := 'LOGON';
    WTS_SESSION_LOGOFF:    EventName := 'LOGOFF';
    WTS_SESSION_LOCK:      EventName := 'LOCK';
    WTS_SESSION_UNLOCK:    EventName := 'UNLOCK';
    WTS_REMOTE_CONNECT:    EventName := 'REMOTE_CONNECT';
    WTS_REMOTE_DISCONNECT: EventName := 'REMOTE_DISCONNECT';
  else
    EventName := Format('UNKNOWN_%d', [EventType]);
  end;

  FSCMDebugger.Log(Format('HandleSessionChange: %s (Session %d)',
    [EventName, SessionId]));

  // Adapter le comportement selon l'événement
  case EventType of
    WTS_SESSION_LOGON:
      OnUserLogon(SessionId);

    WTS_SESSION_LOGOFF:
      OnUserLogoff(SessionId);
  end;
end;

procedure TServiceWithSCM.HandlePowerEvent(EventType, EventData: DWORD);
var
  EventName: string;
begin
  case EventType of
    PBT_APMSUSPEND:           EventName := 'SUSPEND';
    PBT_APMRESUMESUSPEND:     EventName := 'RESUME';
    PBT_APMBATTERYLOW:        EventName := 'BATTERY_LOW';
    PBT_APMPOWERSTATUSCHANGE: EventName := 'POWER_STATUS_CHANGE';
    PBT_APMRESUMEAUTOMATIC:   EventName := 'RESUME_AUTOMATIC';
  else
    EventName := Format('UNKNOWN_%d', [EventType]);
  end;

  FSCMDebugger.Log(Format('HandlePowerEvent: %s', [EventName]));

  // Adapter le comportement
  case EventType of
    PBT_APMSUSPEND:
      PrepareForSuspend;

    PBT_APMRESUMESUSPEND:
      RecoverFromSuspend;

    PBT_APMBATTERYLOW:
      EnterLowPowerMode;
  end;
end;

procedure TServiceWithSCM.HandleCustomCommand(Command: DWORD);
begin
  FSCMDebugger.Log(Format('HandleCustomCommand: %d', [Command]));

  case Command of
    128: // Recharger configuration
      begin
        FSCMDebugger.Log('Custom command: Reload configuration');
        ReloadConfiguration;
      end;

    129: // Dump état
      begin
        FSCMDebugger.Log('Custom command: Dump state');
        DumpServiceState;
      end;

    130: // Forcer garbage collection
      begin
        FSCMDebugger.Log('Custom command: Force GC');
        ForceGarbageCollection;
      end;

  else
    FSCMDebugger.Log(Format('Unknown custom command: %d', [Command]));
  end;
end;

procedure TServiceWithSCM.ServiceControlHandler(CtrlCode: DWORD);
begin
  FSCMDebugger.LogSCMMessage(CtrlCode);

  // Traiter le message selon son type
  case CtrlCode of
    SERVICE_CONTROL_STOP:
      HandleStop;

    SERVICE_CONTROL_PAUSE:
      HandlePause;

    SERVICE_CONTROL_CONTINUE:
      HandleContinue;

    SERVICE_CONTROL_INTERROGATE:
      HandleInterrogate;

    SERVICE_CONTROL_SHUTDOWN:
      HandleShutdown;

    SERVICE_CONTROL_SESSIONCHANGE:
      begin
        // Les détails sont dans les paramètres étendus
        // Nécessite ServiceControlHandlerEx
      end;

    SERVICE_CONTROL_POWEREVENT:
      begin
        // Les détails sont dans les paramètres étendus
      end;

    128..255:
      HandleCustomCommand(CtrlCode);

  else
    FSCMDebugger.Log(Format('Unhandled control code: %d', [CtrlCode]));
  end;
end;

function TServiceWithSCM.Execute: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Execute: Main service loop started');

  while not FShutdownRequested do
  begin
    try
      if not FPaused then
      begin
        // Travail principal du service
        DoServiceWork;
      end
      else
      begin
        // En pause - juste attendre
        Sleep(100);
      end;

      // Permettre au thread de répondre aux événements
      CheckSynchronize(100);

    except
      on E: Exception do
      begin
        FSCMDebugger.LogError('Execute', E.Message);
        // Continuer malgré l'erreur
      end;
    end;
  end;

  FSCMDebugger.Log('Execute: Main service loop ended');
end;

end.
```

## Checklist finale pour l'interaction SCM

### ✅ Avant la mise en production

- [ ] **Handler SCM enregistré** correctement avec RegisterServiceCtrlHandler(Ex)
- [ ] **Tous les états obligatoires** gérés (STOP, INTERROGATE, SHUTDOWN)
- [ ] **Transitions d'état** valides et logiques
- [ ] **Checkpoints** implémentés pour les opérations longues
- [ ] **Timeouts** respectés (< 30 secondes pour les réponses)
- [ ] **Logging SCM** complet pour le débogage
- [ ] **Mode asynchrone** pour les opérations longues
- [ ] **Gestion d'erreur** robuste avec fallback
- [ ] **Tests de tous les scénarios** (normal, timeout, crash, shutdown)
- [ ] **Documentation** des commandes personnalisées

### ⚠️ Pièges courants à éviter

1. **Ne jamais bloquer** dans le handler SCM
2. **Ne pas oublier** d'incrémenter les checkpoints
3. **Ne pas ignorer** INTERROGATE
4. **Ne pas faire** d'opérations longues dans SHUTDOWN
5. **Ne pas oublier** de mettre dwControlsAccepted à 0 pendant les transitions
6. **Ne pas négliger** la journalisation
7. **Ne pas supposer** que Stop sera toujours appelé (crash, kill process)
8. **Ne pas oublier** de tester avec des comptes de service limités

## Conclusion

L'interaction avec le Service Control Manager est le cœur de tout service Windows. Une implémentation correcte garantit :
- Un service stable et fiable
- Une intégration parfaite avec Windows
- Une expérience utilisateur professionnelle
- Un débogage facilité en cas de problème

Prenez le temps de bien comprendre et implémenter cette interaction. C'est la différence entre un service amateur et un service professionnel.

N'oubliez jamais : **Le SCM est votre patron, répondez-lui rapidement et précisément !**

⏭️ [Registry Windows](/06-specificites-windows/03-registry-windows.md)
