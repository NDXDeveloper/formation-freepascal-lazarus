üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.3.2 Configuration OpenGL Linux/Mesa

## Introduction

Sous Linux, OpenGL est principalement fourni par **Mesa 3D**, une impl√©mentation open-source compl√®te d'OpenGL. Mesa est le choix standard pour la plupart des distributions Linux, dont Ubuntu, et offre un excellent support pour OpenGL allant jusqu'√† la version 4.6 sur du mat√©riel r√©cent.

Cette section vous guidera dans la configuration d'OpenGL avec FreePascal/Lazarus sur Ubuntu et d'autres distributions Linux, en couvrant √† la fois X11 et Wayland.

---

## Pr√©requis syst√®me

### Configuration minimale requise

| Composant | Minimum | Recommand√© |
|-----------|---------|------------|
| **Distribution** | Ubuntu 18.04 LTS | Ubuntu 22.04 LTS ou plus r√©cent |
| **Carte graphique** | Compatible OpenGL 2.1 | Compatible OpenGL 3.3+ |
| **Pilotes** | Mesa 18+ | Mesa 22+ ou pilotes propri√©taires |
| **RAM** | 2 GB | 4 GB+ |
| **Lazarus** | 2.0+ | Version r√©cente |
| **Serveur graphique** | X11 ou Wayland | X11 (meilleur support) |

### Distributions support√©es

Ce tutoriel est principalement √©crit pour **Ubuntu**, mais les instructions s'appliquent avec de l√©g√®res adaptations √† :
- **Debian** et d√©riv√©s (Linux Mint, Pop!_OS, etc.)
- **Fedora** et d√©riv√©s (RHEL, CentOS Stream)
- **Arch Linux** et d√©riv√©s (Manjaro, EndeavourOS)
- **openSUSE**

---

## V√©rification du support OpenGL

### M√©thode 1 : Via glxinfo

L'outil `glxinfo` affiche toutes les informations sur votre configuration OpenGL :

```bash
# Installer glxinfo si n√©cessaire
sudo apt-get install mesa-utils

# Afficher les informations OpenGL
glxinfo | grep "OpenGL version"
glxinfo | grep "OpenGL renderer"
glxinfo | grep "OpenGL vendor"

# Informations d√©taill√©es
glxinfo | less
```

**Exemple de sortie** :
```
OpenGL version string: 4.6 (Compatibility Profile) Mesa 22.2.5
OpenGL renderer string: Mesa Intel(R) UHD Graphics 620 (KBL GT2)
OpenGL vendor string: Intel
```

### M√©thode 2 : Via glxgears

Test simple de performance OpenGL :

```bash
# Lancer glxgears (test des engrenages)
glxgears

# Avec affichage du FPS
glxgears -info
```

**Interpr√©tation** :
- **300+ FPS** : Acc√©l√©ration mat√©rielle active ‚úÖ
- **< 60 FPS** : Possible probl√®me de pilotes ou rendu logiciel ‚ö†Ô∏è

### M√©thode 3 : Via le code

```pascal
// Apr√®s avoir cr√©√© le contexte OpenGL
procedure CheckOpenGLSupport;
var
  Version, Vendor, Renderer: PChar;
begin
  Version := glGetString(GL_VERSION);
  Vendor := glGetString(GL_VENDOR);
  Renderer := glGetString(GL_RENDERER);

  WriteLn('Version OpenGL: ', Version);
  WriteLn('Vendeur: ', Vendor);
  WriteLn('Renderer: ', Renderer);

  // V√©rifier si c'est du rendu logiciel (√† √©viter)
  if Pos('llvmpipe', string(Renderer)) > 0 then
    WriteLn('ATTENTION: Rendu logiciel d√©tect√© (pas d''acc√©l√©ration GPU)')
  else if Pos('Software', string(Renderer)) > 0 then
    WriteLn('ATTENTION: Rendu logiciel d√©tect√©');
end;
```

---

## Installation des biblioth√®ques n√©cessaires

### Sur Ubuntu/Debian

```bash
# Mettre √† jour les d√©p√¥ts
sudo apt-get update

# Installer les biblioth√®ques de d√©veloppement OpenGL
sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev

# Installer les outils Mesa
sudo apt-get install mesa-utils mesa-common-dev

# Pour X11 (si pas d√©j√† install√©)
sudo apt-get install libx11-dev libxext-dev

# Pour GLX (OpenGL sous X11)
sudo apt-get install libglx-dev

# V√©rifier l'installation
dpkg -l | grep mesa
```

### Sur Fedora/RHEL

```bash
# Installer les biblioth√®ques de d√©veloppement
sudo dnf install mesa-libGL-devel mesa-libGLU-devel

# Installer les outils
sudo dnf install mesa-demos glx-utils

# Pour X11
sudo dnf install libX11-devel libXext-devel
```

### Sur Arch Linux

```bash
# Installer Mesa et utilitaires
sudo pacman -S mesa mesa-demos glu

# Biblioth√®ques de d√©veloppement X11
sudo pacman -S libx11 libxext
```

---

## Configuration des pilotes graphiques

### Mesa (Open Source) - Recommand√©

Mesa est install√© par d√©faut sur la plupart des distributions Linux et offre :
- ‚úÖ Excellent support OpenGL (jusqu'√† 4.6)
- ‚úÖ Stable et bien maintenu
- ‚úÖ Performance correcte sur Intel et AMD
- ‚úÖ Mises √† jour r√©guli√®res

**V√©rifier la version de Mesa** :
```bash
glxinfo | grep "Mesa"
```

**Mettre √† jour Mesa** (Ubuntu) :
```bash
sudo apt-get update
sudo apt-get upgrade mesa-*
```

### Pilotes propri√©taires NVIDIA

Pour les cartes NVIDIA, les pilotes propri√©taires offrent de meilleures performances :

#### Installation automatique (Ubuntu)

```bash
# D√©tecter et installer automatiquement
ubuntu-drivers devices
sudo ubuntu-drivers autoinstall

# OU installer manuellement une version sp√©cifique
sudo apt-get install nvidia-driver-525

# Red√©marrer
sudo reboot
```

#### V√©rification

```bash
# V√©rifier que le pilote est actif
nvidia-smi

# V√©rifier OpenGL
glxinfo | grep NVIDIA
```

### Pilotes propri√©taires AMD (AMDGPU-PRO)

Pour les cartes AMD Radeon r√©centes :

```bash
# Les pilotes open-source AMDGPU sont g√©n√©ralement suffisants
# Mais pour installer les propri√©taires :

# T√©l√©charger depuis AMD.com
wget https://drivers.amd.com/...

# Extraire et installer
tar -Jxvf amdgpu-pro-*.tar.xz
cd amdgpu-pro-*/
./amdgpu-pro-install -y

# Red√©marrer
sudo reboot
```

**Note** : Les pilotes Mesa RADV pour AMD sont excellents et souvent pr√©f√©r√©s.

### Pilotes Intel (int√©gr√©s √† Mesa)

Les GPU Intel utilisent Mesa par d√©faut :
- **HD Graphics** (Gen 7+) : OpenGL 4.6
- **Iris Xe** : OpenGL 4.6
- Aucune installation suppl√©mentaire n√©cessaire

```bash
# V√©rifier le support
glxinfo | grep "Intel"
```

---

## Configuration de Lazarus pour OpenGL

### Installation du package OpenGLContext

#### M√©thode 1 : Via l'IDE Lazarus

1. Lancez **Lazarus**
2. Menu **Paquet** ‚Üí **Ouvrir un fichier paquet (.lpk)**
3. Naviguez vers : `/usr/share/lazarus/components/opengl/lazopenglcontext.lpk`
   - Ou : `/usr/lib/lazarus/components/opengl/lazopenglcontext.lpk`
   - Ou cherchez avec : `find /usr -name "lazopenglcontext.lpk"`
4. Cliquez sur **Compiler**
5. Cliquez sur **Utiliser** ‚Üí **Ajouter au projet**

#### M√©thode 2 : Via la ligne de commande

```bash
# Compiler le package
cd /usr/share/lazarus/components/opengl/
lazbuild lazopenglcontext.lpk

# Le package est maintenant disponible dans l'IDE
```

### V√©rification

Apr√®s installation, le composant **TOpenGLControl** doit appara√Ætre dans la palette **System** de l'IDE Lazarus.

---

## Premier projet OpenGL sous Linux

### Cr√©ation du projet

```bash
# Cr√©er un r√©pertoire pour le projet
mkdir ~/opengl_test
cd ~/opengl_test
```

1. Dans Lazarus : **Projet** ‚Üí **Nouveau projet** ‚Üí **Application**
2. Sauvegarder dans le r√©pertoire cr√©√©

### Code minimal complet

**Unit1.pas** :

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs,
  OpenGLContext, GL, GLU;

type
  TForm1 = class(TForm)
    OpenGLControl1: TOpenGLControl;
    procedure FormCreate(Sender: TObject);
    procedure OpenGLControl1Paint(Sender: TObject);
    procedure OpenGLControl1Resize(Sender: TObject);
  private
    FInitialized: Boolean;
    procedure InitializeOpenGL;
    procedure ConfigureProjection;
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

procedure TForm1.FormCreate(Sender: TObject);
begin
  FInitialized := False;

  // Configuration du TOpenGLControl
  OpenGLControl1.AutoResizeViewport := True;
  OpenGLControl1.DoubleBuffered := True;

  // Cr√©er le contexte OpenGL
  OpenGLControl1.MakeCurrent;

  // Initialiser OpenGL
  InitializeOpenGL;
  FInitialized := True;
end;

procedure TForm1.InitializeOpenGL;
begin
  // Afficher les informations syst√®me
  WriteLn('=== Informations OpenGL ===');
  WriteLn('Version: ', glGetString(GL_VERSION));
  WriteLn('Vendor: ', glGetString(GL_VENDOR));
  WriteLn('Renderer: ', glGetString(GL_RENDERER));
  WriteLn('===========================');

  // Configuration de base
  glClearColor(0.2, 0.3, 0.4, 1.0);  // Fond bleu fonc√©
  glEnable(GL_DEPTH_TEST);            // Test de profondeur
  glDepthFunc(GL_LESS);

  // Culling
  glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);
  glFrontFace(GL_CCW);

  // √âclairage simple
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_COLOR_MATERIAL);

  // Configurer la projection
  ConfigureProjection;
end;

procedure TForm1.ConfigureProjection;
var
  W, H: Integer;
  AspectRatio: Double;
begin
  W := OpenGLControl1.Width;
  H := OpenGLControl1.Height;

  if H = 0 then
    H := 1;

  AspectRatio := W / H;

  // D√©finir le viewport
  glViewport(0, 0, W, H);

  // Configurer la matrice de projection
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  gluPerspective(45.0, AspectRatio, 0.1, 100.0);

  // Revenir √† modelview
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;
end;

procedure TForm1.OpenGLControl1Paint(Sender: TObject);
begin
  if not FInitialized then
    Exit;

  // Effacer les buffers
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  // R√©initialiser la matrice
  glLoadIdentity;

  // Positionner la cam√©ra
  glTranslatef(0.0, 0.0, -5.0);

  // Dessiner un triangle color√©
  glBegin(GL_TRIANGLES);
    glColor3f(1.0, 0.0, 0.0);  // Rouge
    glVertex3f(0.0, 1.0, 0.0);

    glColor3f(0.0, 1.0, 0.0);  // Vert
    glVertex3f(-1.0, -1.0, 0.0);

    glColor3f(0.0, 0.0, 1.0);  // Bleu
    glVertex3f(1.0, -1.0, 0.0);
  glEnd;

  // Afficher
  OpenGLControl1.SwapBuffers;
end;

procedure TForm1.OpenGLControl1Resize(Sender: TObject);
begin
  if FInitialized then
    ConfigureProjection;
end;

end.
```

### Compilation et ex√©cution

```bash
# Via l'IDE
# Appuyez sur F9 ou Ex√©cuter ‚Üí Lancer

# Via la ligne de commande
lazbuild opengl_test.lpi
./opengl_test
```

---

## Gestion des serveurs graphiques

### X11 (X Window System)

X11 est le serveur graphique traditionnel de Linux et offre le meilleur support OpenGL.

#### V√©rifier que vous utilisez X11

```bash
echo $XDG_SESSION_TYPE
# Devrait afficher : x11
```

#### Configuration GLX (OpenGL pour X11)

```bash
# V√©rifier le support GLX
glxinfo | grep "direct rendering"
# Devrait afficher : direct rendering: Yes

# Tester les extensions GLX
glxinfo | grep "GLX version"
```

#### Code sp√©cifique X11

```pascal
{$IFDEF LINUX}
uses
  X, XLib, XUtil;

procedure GetX11WindowInfo;
var
  Display: PDisplay;
  Screen: Integer;
begin
  Display := XOpenDisplay(nil);
  if Display <> nil then
  begin
    Screen := DefaultScreen(Display);
    WriteLn('X11 Screen: ', Screen);
    WriteLn('Display Width: ', DisplayWidth(Display, Screen));
    WriteLn('Display Height: ', DisplayHeight(Display, Screen));
    XCloseDisplay(Display);
  end;
end;
{$ENDIF}
```

### Wayland

Wayland est le successeur moderne de X11, mais le support OpenGL peut √™tre moins mature.

#### V√©rifier que vous utilisez Wayland

```bash
echo $XDG_SESSION_TYPE
# Devrait afficher : wayland
```

#### Support OpenGL sous Wayland

Wayland utilise **EGL** (Embedded-System Graphics Library) au lieu de GLX :

```bash
# V√©rifier le support EGL
eglinfo | grep "EGL version"
```

#### Forcer l'utilisation de X11 (si probl√®mes avec Wayland)

Pour la session actuelle :
```bash
# Se d√©connecter et choisir "Ubuntu on Xorg" √† l'√©cran de connexion
```

Pour forcer X11 de mani√®re permanente :
```bash
# √âditer /etc/gdm3/custom.conf
sudo nano /etc/gdm3/custom.conf

# D√©commenter la ligne :
WaylandEnable=false

# Red√©marrer GDM
sudo systemctl restart gdm3
```

---

## Optimisations sp√©cifiques Linux

### DRI (Direct Rendering Infrastructure)

DRI permet l'acc√®s direct au GPU sans passer par le serveur X :

```bash
# V√©rifier que DRI est actif
glxinfo | grep "direct rendering"
# Doit afficher : direct rendering: Yes

# Si "No", v√©rifier les permissions
groups $USER | grep video

# Ajouter l'utilisateur au groupe video si n√©cessaire
sudo usermod -a -G video $USER
# Se d√©connecter et reconnecter
```

### VSync sous Linux

#### M√©thode 1 : Via les variables d'environnement

```bash
# Forcer VSync ON
export vblank_mode=3
./votre_application

# Forcer VSync OFF
export vblank_mode=0
./votre_application
```

#### M√©thode 2 : Via le code

```pascal
uses
  GLext;

procedure SetVSync(AEnabled: Boolean);
begin
  // Pour Mesa/Linux
  if Load_GLX_EXT_swap_control then
  begin
    if AEnabled then
      glXSwapIntervalEXT(glXGetCurrentDisplay, glXGetCurrentDrawable, 1)
    else
      glXSwapIntervalEXT(glXGetCurrentDisplay, glXGetCurrentDrawable, 0);
  end
  else if Load_GLX_MESA_swap_control then
  begin
    if AEnabled then
      glXSwapIntervalMESA(1)
    else
      glXSwapIntervalMESA(0);
  end
  else
    WriteLn('Extensions VSync non disponibles');
end;
```

### Multi-threading et contextes partag√©s

Sous Linux, cr√©er des contextes OpenGL partag√©s n√©cessite une configuration sp√©ciale :

```pascal
procedure CreateSharedContext;
var
  SharedControl: TOpenGLControl;
begin
  SharedControl := TOpenGLControl.Create(Self);
  SharedControl.Parent := Self;

  // Partager le contexte avec OpenGLControl1
  SharedControl.SharedControl := OpenGLControl1;

  // Maintenant les deux contr√¥les partagent textures, VBO, etc.
end;
```

---

## Gestion des extensions OpenGL

### Charger les extensions

```pascal
uses
  GLext;

procedure LoadOpenGLExtensions;
begin
  // Charger automatiquement toutes les extensions disponibles
  if Load_GL_version_3_0 then
    WriteLn('OpenGL 3.0 disponible')
  else
    WriteLn('OpenGL 3.0 non disponible');

  if Load_GL_ARB_vertex_buffer_object then
    WriteLn('VBO support√©s')
  else
    WriteLn('VBO non support√©s');

  if Load_GL_ARB_shader_objects then
    WriteLn('Shaders support√©s')
  else
    WriteLn('Shaders non support√©s');
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  OpenGLControl1.MakeCurrent;
  InitializeOpenGL;

  // Charger les extensions apr√®s cr√©ation du contexte
  LoadOpenGLExtensions;
end;
```

### V√©rifier les extensions disponibles

```pascal
procedure ListGLExtensions;
var
  Extensions: string;
  ExtList: TStringList;
  i: Integer;
begin
  Extensions := string(glGetString(GL_EXTENSIONS));
  ExtList := TStringList.Create;
  try
    ExtList.Delimiter := ' ';
    ExtList.DelimitedText := Extensions;
    ExtList.Sort;

    WriteLn('Extensions OpenGL disponibles :');
    for i := 0 to ExtList.Count - 1 do
      WriteLn('  ', ExtList[i]);
  finally
    ExtList.Free;
  end;
end;
```

---

## Debugging sous Linux

### Outils de debugging

#### Mesa Debug Layer

Activer les messages de debug de Mesa :

```bash
# Variables d'environnement pour debugging
export MESA_DEBUG=1
export LIBGL_DEBUG=verbose
export EGL_LOG_LEVEL=debug

# Lancer l'application
./votre_application
```

#### apitrace

Capturer et rejouer les appels OpenGL :

```bash
# Installer apitrace
sudo apt-get install apitrace

# Capturer une trace
apitrace trace ./votre_application

# Analyser la trace
qapitrace votre_application.trace
```

#### RenderDoc sous Linux

```bash
# Installer RenderDoc
sudo apt-get install renderdoc

# Lancer
renderdoc

# Puis lancer votre application depuis RenderDoc
```

### V√©rification des erreurs OpenGL

```pascal
procedure CheckGLError(const AContext: string);
var
  Error: GLenum;
  ErrorStr: string;
begin
  Error := glGetError;

  if Error <> GL_NO_ERROR then
  begin
    case Error of
      GL_INVALID_ENUM:      ErrorStr := 'GL_INVALID_ENUM';
      GL_INVALID_VALUE:     ErrorStr := 'GL_INVALID_VALUE';
      GL_INVALID_OPERATION: ErrorStr := 'GL_INVALID_OPERATION';
      GL_STACK_OVERFLOW:    ErrorStr := 'GL_STACK_OVERFLOW';
      GL_STACK_UNDERFLOW:   ErrorStr := 'GL_STACK_UNDERFLOW';
      GL_OUT_OF_MEMORY:     ErrorStr := 'GL_OUT_OF_MEMORY';
    else
      ErrorStr := Format('Erreur inconnue: %d', [Error]);
    end;

    WriteLn(Format('[ERREUR OpenGL] %s: %s', [AContext, ErrorStr]));
  end;
end;

// Mode debug automatique
{$IFDEF DEBUG}
{$DEFINE GL_ERROR_CHECK}
{$ENDIF}

procedure GLCall(const AFunctionName: string);
begin
  {$IFDEF GL_ERROR_CHECK}
  CheckGLError(AFunctionName);
  {$ENDIF}
end;

// Utilisation
glEnable(GL_DEPTH_TEST);
GLCall('glEnable(GL_DEPTH_TEST)');
```

---

## Gestion des chemins et fichiers

### Chemins Linux standards

```pascal
{$IFDEF LINUX}
const
  // R√©pertoire home de l'utilisateur
  USER_HOME = '/home/user/';  // Ou utiliser GetEnvironmentVariable('HOME')

  // R√©pertoires standards
  DATA_DIR = '/usr/share/votre_app/';
  CONFIG_DIR = '~/.config/votre_app/';
  CACHE_DIR = '~/.cache/votre_app/';
{$ENDIF}

function GetUserConfigDir: string;
begin
  {$IFDEF LINUX}
  Result := GetEnvironmentVariable('HOME') + '/.config/votre_app/';
  {$ENDIF}
  {$IFDEF WINDOWS}
  Result := GetEnvironmentVariable('APPDATA') + '\votre_app\';
  {$ENDIF}

  // Cr√©er le r√©pertoire s'il n'existe pas
  if not DirectoryExists(Result) then
    ForceDirectories(Result);
end;

function GetResourcePath(const AFileName: string): string;
begin
  {$IFDEF LINUX}
  // Chercher dans plusieurs emplacements
  if FileExists('/usr/share/votre_app/' + AFileName) then
    Result := '/usr/share/votre_app/' + AFileName
  else if FileExists(ExtractFilePath(ParamStr(0)) + 'resources/' + AFileName) then
    Result := ExtractFilePath(ParamStr(0)) + 'resources/' + AFileName
  else
    Result := AFileName;  // Chemin relatif
  {$ENDIF}

  {$IFDEF WINDOWS}
  Result := ExtractFilePath(ParamStr(0)) + 'resources\' + AFileName;
  {$ENDIF}
end;
```

---

## Exemple complet : Application OpenGL Linux

Voici une application compl√®te avec animation et interactions :

```pascal
unit MainUnit;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ExtCtrls, StdCtrls,
  OpenGLContext, GL, GLU, DateUtils;

type
  TMainForm = class(TForm)
    OpenGLControl1: TOpenGLControl;
    Panel1: TPanel;
    Timer1: TTimer;
    ButtonReset: TButton;
    CheckBoxWireframe: TCheckBox;
    LabelFPS: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure OpenGLControl1Paint(Sender: TObject);
    procedure OpenGLControl1Resize(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure ButtonResetClick(Sender: TObject);
    procedure CheckBoxWireframeChange(Sender: TObject);
  private
    FInitialized: Boolean;
    FAngle: Single;
    FRotationSpeed: Single;
    FLastTime: TDateTime;
    FFrameCount: Integer;
    FFPS: Integer;
    procedure InitializeOpenGL;
    procedure ConfigureProjection;
    procedure RenderScene;
    procedure UpdateFPS;
    procedure DrawCube;
  end;

var
  MainForm: TMainForm;

implementation

{$R *.lfm}

procedure TMainForm.FormCreate(Sender: TObject);
begin
  FInitialized := False;
  FAngle := 0.0;
  FRotationSpeed := 1.0;
  FFrameCount := 0;
  FFPS := 0;
  FLastTime := Now;

  // Configuration du contr√¥le OpenGL
  OpenGLControl1.AutoResizeViewport := True;
  OpenGLControl1.DoubleBuffered := True;

  // Cr√©er le contexte
  OpenGLControl1.MakeCurrent;

  // Initialiser OpenGL
  InitializeOpenGL;
  FInitialized := True;

  // Activer le timer
  Timer1.Interval := 16;  // ~60 FPS
  Timer1.Enabled := True;

  // Permettre la gestion du clavier
  KeyPreview := True;
end;

procedure TMainForm.FormDestroy(Sender: TObject);
begin
  Timer1.Enabled := False;
end;

procedure TMainForm.InitializeOpenGL;
var
  Version, Vendor, Renderer: PChar;
begin
  // Afficher les informations
  Version := glGetString(GL_VERSION);
  Vendor := glGetString(GL_VENDOR);
  Renderer := glGetString(GL_RENDERER);

  WriteLn('=== Configuration OpenGL Linux ===');
  WriteLn('Version: ', Version);
  WriteLn('Vendor: ', Vendor);
  WriteLn('Renderer: ', Renderer);
  WriteLn('==================================');

  // V√©rifier le rendu logiciel
  if Pos('llvmpipe', string(Renderer)) > 0 then
    WriteLn('AVERTISSEMENT: Rendu logiciel d√©tect√© - performance limit√©e');

  // Configuration
  glClearColor(0.1, 0.1, 0.2, 1.0);
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LESS);

  glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);

  // √âclairage
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_COLOR_MATERIAL);

  // Position de la lumi√®re
  glLightfv(GL_LIGHT0, GL_POSITION, @GLfloat(array[0..3] of GLfloat = (5.0, 5.0, 5.0, 1.0)));

  ConfigureProjection;
end;

procedure TMainForm.ConfigureProjection;
var
  W, H: Integer;
  AspectRatio: Double;
begin
  W := OpenGLControl1.Width;
  H := OpenGLControl1.Height;
  if H = 0 then H := 1;

  AspectRatio := W / H;

  glViewport(0, 0, W, H);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  gluPerspective(45.0, AspectRatio, 0.1, 100.0);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;
end;

procedure TMainForm.DrawCube;
begin
  glBegin(GL_QUADS);
    // Face avant (rouge)
    glColor3f(1.0, 0.0, 0.0);
    glNormal3f(0.0, 0.0, 1.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glVertex3f(1.0, -1.0, 1.0);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(-1.0, 1.0, 1.0);

    // Face arri√®re (vert)
    glColor3f(0.0, 1.0, 0.0);
    glNormal3f(0.0, 0.0, -1.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glVertex3f(1.0, 1.0, -1.0);
    glVertex3f(1.0, -1.0, -1.0);

    // Face haut (bleu)
    glColor3f(0.0, 0.0, 1.0);
    glNormal3f(0.0, 1.0, 0.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glVertex3f(-1.0, 1.0, 1.0);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(1.0, 1.0, -1.0);

    // Face bas (jaune)
    glColor3f(1.0, 1.0, 0.0);
    glNormal3f(0.0, -1.0, 0.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(1.0, -1.0, -1.0);
    glVertex3f(1.0, -1.0, 1.0);
    glVertex3f(-1.0, -1.0, 1.0);

    // Face droite (magenta)
    glColor3f(1.0, 0.0, 1.0);
    glNormal3f(1.0, 0.0, 0.0);
    glVertex3f(1.0, -1.0, -1.0);
    glVertex3f(1.0, 1.0, -1.0);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(1.0, -1.0, 1.0);

    // Face gauche (cyan)
    glColor3f(0.0, 1.0, 1.0);
    glNormal3f(-1.0, 0.0, 0.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glVertex3f(-1.0, 1.0, 1.0);
    glVertex3f(-1.0, 1.0, -1.0);
  glEnd;
end;

procedure TMainForm.RenderScene;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadIdentity;

  // Position de la cam√©ra
  glTranslatef(0.0, 0.0, -6.0);

  // Rotations anim√©es
  glRotatef(FAngle, 0.0, 1.0, 0.0);
  glRotatef(FAngle * 0.5, 1.0, 0.0, 0.0);

  // Dessiner le cube
  DrawCube;
end;

procedure TMainForm.OpenGLControl1Paint(Sender: TObject);
begin
  if not FInitialized then
    Exit;

  RenderScene;
  OpenGLControl1.SwapBuffers;
  UpdateFPS;
end;

procedure TMainForm.OpenGLControl1Resize(Sender: TObject);
begin
  if FInitialized then
    ConfigureProjection;
end;

procedure TMainForm.Timer1Timer(Sender: TObject);
begin
  // Incr√©menter l'angle
  FAngle := FAngle + FRotationSpeed;
  if FAngle >= 360.0 then
    FAngle := FAngle - 360.0;

  // Redessiner
  OpenGLControl1.Invalidate;
end;

procedure TMainForm.UpdateFPS;
var
  CurrentTime: TDateTime;
  ElapsedMS: Int64;
begin
  Inc(FFrameCount);
  CurrentTime := Now;
  ElapsedMS := MilliSecondsBetween(CurrentTime, FLastTime);

  if ElapsedMS >= 1000 then
  begin
    FFPS := FFrameCount;
    FFrameCount := 0;
    FLastTime := CurrentTime;

    Caption := Format('OpenGL Linux - FPS: %d', [FFPS]);
    LabelFPS.Caption := Format('FPS: %d', [FFPS]);
  end;
end;

procedure TMainForm.ButtonResetClick(Sender: TObject);
begin
  FAngle := 0.0;
  FRotationSpeed := 1.0;
  OpenGLControl1.Invalidate;
end;

procedure TMainForm.CheckBoxWireframeChange(Sender: TObject);
begin
  OpenGLControl1.MakeCurrent;

  if CheckBoxWireframe.Checked then
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
  else
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

  OpenGLControl1.Invalidate;
end;

procedure TMainForm.FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  case Key of
    VK_UP:    FRotationSpeed := FRotationSpeed + 0.5;
    VK_DOWN:  FRotationSpeed := FRotationSpeed - 0.5;
    VK_SPACE: FRotationSpeed := 0.0;
    VK_R:     ButtonResetClick(nil);
    VK_W:     CheckBoxWireframe.Checked := not CheckBoxWireframe.Checked;
    VK_ESCAPE: Close;
  end;
end;

end.
```

---

## Probl√®mes courants et solutions

### Probl√®me 1 : "Cannot create OpenGL context"

**Causes possibles** :
- Biblioth√®ques Mesa manquantes
- Pilotes OpenGL non install√©s
- Configuration X11 incorrecte

**Solutions** :

```bash
# R√©installer Mesa
sudo apt-get install --reinstall libgl1-mesa-glx libgl1-mesa-dri

# V√©rifier les biblioth√®ques li√©es
ldd $(which lazarus) | grep GL
ldd ./votre_application | grep GL

# Installer les paquets de d√©veloppement
sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev libglx-dev

# V√©rifier la configuration X11
echo $DISPLAY
# Devrait afficher quelque chose comme :0 ou :1
```

### Probl√®me 2 : Rendu logiciel (llvmpipe)

**Sympt√¥mes** :
- FPS tr√®s bas (< 60 FPS)
- `glxinfo` affiche "llvmpipe" comme renderer
- Pas d'acc√©l√©ration GPU

**Diagnostic** :

```bash
# V√©rifier le renderer actuel
glxinfo | grep "OpenGL renderer"
# Si vous voyez "llvmpipe", c'est du rendu logiciel

# V√©rifier le direct rendering
glxinfo | grep "direct rendering"
# Doit afficher: "direct rendering: Yes"

# V√©rifier les modules DRI charg√©s
ls /usr/lib/x86_64-linux-gnu/dri/
# Devrait lister: i965_dri.so (Intel), radeonsi_dri.so (AMD), etc.
```

**Solutions** :

```bash
# Pour Intel
sudo apt-get install mesa-va-drivers intel-media-va-driver

# Pour AMD
sudo apt-get install mesa-vulkan-drivers libvulkan1

# Pour NVIDIA (pilotes propri√©taires)
sudo ubuntu-drivers autoinstall
sudo reboot

# V√©rifier les permissions
sudo usermod -a -G video $USER
sudo usermod -a -G render $USER
# Se d√©connecter et reconnecter

# Forcer l'utilisation du GPU d√©di√© (laptops)
DRI_PRIME=1 ./votre_application
```

### Probl√®me 3 : √âcran noir

**Causes possibles** :
- Contexte OpenGL non cr√©√© correctement
- Projection mal configur√©e
- Z-buffer non activ√©

**Solutions** :

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  // IMPORTANT: Cr√©er le contexte AVANT toute op√©ration OpenGL
  if not OpenGLControl1.MakeCurrent then
  begin
    ShowMessage('Impossible de cr√©er le contexte OpenGL');
    Exit;
  end;

  // V√©rifier que le contexte est valide
  WriteLn('Version OpenGL: ', glGetString(GL_VERSION));

  InitializeOpenGL;
end;

procedure TForm1.InitializeOpenGL;
begin
  // S'assurer que le contexte est actif
  OpenGLControl1.MakeCurrent;

  // Configurer correctement
  glClearColor(0.2, 0.3, 0.4, 1.0);  // Pas noir total pour d√©bugger
  glEnable(GL_DEPTH_TEST);            // CRITIQUE

  // V√©rifier les erreurs
  CheckGLError('InitializeOpenGL');
end;
```

### Probl√®me 4 : Scintillement (tearing)

**Causes** :
- VSync d√©sactiv√©
- Double buffering mal configur√©

**Solutions** :

```bash
# Forcer VSync via variables d'environnement
export vblank_mode=3
./votre_application

# OU dans le code
```

```pascal
procedure EnableVSync;
begin
  // Mesa/Linux
  if Load_GLX_MESA_swap_control then
  begin
    glXSwapIntervalMESA(1);
    WriteLn('VSync activ√© (Mesa)');
  end
  else if Load_GLX_EXT_swap_control then
  begin
    glXSwapIntervalEXT(glXGetCurrentDisplay, glXGetCurrentDrawable, 1);
    WriteLn('VSync activ√© (EXT)');
  end
  else
    WriteLn('VSync non disponible');
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  OpenGLControl1.MakeCurrent;
  OpenGLControl1.DoubleBuffered := True;  // IMPORTANT
  InitializeOpenGL;
  EnableVSync;
end;
```

### Probl√®me 5 : Crash au redimensionnement

**Causes** :
- Division par z√©ro (hauteur = 0)
- Projection recalcul√©e trop t√¥t

**Solution** :

```pascal
procedure TForm1.OpenGLControl1Resize(Sender: TObject);
begin
  // Protection contre initialisation incompl√®te
  if not FInitialized then
    Exit;

  // S'assurer que le contexte est actif
  if not OpenGLControl1.MakeCurrent then
    Exit;

  // Protection contre dimensions invalides
  if (OpenGLControl1.Width = 0) or (OpenGLControl1.Height = 0) then
    Exit;

  ConfigureProjection;
  OpenGLControl1.Invalidate;
end;

procedure TForm1.ConfigureProjection;
var
  W, H: Integer;
  AspectRatio: Double;
begin
  W := OpenGLControl1.Width;
  H := OpenGLControl1.Height;

  // Protection contre division par z√©ro
  if H = 0 then
    H := 1;

  AspectRatio := W / H;

  glViewport(0, 0, W, H);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  gluPerspective(45.0, AspectRatio, 0.1, 100.0);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;
end;
```

### Probl√®me 6 : Fuite m√©moire

**Causes** :
- Textures non lib√©r√©es
- VBO non supprim√©s
- Display lists non nettoy√©es

**Solution** :

```pascal
type
  TMainForm = class(TForm)
  private
    FTextures: array of GLuint;
    FVBOs: array of GLuint;
    FDisplayLists: array of GLuint;
    procedure CleanupOpenGL;
  end;

procedure TMainForm.FormDestroy(Sender: TObject);
begin
  // Activer le contexte avant nettoyage
  if Assigned(OpenGLControl1) then
  begin
    OpenGLControl1.MakeCurrent;
    CleanupOpenGL;
  end;
end;

procedure TMainForm.CleanupOpenGL;
var
  i: Integer;
begin
  // Supprimer les textures
  if Length(FTextures) > 0 then
  begin
    glDeleteTextures(Length(FTextures), @FTextures[0]);
    SetLength(FTextures, 0);
  end;

  // Supprimer les VBO
  if Length(FVBOs) > 0 then
  begin
    glDeleteBuffers(Length(FVBOs), @FVBOs[0]);
    SetLength(FVBOs, 0);
  end;

  // Supprimer les display lists
  for i := 0 to High(FDisplayLists) do
    if FDisplayLists[i] <> 0 then
      glDeleteLists(FDisplayLists[i], 1);

  SetLength(FDisplayLists, 0);
end;
```

---

## Performance et profiling sous Linux

### Mesa Gallium HUD

Mesa int√®gre un affichage t√™te haute (HUD) pour surveiller les performances :

```bash
# Activer le HUD avec FPS
export GALLIUM_HUD="fps"
./votre_application

# HUD complet
export GALLIUM_HUD="fps,cpu,GPU-load,draw-calls,vertices,VRAM-usage"
./votre_application

# HUD simple dans un coin
export GALLIUM_HUD="simple,fps"
./votre_application
```

### Profiling avec perf

```bash
# Installer perf
sudo apt-get install linux-tools-common linux-tools-generic

# Profiler l'application
perf record -g ./votre_application

# Analyser les r√©sultats
perf report

# Profiler avec focus sur OpenGL
perf record -e cycles -g ./votre_application
```

### Profiling GPU avec renderdoc

```bash
# Installer RenderDoc
sudo apt-get install renderdoc

# Lancer
renderdoc

# Dans RenderDoc:
# 1. File ‚Üí Inject into Process
# 2. S√©lectionner votre application
# 3. Appuyer sur F12 pour capturer une frame
```

### Optimisations sp√©cifiques Mesa

```bash
# Activer le multi-threading shader
export mesa_glthread=true
./votre_application

# D√©sactiver les validations (gain de performance)
export MESA_NO_ERROR=1
./votre_application

# Forcer l'utilisation du GPU d√©di√© (laptops bi-GPU)
export DRI_PRIME=1
./votre_application
```

---

## Scripts utiles pour le d√©veloppement

### Script de compilation

**build.sh** :

```bash
#!/bin/bash

echo "=== Compilation de l'application OpenGL ==="

# Nettoyer
echo "Nettoyage..."
rm -rf lib/ backup/

# Compiler
echo "Compilation..."
lazbuild --build-mode=Release opengl_app.lpi

if [ $? -eq 0 ]; then
    echo "Compilation r√©ussie !"

    # Copier les ressources
    echo "Copie des ressources..."
    mkdir -p bin/resources
    cp -r resources/* bin/resources/

    echo "=== Build termin√© ==="
else
    echo "ERREUR lors de la compilation"
    exit 1
fi
```

### Script de test

**test.sh** :

```bash
#!/bin/bash

echo "=== Tests OpenGL ==="

# V√©rifier Mesa
echo "Version Mesa:"
glxinfo | grep "Mesa"

# V√©rifier OpenGL
echo -e "\nVersion OpenGL:"
glxinfo | grep "OpenGL version"

# V√©rifier le renderer
echo -e "\nRenderer:"
glxinfo | grep "OpenGL renderer"

# V√©rifier direct rendering
echo -e "\nDirect rendering:"
glxinfo | grep "direct rendering"

# Test de performance
echo -e "\nTest de performance (glxgears 10 secondes):"
timeout 10 glxgears 2>&1 | tail -n 5

# Lancer l'application avec monitoring
echo -e "\n=== Lancement de l'application ==="
export GALLIUM_HUD="fps,cpu"
export MESA_DEBUG=1
./opengl_app
```

### Script d'installation des d√©pendances

**install_deps.sh** :

```bash
#!/bin/bash

echo "=== Installation des d√©pendances OpenGL pour Ubuntu ==="

# Mise √† jour
sudo apt-get update

# Biblioth√®ques Mesa
echo "Installation de Mesa..."
sudo apt-get install -y \
    libgl1-mesa-dev \
    libglu1-mesa-dev \
    libglx-dev \
    mesa-common-dev \
    mesa-utils

# Outils de d√©veloppement
echo "Installation des outils..."
sudo apt-get install -y \
    build-essential \
    gdb \
    valgrind

# Outils OpenGL
echo "Installation des outils OpenGL..."
sudo apt-get install -y \
    renderdoc \
    apitrace

# Lazarus (si pas encore install√©)
echo "V√©rification de Lazarus..."
if ! command -v lazarus &> /dev/null; then
    echo "Installation de Lazarus..."
    sudo apt-get install -y lazarus
fi

echo "=== Installation termin√©e ==="
echo "Red√©marrez votre session pour que les groupes prennent effet"
```

---

## Packaging et distribution

### Cr√©er un .deb

**Structure** :

```
mon-app/
‚îú‚îÄ‚îÄ DEBIAN/
‚îÇ   ‚îî‚îÄ‚îÄ control
‚îú‚îÄ‚îÄ usr/
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mon-app
‚îÇ   ‚îî‚îÄ‚îÄ share/
‚îÇ       ‚îú‚îÄ‚îÄ applications/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ mon-app.desktop
‚îÇ       ‚îú‚îÄ‚îÄ icons/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ hicolor/
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ 64x64/
‚îÇ       ‚îÇ           ‚îî‚îÄ‚îÄ apps/
‚îÇ       ‚îÇ               ‚îî‚îÄ‚îÄ mon-app.png
‚îÇ       ‚îî‚îÄ‚îÄ mon-app/
‚îÇ           ‚îî‚îÄ‚îÄ resources/
```

**DEBIAN/control** :

```
Package: mon-app-opengl
Version: 1.0
Section: graphics
Priority: optional
Architecture: amd64
Depends: libgl1, libglu1, libx11-6
Maintainer: Votre Nom <email@example.com>
Description: Application OpenGL avec FreePascal
 Description d√©taill√©e de votre application
 utilisant OpenGL et FreePascal/Lazarus.
```

**usr/share/applications/mon-app.desktop** :

```desktop
[Desktop Entry]
Version=1.0
Type=Application
Name=Mon App OpenGL
Comment=Application 3D avec OpenGL
Exec=/usr/bin/mon-app
Icon=mon-app
Terminal=false
Categories=Graphics;3DGraphics;
```

**Cr√©er le package** :

```bash
# Construire le package
dpkg-deb --build mon-app

# Installer
sudo dpkg -i mon-app.deb

# V√©rifier
dpkg -L mon-app-opengl
```

### Cr√©er un AppImage

```bash
# T√©l√©charger appimagetool
wget https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
chmod +x appimagetool-x86_64.AppImage

# Structure AppDir
mkdir -p MonApp.AppDir/usr/bin
mkdir -p MonApp.AppDir/usr/share/applications
mkdir -p MonApp.AppDir/usr/share/icons/hicolor/256x256/apps

# Copier les fichiers
cp mon-app MonApp.AppDir/usr/bin/
cp mon-app.desktop MonApp.AppDir/usr/share/applications/
cp icon.png MonApp.AppDir/usr/share/icons/hicolor/256x256/apps/mon-app.png

# Cr√©er l'AppImage
./appimagetool-x86_64.AppImage MonApp.AppDir

# Tester
./Mon_App-x86_64.AppImage
```

---

## Bonnes pratiques Linux

### 1. Gestion des chemins

```pascal
function GetApplicationDataDir: string;
begin
  {$IFDEF LINUX}
  Result := GetEnvironmentVariable('HOME') + '/.local/share/mon-app/';
  {$ENDIF}

  if not DirectoryExists(Result) then
    ForceDirectories(Result);
end;

function GetConfigDir: string;
begin
  {$IFDEF LINUX}
  Result := GetEnvironmentVariable('HOME') + '/.config/mon-app/';
  {$ENDIF}

  if not DirectoryExists(Result) then
    ForceDirectories(Result);
end;

function GetCacheDir: string;
begin
  {$IFDEF LINUX}
  Result := GetEnvironmentVariable('HOME') + '/.cache/mon-app/';
  {$ENDIF}

  if not DirectoryExists(Result) then
    ForceDirectories(Result);
end;
```

### 2. Respect des standards FreeDesktop

```pascal
// Utiliser XDG Base Directory Specification
function GetXDGDataHome: string;
begin
  Result := GetEnvironmentVariable('XDG_DATA_HOME');
  if Result = '' then
    Result := GetEnvironmentVariable('HOME') + '/.local/share';
end;

function GetXDGConfigHome: string;
begin
  Result := GetEnvironmentVariable('XDG_CONFIG_HOME');
  if Result = '' then
    Result := GetEnvironmentVariable('HOME') + '/.config';
end;

function GetXDGCacheHome: string;
begin
  Result := GetEnvironmentVariable('XDG_CACHE_HOME');
  if Result = '' then
    Result := GetEnvironmentVariable('HOME') + '/.cache';
end;
```

### 3. Gestion des signaux Unix

```pascal
uses
  BaseUnix;

procedure SignalHandler(sig: cint); cdecl;
begin
  case sig of
    SIGTERM, SIGINT:
      begin
        WriteLn('Signal re√ßu, nettoyage...');
        // Nettoyer les ressources OpenGL
        Application.Terminate;
      end;
  end;
end;

procedure InstallSignalHandlers;
var
  sa: SigActionRec;
begin
  FillChar(sa, SizeOf(sa), 0);
  sa.sa_handler := @SignalHandler;
  FpSigAction(SIGTERM, @sa, nil);
  FpSigAction(SIGINT, @sa, nil);
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  InstallSignalHandlers;
  // ... reste de l'initialisation
end;
```

---

## Ressources et documentation Linux

### Documentation officielle

- **Mesa 3D** : https://www.mesa3d.org/
- **X.Org** : https://www.x.org/wiki/
- **FreeDesktop.org** : https://www.freedesktop.org/wiki/
- **Lazarus Wiki Linux** : https://wiki.lazarus.freepascal.org/Linux

### Forums et communaut√©

- **FreePascal Forum Linux** : https://forum.lazarus.freepascal.org/index.php/board,14.0.html
- **Mesa Users Mailing List** : https://lists.freedesktop.org/mailman/listinfo/mesa-users
- **Ubuntu Forums** : https://ubuntuforums.org/

### Outils recommand√©s

- **RenderDoc** : Debugging OpenGL/Vulkan
- **apitrace** : Trace et rejeu d'appels OpenGL
- **Mesa demos** : Exemples et tests OpenGL
- **Valgrind** : D√©tection de fuites m√©moire
- **GDB** : Debugging g√©n√©ral

---

## Conclusion

La configuration d'OpenGL sous Linux avec FreePascal/Lazarus est maintenant compl√®te. Points cl√©s √† retenir :

‚úÖ **Mesa** : Impl√©mentation OpenGL open-source excellente
‚úÖ **Pilotes** : Mesa pour Intel/AMD, propri√©taires pour NVIDIA
‚úÖ **Installation** : Simple avec apt-get
‚úÖ **TOpenGLControl** : Fonctionne identiquement √† Windows
‚úÖ **Performance** : Excellente avec bons pilotes
‚úÖ **Debugging** : Outils riches (perf, RenderDoc, apitrace)
‚úÖ **Portabilit√©** : Code quasi-identique √† Windows

### Diff√©rences Windows/Linux

| Aspect | Windows | Linux |
|--------|---------|-------|
| **Biblioth√®que** | opengl32.dll | libGL.so (Mesa) |
| **Extensions** | WGL | GLX/EGL |
| **VSync** | wglSwapIntervalEXT | glXSwapIntervalMESA |
| **Installation** | Int√©gr√© | apt-get install |
| **Debugging** | RenderDoc, NSight | RenderDoc, apitrace |

### Prochaines √©tapes

Vous √™tes maintenant pr√™t pour :
- D√©velopper des applications OpenGL portables
- Utiliser les shaders GLSL
- Optimiser pour les performances
- Cr√©er des jeux et visualisations 3D

Bon d√©veloppement OpenGL sous Linux ! üêßüöÄ

‚è≠Ô∏è [Vulkan et rendu moderne](/12-interfaces-graphiques-avancees/04-vulkan-rendu-moderne.md)
