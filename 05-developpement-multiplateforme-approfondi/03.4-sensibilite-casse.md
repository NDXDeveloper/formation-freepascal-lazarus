üîù Retour au [Sommaire](/SOMMAIRE.md)

# Gestion de la sensibilit√© √† la casse en FreePascal/Lazarus
## D√©veloppement multi-plateforme Windows/Linux

## Introduction

Imaginez que vous cr√©ez un fichier nomm√© "Document.txt" et que votre programme essaie ensuite d'ouvrir "document.txt". Sur Windows, √ßa fonctionne parfaitement. Sur Linux, votre programme crash avec une erreur "fichier introuvable". Pourquoi ? C'est une question de sensibilit√© √† la casse !

La sensibilit√© √† la casse (en anglais "case sensitivity") d√©termine si les lettres majuscules et minuscules sont consid√©r√©es comme diff√©rentes. C'est l'une des diff√©rences les plus pi√©geuses entre Windows et Linux, source de nombreux bugs difficiles √† d√©tecter lors du d√©veloppement multi-plateforme.

Ce tutoriel vous expliquera tout ce que vous devez savoir pour g√©rer correctement ces diff√©rences et cr√©er des applications vraiment portables.

## Comprendre la sensibilit√© √† la casse

### Les diff√©rences fondamentales

**Windows : Insensible √† la casse (case-insensitive)**
- `Document.txt` = `document.txt` = `DOCUMENT.TXT`
- Un seul fichier peut exister avec ces variantes de nom
- Les chemins sont √©quivalents : `C:\Users` = `c:\users` = `C:\USERS`

**Linux/Unix : Sensible √† la casse (case-sensitive)**
- `Document.txt` ‚â† `document.txt` ‚â† `DOCUMENT.TXT`
- Ces trois noms repr√©sentent trois fichiers diff√©rents
- Les chemins sont distincts : `/home/User` ‚â† `/home/user`

**macOS : Cas particulier**
- Par d√©faut insensible √† la casse mais pr√©serve la casse
- Peut √™tre configur√© en sensible √† la casse
- HFS+ : insensible, APFS : configurable

### Visualisation du probl√®me

Voici ce qui peut arriver sur chaque syst√®me :

```bash
# Sur Linux
$ touch Document.txt
$ touch document.txt
$ touch DOCUMENT.TXT
$ ls
Document.txt  document.txt  DOCUMENT.TXT
# Trois fichiers diff√©rents existent !

# Sur Windows
> echo. > Document.txt
> echo. > document.txt
> echo. > DOCUMENT.TXT
> dir
Document.txt
# Un seul fichier existe (le nom peut varier selon l'ordre de cr√©ation)
```

## Syst√®me de fichiers et sensibilit√© √† la casse

### Comportement par syst√®me de fichiers

| Syst√®me de fichiers | OS principal | Sensibilit√© √† la casse |
|-------------------|--------------|------------------------|
| NTFS | Windows | Insensible (mais pr√©serve la casse) |
| FAT32/exFAT | Windows | Insensible |
| ext4 | Linux | Sensible |
| Btrfs | Linux | Sensible |
| XFS | Linux | Sensible |
| HFS+ | macOS ancien | Insensible par d√©faut |
| APFS | macOS moderne | Configurable |
| ZFS | Multi-OS | Configurable |

### D√©tection du syst√®me en FreePascal

```pascal
uses
  SysUtils
  {$IFDEF UNIX}
  , BaseUnix
  {$ENDIF}
  ;

function SystemeEstSensibleCasse: Boolean;
begin
  {$IFDEF WINDOWS}
  // Windows est toujours insensible √† la casse
  Result := False;
  {$ENDIF}

  {$IFDEF UNIX}
    {$IFDEF DARWIN}
    // macOS : g√©n√©ralement insensible mais on peut tester
    Result := False; // Par d√©faut sur macOS
    {$ELSE}
    // Linux/Unix : sensible √† la casse
    Result := True;
    {$ENDIF}
  {$ENDIF}
end;

procedure AfficherInfoSysteme;
begin
  WriteLn('Syst√®me d''exploitation : ',
    {$IFDEF WINDOWS}'Windows'{$ENDIF}
    {$IFDEF LINUX}'Linux'{$ENDIF}
    {$IFDEF DARWIN}'macOS'{$ENDIF}
  );

  if SystemeEstSensibleCasse then
    WriteLn('Syst√®me de fichiers : SENSIBLE √† la casse')
  else
    WriteLn('Syst√®me de fichiers : INSENSIBLE √† la casse');
end;
```

## Gestion des noms de fichiers

### Comparaison portable de noms de fichiers

```pascal
uses
  SysUtils;

function ComparerNomsFichiers(const Nom1, Nom2: string): Boolean;
begin
  {$IFDEF WINDOWS}
  // Sur Windows : comparaison insensible √† la casse
  Result := CompareText(Nom1, Nom2) = 0;
  {$ELSE}
  // Sur Linux : comparaison sensible √† la casse
  Result := CompareStr(Nom1, Nom2) = 0;
  {$ENDIF}
end;

// Version plus flexible avec param√®tre
function ComparerNomsFichiersEx(const Nom1, Nom2: string;
                                RespectCasse: Boolean): Boolean;
begin
  if RespectCasse then
    Result := CompareStr(Nom1, Nom2) = 0    // Sensible √† la casse
  else
    Result := CompareText(Nom1, Nom2) = 0;  // Insensible √† la casse
end;

// Utilisation
procedure TesterComparaison;
begin
  WriteLn('Test.txt = test.txt ? ',
          ComparerNomsFichiers('Test.txt', 'test.txt'));
  // Windows : True
  // Linux : False
end;
```

### Recherche de fichiers robuste

```pascal
uses
  SysUtils, Classes;

function TrouverFichier(const Repertoire, NomRecherche: string): string;
var
  sr: TSearchRec;
  trouve: Boolean;
begin
  Result := '';
  trouve := False;

  if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*',
               faAnyFile, sr) = 0 then
  begin
    try
      repeat
        {$IFDEF WINDOWS}
        // Comparaison insensible sur Windows
        if CompareText(sr.Name, NomRecherche) = 0 then
        {$ELSE}
        // Comparaison sensible sur Linux
        if CompareStr(sr.Name, NomRecherche) = 0 then
        {$ENDIF}
        begin
          Result := sr.Name; // Retourne le nom r√©el
          trouve := True;
        end;
      until trouve or (FindNext(sr) <> 0);
    finally
      FindClose(sr);
    end;
  end;
end;

function TrouverFichierFlexible(const Repertoire, NomRecherche: string): string;
var
  sr: TSearchRec;
  correspondances: TStringList;
begin
  Result := '';
  correspondances := TStringList.Create;
  try
    // Rechercher toutes les correspondances possibles
    if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*',
                 faAnyFile, sr) = 0 then
    begin
      try
        repeat
          // Correspondance exacte (sensible √† la casse)
          if CompareStr(sr.Name, NomRecherche) = 0 then
          begin
            Result := sr.Name;
            Exit; // Priorit√© √† la correspondance exacte
          end;

          // Correspondance insensible √† la casse
          if CompareText(sr.Name, NomRecherche) = 0 then
            correspondances.Add(sr.Name);

        until FindNext(sr) <> 0;
      finally
        FindClose(sr);
      end;
    end;

    // Si pas de correspondance exacte, prendre la premi√®re insensible
    if (Result = '') and (correspondances.Count > 0) then
      Result := correspondances[0];

    // Avertir s'il y a plusieurs correspondances
    if correspondances.Count > 1 then
      WriteLn('Attention : plusieurs fichiers correspondent √† "',
              NomRecherche, '" avec des casses diff√©rentes');
  finally
    correspondances.Free;
  end;
end;
```

### Normalisation des noms de fichiers

```pascal
type
  TNormalisationMode = (nmAucune, nmMinuscules, nmMajuscules, nmTitre);

function NormaliserNomFichier(const NomFichier: string;
                              Mode: TNormalisationMode = nmMinuscules): string;
var
  nom, extension: string;
begin
  nom := ChangeFileExt(NomFichier, '');
  extension := ExtractFileExt(NomFichier);

  case Mode of
    nmMinuscules:
      Result := LowerCase(nom) + LowerCase(extension);

    nmMajuscules:
      Result := UpperCase(nom) + UpperCase(extension);

    nmTitre:
      begin
        // Premi√®re lettre en majuscule, reste en minuscules
        if Length(nom) > 0 then
          nom := UpperCase(nom[1]) + LowerCase(Copy(nom, 2, MaxInt));
        Result := nom + LowerCase(extension);
      end;

    else
      Result := NomFichier;
  end;
end;

procedure NormaliserTousFichiers(const Repertoire: string);
var
  sr: TSearchRec;
  ancienNom, nouveauNom: string;
begin
  WriteLn('Normalisation des fichiers dans : ', Repertoire);

  if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*.*',
               faAnyFile and not faDirectory, sr) = 0 then
  begin
    try
      repeat
        ancienNom := IncludeTrailingPathDelimiter(Repertoire) + sr.Name;
        nouveauNom := IncludeTrailingPathDelimiter(Repertoire) +
                     NormaliserNomFichier(sr.Name, nmMinuscules);

        if ancienNom <> nouveauNom then
        begin
          {$IFDEF WINDOWS}
          // Sur Windows, simple renommage
          if RenameFile(ancienNom, nouveauNom) then
            WriteLn('  ', sr.Name, ' -> ', ExtractFileName(nouveauNom))
          else
            WriteLn('  Erreur lors du renommage de ', sr.Name);
          {$ELSE}
          // Sur Linux, v√©rifier qu'on n'√©crase pas un fichier existant
          if not FileExists(nouveauNom) then
          begin
            if RenameFile(ancienNom, nouveauNom) then
              WriteLn('  ', sr.Name, ' -> ', ExtractFileName(nouveauNom))
            else
              WriteLn('  Erreur lors du renommage de ', sr.Name);
          end
          else
            WriteLn('  Conflit : ', nouveauNom, ' existe d√©j√† !');
          {$ENDIF}
        end;
      until FindNext(sr) <> 0;
    finally
      FindClose(sr);
    end;
  end;
end;
```

## Gestion des chemins complets

### Validation cross-platform des chemins

```pascal
uses
  SysUtils, StrUtils;

function ValiderCheminPortable(const Chemin: string): Boolean;
var
  elements: TStringArray;
  i: Integer;
  element: string;
begin
  Result := True;

  // D√©composer le chemin en √©l√©ments
  elements := SplitString(Chemin, PathDelim);

  for i := 0 to High(elements) do
  begin
    element := elements[i];

    // Ignorer les √©l√©ments vides
    if element = '' then
      Continue;

    {$IFDEF WINDOWS}
    // Sur Windows, v√©rifier les caract√®res interdits
    if ContainsAny(element, ['<', '>', ':', '"', '|', '?', '*']) then
    begin
      WriteLn('Caract√®re interdit dans : ', element);
      Result := False;
    end;
    {$ENDIF}

    // Avertir si le nom diff√®re seulement par la casse
    if i > 0 then
    begin
      for var j := 0 to i - 1 do
      begin
        if CompareText(elements[j], element) = 0 then
        begin
          if CompareStr(elements[j], element) <> 0 then
          begin
            WriteLn('Attention : √©l√©ments similaires avec casse diff√©rente : ',
                   elements[j], ' et ', element);
            {$IFDEF UNIX}
            // Sur Unix, c'est valide mais peut √™tre confus
            WriteLn('  (Valide sur Linux mais peut causer confusion)');
            {$ELSE}
            // Sur Windows, c'est un probl√®me
            WriteLn('  (Probl√©matique sur Windows)');
            Result := False;
            {$ENDIF}
          end;
        end;
      end;
    end;
  end;
end;

function CorrigerCheminPourOS(const Chemin: string): string;
var
  elements: TStringArray;
  i: Integer;
begin
  Result := Chemin;

  {$IFDEF WINDOWS}
  // Sur Windows, normaliser en minuscules pour √©viter les probl√®mes
  // mais pr√©server le premier √©l√©ment s'il contient un lecteur
  elements := SplitString(Chemin, PathDelim);

  for i := 0 to High(elements) do
  begin
    if (i = 0) and (Pos(':', elements[i]) > 0) then
      Continue; // Garder le lecteur tel quel (C:, D:, etc.)
    else
      elements[i] := LowerCase(elements[i]);
  end;

  Result := JoinStrings(elements, PathDelim);
  {$ENDIF}

  // Nettoyer les doubles s√©parateurs
  Result := StringReplace(Result, PathDelim + PathDelim, PathDelim,
                         [rfReplaceAll]);
end;
```

## Recherche et filtrage

### Recherche de fichiers avec patterns

```pascal
uses
  SysUtils, Classes, Masks;

type
  TRechercheOptions = set of (roSensibleCasse, roRecursif, roFichiersUniquement);

function RechercherFichiers(const Repertoire, Pattern: string;
                           Options: TRechercheOptions = []): TStringList;
var
  masque: TMask;
  sr: TSearchRec;

  procedure RechercherDansRepertoire(const Rep: string);
  var
    srLocal: TSearchRec;
    nomCompare: string;
  begin
    // Rechercher les fichiers
    if FindFirst(IncludeTrailingPathDelimiter(Rep) + '*',
                 faAnyFile, srLocal) = 0 then
    begin
      try
        repeat
          // Ignorer . et ..
          if (srLocal.Name = '.') or (srLocal.Name = '..') then
            Continue;

          // Pr√©parer le nom pour la comparaison
          if roSensibleCasse in Options then
            nomCompare := srLocal.Name
          else
            nomCompare := LowerCase(srLocal.Name);

          // V√©rifier la correspondance avec le masque
          if masque.Matches(nomCompare) then
          begin
            if not ((roFichiersUniquement in Options) and
                   (srLocal.Attr and faDirectory <> 0)) then
              Result.Add(IncludeTrailingPathDelimiter(Rep) + srLocal.Name);
          end;

          // R√©cursion si demand√©e
          if (roRecursif in Options) and
             (srLocal.Attr and faDirectory <> 0) then
          begin
            RechercherDansRepertoire(IncludeTrailingPathDelimiter(Rep) +
                                   srLocal.Name);
          end;
        until FindNext(srLocal) <> 0;
      finally
        FindClose(srLocal);
      end;
    end;
  end;

begin
  Result := TStringList.Create;

  // Cr√©er le masque selon les options
  if roSensibleCasse in Options then
    masque := TMask.Create(Pattern)
  else
    masque := TMask.Create(LowerCase(Pattern));

  try
    RechercherDansRepertoire(Repertoire);
  finally
    masque.Free;
  end;
end;

// Exemple d'utilisation
procedure ExempleRecherche;
var
  fichiers: TStringList;
  i: Integer;
begin
  // Recherche insensible √† la casse (d√©faut)
  fichiers := RechercherFichiers('/home/user/documents', '*.TXT');
  try
    WriteLn('Fichiers .TXT trouv√©s (insensible) : ', fichiers.Count);
    for i := 0 to fichiers.Count - 1 do
      WriteLn('  ', fichiers[i]);
  finally
    fichiers.Free;
  end;

  // Recherche sensible √† la casse
  fichiers := RechercherFichiers('/home/user/documents', '*.TXT',
                                 [roSensibleCasse]);
  try
    WriteLn('Fichiers .TXT trouv√©s (sensible) : ', fichiers.Count);
    for i := 0 to fichiers.Count - 1 do
      WriteLn('  ', fichiers[i]);
  finally
    fichiers.Free;
  end;
end;
```

## Collections et dictionnaires

### Gestion des cl√©s sensibles √† la casse

```pascal
uses
  SysUtils, fgl, Classes;

type
  // Dictionnaire avec gestion de la casse configurable
  TDictionnaireCasse = class
  private
    FDonnees: TFPGMap<string, string>;
    FSensibleCasse: Boolean;
    function NormaliserCle(const Cle: string): string;
  public
    constructor Create(SensibleCasse: Boolean);
    destructor Destroy; override;

    procedure Ajouter(const Cle, Valeur: string);
    function Obtenir(const Cle: string; out Valeur: string): Boolean;
    function Contient(const Cle: string): Boolean;
    procedure Supprimer(const Cle: string);
    procedure Lister;
  end;

constructor TDictionnaireCasse.Create(SensibleCasse: Boolean);
begin
  FDonnees := TFPGMap<string, string>.Create;
  FSensibleCasse := SensibleCasse;
end;

destructor TDictionnaireCasse.Destroy;
begin
  FDonnees.Free;
  inherited;
end;

function TDictionnaireCasse.NormaliserCle(const Cle: string): string;
begin
  if FSensibleCasse then
    Result := Cle
  else
    Result := LowerCase(Cle);
end;

procedure TDictionnaireCasse.Ajouter(const Cle, Valeur: string);
begin
  FDonnees.Add(NormaliserCle(Cle), Valeur);
end;

function TDictionnaireCasse.Obtenir(const Cle: string; out Valeur: string): Boolean;
var
  index: Integer;
begin
  index := FDonnees.IndexOf(NormaliserCle(Cle));
  Result := index >= 0;
  if Result then
    Valeur := FDonnees.Data[index];
end;

function TDictionnaireCasse.Contient(const Cle: string): Boolean;
begin
  Result := FDonnees.IndexOf(NormaliserCle(Cle)) >= 0;
end;

procedure TDictionnaireCasse.Supprimer(const Cle: string);
var
  index: Integer;
begin
  index := FDonnees.IndexOf(NormaliserCle(Cle));
  if index >= 0 then
    FDonnees.Delete(index);
end;

procedure TDictionnaireCasse.Lister;
var
  i: Integer;
begin
  WriteLn('Contenu du dictionnaire (',
          IfThen(FSensibleCasse, 'sensible', 'insensible'), ' √† la casse):');
  for i := 0 to FDonnees.Count - 1 do
    WriteLn('  ', FDonnees.Keys[i], ' = ', FDonnees.Data[i]);
end;

// Test
procedure TesterDictionnaire;
var
  dict: TDictionnaireCasse;
  valeur: string;
begin
  // Dictionnaire insensible √† la casse (style Windows)
  dict := TDictionnaireCasse.Create(False);
  try
    dict.Ajouter('Config', 'valeur1');
    dict.Ajouter('CONFIG', 'valeur2'); // √âcrase la pr√©c√©dente
    dict.Ajouter('config', 'valeur3'); // √âcrase aussi

    if dict.Obtenir('CoNfIg', valeur) then
      WriteLn('Trouv√© : ', valeur); // Affiche "valeur3"

    dict.Lister;
  finally
    dict.Free;
  end;

  // Dictionnaire sensible √† la casse (style Linux)
  dict := TDictionnaireCasse.Create(True);
  try
    dict.Ajouter('Config', 'valeur1');
    dict.Ajouter('CONFIG', 'valeur2'); // Cl√© diff√©rente
    dict.Ajouter('config', 'valeur3'); // Encore diff√©rente

    if not dict.Obtenir('CoNfIg', valeur) then
      WriteLn('Non trouv√© : CoNfIg'); // N'existe pas

    dict.Lister; // Affiche les 3 entr√©es
  finally
    dict.Free;
  end;
end;
```

## Configuration et fichiers INI

### Gestion portable des fichiers de configuration

```pascal
uses
  IniFiles, SysUtils;

type
  TIniPortable = class(TIniFile)
  private
    FSensibleCasse: Boolean;
    function NormaliserNom(const Nom: string): string;
  public
    constructor Create(const NomFichier: string; SensibleCasse: Boolean = False);

    function ReadString(const Section, Ident, Default: string): string; override;
    procedure WriteString(const Section, Ident, Value: string); override;
    function SectionExists(const Section: string): Boolean; override;
    function ValueExists(const Section, Ident: string): Boolean; override;
  end;

constructor TIniPortable.Create(const NomFichier: string; SensibleCasse: Boolean);
begin
  inherited Create(NomFichier);

  {$IFDEF WINDOWS}
  FSensibleCasse := False; // Forcer insensible sur Windows
  {$ELSE}
  FSensibleCasse := SensibleCasse;
  {$ENDIF}
end;

function TIniPortable.NormaliserNom(const Nom: string): string;
begin
  if FSensibleCasse then
    Result := Nom
  else
    Result := LowerCase(Nom);
end;

function TIniPortable.ReadString(const Section, Ident, Default: string): string;
begin
  Result := inherited ReadString(NormaliserNom(Section),
                                 NormaliserNom(Ident),
                                 Default);
end;

procedure TIniPortable.WriteString(const Section, Ident, Value: string);
begin
  inherited WriteString(NormaliserNom(Section),
                       NormaliserNom(Ident),
                       Value);
end;

function TIniPortable.SectionExists(const Section: string): Boolean;
begin
  Result := inherited SectionExists(NormaliserNom(Section));
end;

function TIniPortable.ValueExists(const Section, Ident: string): Boolean;
begin
  Result := inherited ValueExists(NormaliserNom(Section),
                                  NormaliserNom(Ident));
end;

// Utilisation
procedure GererConfiguration;
var
  ini: TIniPortable;
begin
  ini := TIniPortable.Create('config.ini', False); // Insensible √† la casse
  try
    // Ces trois appels acc√®dent √† la m√™me valeur
    ini.WriteString('DATABASE', 'server', 'localhost');
    WriteLn(ini.ReadString('Database', 'Server', '')); // localhost
    WriteLn(ini.ReadString('database', 'SERVER', '')); // localhost
  finally
    ini.Free;
  end;
end;
```

## Base de donn√©es et requ√™tes SQL

### Requ√™tes SQL portables

```pascal
uses
  SQLdb, SysUtils;

type
  TRequetePortable = class
  private
    FConnection: TSQLConnection;
    function QuoterIdentifiant(const Nom: string): string;
  public
    constructor Create(Connection: TSQLConnection);
    function ExecuterSelect(const Table, Colonne: string;
                           const Condition: string = ''): TSQLQuery;
  end;

function TRequetePortable.QuoterIdentifiant(const Nom: string): string;
begin
  // Selon le type de base de donn√©es
  if FConnection is TPQConnection then
  begin
    // PostgreSQL : sensible √† la casse si entre guillemets
    Result := '"' + Nom + '"';
  end
  else if FConnection is TMySQL57Connection then
  begin
    // MySQL : d√©pend de la configuration, utiliser backticks
    Result := '`' + Nom + '`';
  end
  else if FConnection is TSQLite3Connection then
  begin
    // SQLite : insensible par d√©faut
    Result := '"' + Nom + '"';
  end
  else
  begin
    // Par d√©faut
    Result := Nom;
  end;
end;

function TRequetePortable.ExecuterSelect(const Table, Colonne: string;
                                        const Condition: string): TSQLQuery;
var
  sql: string;
begin
  Result := TSQLQuery.Create(nil);
  Result.Database := FConnection;

  // Construire la requ√™te selon la base
  if FConnection is TPQConnection then
  begin
    // PostgreSQL : utiliser ILIKE pour recherche insensible
    sql := Format('SELECT %s FROM %s',
                 [QuoterIdentifiant(Colonne), QuoterIdentifiant(Table)]);
    if Condition <> '' then
      sql := sql + ' WHERE ' + StringReplace(Condition, 'LIKE', 'ILIKE',
                                             [rfReplaceAll, rfIgnoreCase]);
  end
  else if FConnection is TMySQL57Connection then
  begin
    // MySQL : d√©pend du collation
    sql := Format('SELECT %s FROM %s', [Colonne, Table]);
    if Condition <> '' then
      sql := sql + ' WHERE ' + Condition;
  end
  else
  begin
    // SQLite et autres
    sql := Format('SELECT %s FROM %s', [Colonne, Table]);
    if Condition <> '' then
      sql := sql + ' WHERE ' + Condition + ' COLLATE NOCASE';
  end;

  Result.SQL.Text := sql;
  Result.Open;
end;
```

## Probl√®mes courants et solutions

### Probl√®me 1 : Import de fichiers depuis diff√©rents OS

```pascal
function ImporterFichierPortable(const CheminOrigine: string): string;
var
  nomFichier: string;
  cheminNormalise: string;
begin
  nomFichier := ExtractFileName(CheminOrigine);

  {$IFDEF WINDOWS}
  // Sur Windows, normaliser en minuscules
  nomFichier := LowerCase(nomFichier);
  {$ENDIF}

  // Remplacer les caract√®res probl√©matiques
  nomFichier := StringReplace(nomFichier, ' ', '_', [rfReplaceAll]);
  nomFichier := StringReplace(nomFichier, '&', 'and', [rfReplaceAll]);

  // G√©n√©rer un nom unique si n√©cessaire
  cheminNormalise := IncludeTrailingPathDelimiter(GetCurrentDir) + nomFichier;

  if FileExists(cheminNormalise) then
  begin
    // Ajouter un timestamp pour √©viter les conflits
    cheminNormalise := ChangeFileExt(cheminNormalise, '') + '_' +
                      FormatDateTime('yyyymmdd_hhnnss', Now) +
                      ExtractFileExt(nomFichier);
  end;

  Result := cheminNormalise;
  WriteLn('Import : ', CheminOrigine, ' -> ', Result);
end;
```

### Probl√®me 2 : Synchronisation de fichiers

```pascal
type
  TSyncDirection = (sdWindowsVersLinux, sdLinuxVersWindows, sdBidirectionnel);

procedure SynchroniserRepertoires(const RepSource, RepDest: string;
                                 Direction: TSyncDirection);
var
  fichiersSource, fichiersDest: TStringList;
  i, j: Integer;
  trouve: Boolean;
  nomSource, nomDest: string;
begin
  fichiersSource := TStringList.Create;
  fichiersDest := TStringList.Create;
  try
    // Lister les fichiers source
    ListerFichiers(RepSource, fichiersSource);
    ListerFichiers(RepDest, fichiersDest);

    for i := 0 to fichiersSource.Count - 1 do
    begin
      nomSource := ExtractFileName(fichiersSource[i]);
      trouve := False;

      for j := 0 to fichiersDest.Count - 1 do
      begin
        nomDest := ExtractFileName(fichiersDest[j]);

        case Direction of
          sdWindowsVersLinux:
            // Windows -> Linux : comparaison insensible c√¥t√© source
            trouve := CompareText(nomSource, nomDest) = 0;

          sdLinuxVersWindows:
            // Linux -> Windows : comparaison sensible c√¥t√© source
            trouve := CompareStr(nomSource, nomDest) = 0;

          sdBidirectionnel:
            // Comparaison adaptative selon le syst√®me actuel
            {$IFDEF WINDOWS}
            trouve := CompareText(nomSource, nomDest) = 0;
            {$ELSE}
            trouve := CompareStr(nomSource, nomDest) = 0;
            {$ENDIF}
        end;

        if trouve then
          Break;
      end;

      if not trouve then
      begin
        // Copier le fichier manquant
        CopierFichierPortable(fichiersSource[i], RepDest, Direction);
      end;
    end;
  finally
    fichiersSource.Free;
    fichiersDest.Free;
  end;
end;

procedure CopierFichierPortable(const Source, RepDest: string;
                               Direction: TSyncDirection);
var
  nomFichier, destPath: string;
  conflits: TStringList;
begin
  nomFichier := ExtractFileName(Source);

  // G√©rer les conflits potentiels de casse
  case Direction of
    sdWindowsVersLinux:
      begin
        // V√©rifier les conflits potentiels sur Linux
        conflits := TrouverConflitsCasse(RepDest, nomFichier);
        try
          if conflits.Count > 0 then
          begin
            WriteLn('ATTENTION : Conflit de casse d√©tect√© !');
            WriteLn('  Fichier source : ', nomFichier);
            WriteLn('  Fichiers existants : ', conflits.CommaText);

            // Renommer avec suffix pour √©viter le conflit
            nomFichier := ChangeFileExt(nomFichier, '') + '_win' +
                         ExtractFileExt(nomFichier);
            WriteLn('  Renomm√© en : ', nomFichier);
          end;
        finally
          conflits.Free;
        end;
      end;

    sdLinuxVersWindows:
      begin
        // Sur Windows, normaliser le nom
        nomFichier := NormaliserPourWindows(nomFichier);
      end;
  end;

  destPath := IncludeTrailingPathDelimiter(RepDest) + nomFichier;

  if CopyFile(PChar(Source), PChar(destPath), False) then
    WriteLn('Copi√© : ', ExtractFileName(Source), ' -> ', destPath)
  else
    WriteLn('Erreur lors de la copie de : ', ExtractFileName(Source));
end;

function TrouverConflitsCasse(const Repertoire, NomFichier: string): TStringList;
var
  sr: TSearchRec;
begin
  Result := TStringList.Create;

  if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*',
               faAnyFile, sr) = 0 then
  begin
    try
      repeat
        // Chercher les fichiers avec m√™me nom mais casse diff√©rente
        if (CompareText(sr.Name, NomFichier) = 0) and
           (CompareStr(sr.Name, NomFichier) <> 0) then
        begin
          Result.Add(sr.Name);
        end;
      until FindNext(sr) <> 0;
    finally
      FindClose(sr);
    end;
  end;
end;

function NormaliserPourWindows(const NomFichier: string): string;
var
  base, ext: string;
begin
  base := ChangeFileExt(NomFichier, '');
  ext := ExtractFileExt(NomFichier);

  // Convertir en minuscules et remplacer les espaces
  Result := LowerCase(StringReplace(base, ' ', '_', [rfReplaceAll])) +
            LowerCase(ext);
end;
```

### Probl√®me 3 : Gestion des liens symboliques

```pascal
{$IFDEF UNIX}
uses
  BaseUnix, Unix;
{$ENDIF}

procedure GererLiensSymboliques(const Chemin: string);
{$IFDEF UNIX}
var
  info: Stat;
  cible: string;
  buffer: array[0..1023] of Char;
  taille: Integer;
begin
  // V√©rifier si c'est un lien symbolique
  if fpLstat(Chemin, info) = 0 then
  begin
    if fpS_ISLNK(info.st_mode) then
    begin
      WriteLn('Lien symbolique d√©tect√© : ', Chemin);

      // Lire la cible du lien
      taille := fpReadLink(PChar(Chemin), @buffer[0], SizeOf(buffer));
      if taille > 0 then
      begin
        SetString(cible, buffer, taille);
        WriteLn('  Pointe vers : ', cible);

        // V√©rifier la sensibilit√© √† la casse de la cible
        if not FileExists(cible) then
        begin
          WriteLn('  ATTENTION : La cible n''existe pas !');
          WriteLn('  V√©rifier la casse du chemin cible');

          // Essayer de trouver une correspondance
          var cibleCorrigee := TrouverFichierAvecCasse(ExtractFilePath(cible),
                                                       ExtractFileName(cible));
          if cibleCorrigee <> '' then
            WriteLn('  Suggestion : ', cibleCorrigee);
        end;
      end;
    end;
  end;
end;
{$ELSE}
begin
  // Windows : les liens symboliques sont diff√©rents
  WriteLn('Gestion des liens symboliques non impl√©ment√©e sur Windows');
end;
{$ENDIF}

function TrouverFichierAvecCasse(const Repertoire, NomRecherche: string): string;
var
  sr: TSearchRec;
  meilleurScore: Integer;
  score: Integer;
begin
  Result := '';
  meilleurScore := MaxInt;

  if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*',
               faAnyFile, sr) = 0 then
  begin
    try
      repeat
        // Calculer un score de similarit√©
        score := LevenshteinDistance(LowerCase(sr.Name),
                                     LowerCase(NomRecherche));

        if score < meilleurScore then
        begin
          meilleurScore := score;
          Result := IncludeTrailingPathDelimiter(Repertoire) + sr.Name;
        end;

        // Correspondance exacte insensible √† la casse
        if CompareText(sr.Name, NomRecherche) = 0 then
        begin
          Result := IncludeTrailingPathDelimiter(Repertoire) + sr.Name;
          Break;
        end;
      until FindNext(sr) <> 0;
    finally
      FindClose(sr);
    end;
  end;
end;

// Calcul de la distance de Levenshtein pour la similarit√©
function LevenshteinDistance(const S1, S2: string): Integer;
var
  i, j: Integer;
  matrice: array of array of Integer;
begin
  SetLength(matrice, Length(S1) + 1, Length(S2) + 1);

  for i := 0 to Length(S1) do
    matrice[i, 0] := i;

  for j := 0 to Length(S2) do
    matrice[0, j] := j;

  for i := 1 to Length(S1) do
    for j := 1 to Length(S2) do
      if S1[i] = S2[j] then
        matrice[i, j] := matrice[i-1, j-1]
      else
        matrice[i, j] := 1 + Min(Min(matrice[i-1, j],
                                     matrice[i, j-1]),
                                     matrice[i-1, j-1]);

  Result := matrice[Length(S1), Length(S2)];
end;
```

## D√©veloppement d'applications robustes

### Classe de gestion unifi√©e

```pascal
type
  TGestionnaireFichierPortable = class
  private
    FModeStricte: Boolean;
    FJournalConflits: TStringList;

    function EstConflitCasse(const Chemin1, Chemin2: string): Boolean;
    procedure EnregistrerConflit(const Message: string);

  public
    constructor Create(ModeStricte: Boolean = False);
    destructor Destroy; override;

    function OuvrirFichier(const NomFichier: string;
                          out Stream: TFileStream): Boolean;
    function CreerFichier(const NomFichier: string): TFileStream;
    function RenommerFichier(const Ancien, Nouveau: string): Boolean;
    function SupprimerFichier(const NomFichier: string): Boolean;

    procedure VerifierRepertoire(const Repertoire: string);
    function ObtenirConflits: TStringList;

    property ModeStricte: Boolean read FModeStricte write FModeStricte;
  end;

constructor TGestionnaireFichierPortable.Create(ModeStricte: Boolean);
begin
  FModeStricte := ModeStricte;
  FJournalConflits := TStringList.Create;
end;

destructor TGestionnaireFichierPortable.Destroy;
begin
  FJournalConflits.Free;
  inherited;
end;

function TGestionnaireFichierPortable.EstConflitCasse(const Chemin1, Chemin2: string): Boolean;
begin
  Result := (CompareText(Chemin1, Chemin2) = 0) and
            (CompareStr(Chemin1, Chemin2) <> 0);
end;

procedure TGestionnaireFichierPortable.EnregistrerConflit(const Message: string);
begin
  FJournalConflits.Add(FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' | ' + Message);

  if FModeStricte then
    raise Exception.Create('Conflit de casse d√©tect√© : ' + Message);
end;

function TGestionnaireFichierPortable.OuvrirFichier(const NomFichier: string;
                                                   out Stream: TFileStream): Boolean;
var
  fichierReel: string;
begin
  Result := False;
  Stream := nil;

  // V√©rifier l'existence exacte
  if FileExists(NomFichier) then
  begin
    Stream := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
    Result := True;
  end
  else
  begin
    // Chercher une variante de casse
    fichierReel := TrouverFichierFlexible(ExtractFilePath(NomFichier),
                                          ExtractFileName(NomFichier));

    if fichierReel <> '' then
    begin
      if not EstConflitCasse(NomFichier, fichierReel) then
      begin
        Stream := TFileStream.Create(fichierReel, fmOpenRead or fmShareDenyWrite);
        Result := True;
      end
      else
      begin
        EnregistrerConflit(Format('Tentative d''ouverture de "%s", trouv√© "%s"',
                                 [NomFichier, fichierReel]));

        if not FModeStricte then
        begin
          // En mode non strict, ouvrir quand m√™me
          Stream := TFileStream.Create(fichierReel, fmOpenRead or fmShareDenyWrite);
          Result := True;
        end;
      end;
    end;
  end;
end;

function TGestionnaireFichierPortable.CreerFichier(const NomFichier: string): TFileStream;
var
  conflits: TStringList;
begin
  // V√©rifier les conflits potentiels avant cr√©ation
  conflits := TrouverConflitsCasse(ExtractFilePath(NomFichier),
                                   ExtractFileName(NomFichier));
  try
    if conflits.Count > 0 then
    begin
      EnregistrerConflit(Format('Cr√©ation de "%s" avec conflits existants : %s',
                               [NomFichier, conflits.CommaText]));

      if FModeStricte then
        Exit(nil);
    end;
  finally
    conflits.Free;
  end;

  Result := TFileStream.Create(NomFichier, fmCreate);
end;

function TGestionnaireFichierPortable.RenommerFichier(const Ancien, Nouveau: string): Boolean;
begin
  Result := False;

  // V√©rifier si c'est juste un changement de casse
  if EstConflitCasse(Ancien, Nouveau) then
  begin
    {$IFDEF WINDOWS}
    // Sur Windows, renommage direct possible
    Result := RenameFile(Ancien, Nouveau);
    {$ELSE}
    // Sur Linux, n√©cessite un nom temporaire
    var temp := Ancien + '.tmp';
    Result := RenameFile(Ancien, temp) and RenameFile(temp, Nouveau);
    {$ENDIF}

    if Result then
      WriteLn('Changement de casse : ', Ancien, ' -> ', Nouveau);
  end
  else
  begin
    // Renommage normal
    if FileExists(Nouveau) then
    begin
      EnregistrerConflit(Format('Le fichier destination existe d√©j√† : %s',
                               [Nouveau]));
      Exit(False);
    end;

    Result := RenameFile(Ancien, Nouveau);
  end;
end;

function TGestionnaireFichierPortable.SupprimerFichier(const NomFichier: string): Boolean;
var
  fichierReel: string;
begin
  if FileExists(NomFichier) then
  begin
    Result := DeleteFile(NomFichier);
  end
  else
  begin
    // Chercher avec casse diff√©rente
    fichierReel := TrouverFichierFlexible(ExtractFilePath(NomFichier),
                                          ExtractFileName(NomFichier));

    if fichierReel <> '' then
    begin
      if EstConflitCasse(NomFichier, fichierReel) then
        EnregistrerConflit(Format('Suppression avec casse diff√©rente : demand√© "%s", trouv√© "%s"',
                                 [NomFichier, fichierReel]));

      Result := DeleteFile(fichierReel);
    end
    else
      Result := False;
  end;
end;

procedure TGestionnaireFichierPortable.VerifierRepertoire(const Repertoire: string);
var
  fichiers: TStringList;
  i, j: Integer;
begin
  fichiers := TStringList.Create;
  try
    ListerFichiers(Repertoire, fichiers);

    WriteLn('V√©rification du r√©pertoire : ', Repertoire);
    WriteLn('Nombre de fichiers : ', fichiers.Count);

    // Chercher les conflits potentiels
    for i := 0 to fichiers.Count - 2 do
    begin
      for j := i + 1 to fichiers.Count - 1 do
      begin
        if EstConflitCasse(ExtractFileName(fichiers[i]),
                          ExtractFileName(fichiers[j])) then
        begin
          EnregistrerConflit(Format('Fichiers similaires : "%s" et "%s"',
                                   [fichiers[i], fichiers[j]]));
        end;
      end;
    end;

    if FJournalConflits.Count > 0 then
    begin
      WriteLn('ATTENTION : ', FJournalConflits.Count, ' conflit(s) d√©tect√©(s)');
      {$IFDEF WINDOWS}
      WriteLn('  Ces fichiers seront confondus sur Windows');
      {$ELSE}
      WriteLn('  Ces fichiers causeront des probl√®mes sur Windows');
      {$ENDIF}
    end
    else
      WriteLn('Aucun conflit de casse d√©tect√©');

  finally
    fichiers.Free;
  end;
end;

function TGestionnaireFichierPortable.ObtenirConflits: TStringList;
begin
  Result := TStringList.Create;
  Result.Assign(FJournalConflits);
end;
```

## Bonnes pratiques pour le d√©veloppement multi-plateforme

### 1. Toujours utiliser des noms en minuscules

```pascal
// ‚úÖ BON : Noms en minuscules
const
  CONFIG_FILE = 'config.ini';
  LOG_FILE = 'application.log';
  DATA_DIR = 'data';

// ‚ùå MAUVAIS : Casse mixte
const
  CONFIG_FILE = 'Config.ini';
  LOG_FILE = 'Application.Log';
  DATA_DIR = 'Data';
```

### 2. Utiliser des fonctions de comparaison appropri√©es

```pascal
// ‚úÖ BON : Fonction adaptative
function ComparerFichiers(const F1, F2: string): Boolean;
begin
  {$IFDEF WINDOWS}
  Result := CompareText(F1, F2) = 0;
  {$ELSE}
  Result := CompareStr(F1, F2) = 0;
  {$ENDIF}
end;

// ‚ùå MAUVAIS : Comparaison directe
if Fichier1 = Fichier2 then  // D√©pend des param√®tres du compilateur
  DoSomething;
```

### 3. Valider les noms de fichiers √† la cr√©ation

```pascal
function ValiderNomFichier(const Nom: string): Boolean;
var
  i: Integer;
begin
  Result := True;

  // V√©rifier la longueur
  if Length(Nom) = 0 then
    Exit(False);

  // V√©rifier les caract√®res interdits
  for i := 1 to Length(Nom) do
  begin
    if Nom[i] in ['/', '\', ':', '*', '?', '"', '<', '>', '|'] then
      Exit(False);
  end;

  // Avertir pour la casse mixte
  if (LowerCase(Nom) <> Nom) and (UpperCase(Nom) <> Nom) then
    WriteLn('Attention : nom avec casse mixte "', Nom, '"');
end;
```

### 4. Impl√©menter une couche d'abstraction

```pascal
type
  ISystemeFichier = interface
    function OuvrirFichier(const Nom: string): TStream;
    function CreerFichier(const Nom: string): TStream;
    function FichierExiste(const Nom: string): Boolean;
    function RenommerFichier(const Ancien, Nouveau: string): Boolean;
  end;

  TSystemeFichierWindows = class(TInterfacedObject, ISystemeFichier)
    // Impl√©mentation sp√©cifique Windows (insensible √† la casse)
  end;

  TSystemeFichierLinux = class(TInterfacedObject, ISystemeFichier)
    // Impl√©mentation sp√©cifique Linux (sensible √† la casse)
  end;

function CreerSystemeFichier: ISystemeFichier;
begin
  {$IFDEF WINDOWS}
  Result := TSystemeFichierWindows.Create;
  {$ELSE}
  Result := TSystemeFichierLinux.Create;
  {$ENDIF}
end;
```

### 5. Tests automatis√©s multi-plateformes

```pascal
procedure TesterSensibiliteCasse;
var
  gestionnaire: TGestionnaireFichierPortable;
  stream: TFileStream;
begin
  WriteLn('=== Tests de sensibilit√© √† la casse ===');

  gestionnaire := TGestionnaireFichierPortable.Create(False);
  try
    // Test 1 : Cr√©ation avec casses diff√©rentes
    stream := gestionnaire.CreerFichier('test.txt');
    stream.Free;

    {$IFDEF WINDOWS}
    // Sur Windows, devrait √©chouer ou √©craser
    Assert(not FileExists('Test.txt') or FileExists('test.txt'));
    {$ELSE}
    // Sur Linux, peut cr√©er deux fichiers diff√©rents
    stream := gestionnaire.CreerFichier('Test.txt');
    stream.Free;
    Assert(FileExists('test.txt') and FileExists('Test.txt'));
    {$ENDIF}

    // Test 2 : Ouverture avec casse diff√©rente
    if gestionnaire.OuvrirFichier('TEST.txt', stream) then
    begin
      {$IFDEF WINDOWS}
      WriteLn('‚úì Windows : ouverture insensible √† la casse OK');
      {$ELSE}
      WriteLn('‚ö† Linux : ouverture avec casse diff√©rente (mode non strict)');
      {$ENDIF}
      stream.Free;
    end;

    // Nettoyer
    DeleteFile('test.txt');
    {$IFDEF UNIX}
    DeleteFile('Test.txt');
    {$ENDIF}

  finally
    gestionnaire.Free;
  end;
end;
```

## Exemple complet : Gestionnaire de projet portable

```pascal
program GestionnaireProjetPortable;

uses
  SysUtils, Classes;

type
  TProjet = class
  private
    FNom: string;
    FFichiers: TStringList;
    FCheminBase: string;
    FSensibleCasse: Boolean;

    function NormaliserChemin(const Chemin: string): string;

  public
    constructor Create(const Nom, CheminBase: string);
    destructor Destroy; override;

    procedure AjouterFichier(const NomFichier: string);
    function TrouverFichier(const NomFichier: string): string;
    procedure ListerFichiers;
    procedure VerifierCoherence;
    procedure SauvegarderManifeste(const NomFichier: string);
    procedure ChargerManifeste(const NomFichier: string);
  end;

constructor TProjet.Create(const Nom, CheminBase: string);
begin
  FNom := Nom;
  FCheminBase := IncludeTrailingPathDelimiter(CheminBase);
  FFichiers := TStringList.Create;

  {$IFDEF WINDOWS}
  FSensibleCasse := False;
  FFichiers.CaseSensitive := False;
  {$ELSE}
  FSensibleCasse := True;
  FFichiers.CaseSensitive := True;
  {$ENDIF}

  FFichiers.Sorted := True;
  FFichiers.Duplicates := dupError;
end;

destructor TProjet.Destroy;
begin
  FFichiers.Free;
  inherited;
end;

function TProjet.NormaliserChemin(const Chemin: string): string;
begin
  Result := Chemin;

  // Remplacer les s√©parateurs
  Result := StringReplace(Result, '\', PathDelim, [rfReplaceAll]);
  Result := StringReplace(Result, '/', PathDelim, [rfReplaceAll]);

  {$IFDEF WINDOWS}
  // Sur Windows, normaliser en minuscules
  Result := LowerCase(Result);
  {$ENDIF}
end;

procedure TProjet.AjouterFichier(const NomFichier: string);
var
  cheminComplet, cheminNormalise: string;
begin
  cheminComplet := FCheminBase + NomFichier;
  cheminNormalise := NormaliserChemin(NomFichier);

  if not FileExists(cheminComplet) then
  begin
    WriteLn('Erreur : fichier introuvable : ', cheminComplet);
    Exit;
  end;

  try
    FFichiers.Add(cheminNormalise);
    WriteLn('Fichier ajout√© : ', cheminNormalise);
  except
    on E: EStringListError do
      WriteLn('Erreur : fichier d√©j√† dans le projet (ou conflit de casse)');
  end;
end;

function TProjet.TrouverFichier(const NomFichier: string): string;
var
  index: Integer;
  normalise: string;
begin
  normalise := NormaliserChemin(NomFichier);
  index := FFichiers.IndexOf(normalise);

  if index >= 0 then
    Result := FFichiers[index]
  else
    Result := '';
end;

procedure TProjet.ListerFichiers;
var
  i: Integer;
begin
  WriteLn('Projet : ', FNom);
  WriteLn('Chemin de base : ', FCheminBase);
  WriteLn('Mode : ', IfThen(FSensibleCasse, 'Sensible', 'Insensible'),
          ' √† la casse');
  WriteLn('Fichiers (', FFichiers.Count, ') :');

  for i := 0 to FFichiers.Count - 1 do
    WriteLn('  ', FFichiers[i]);
end;

procedure TProjet.VerifierCoherence;
var
  i, j: Integer;
  conflits: Integer;
begin
  conflits := 0;

  WriteLn('V√©rification de la coh√©rence du projet...');

  // V√©rifier l'existence de tous les fichiers
  for i := 0 to FFichiers.Count - 1 do
  begin
    if not FileExists(FCheminBase + FFichiers[i]) then
    begin
      WriteLn('  ‚ö† Fichier manquant : ', FFichiers[i]);
      Inc(conflits);
    end;
  end;

  // Sur Linux, v√©rifier les conflits potentiels pour Windows
  {$IFDEF UNIX}
  for i := 0 to FFichiers.Count - 2 do
  begin
    for j := i + 1 to FFichiers.Count - 1 do
    begin
      if CompareText(FFichiers[i], FFichiers[j]) = 0 then
      begin
        WriteLn('  ‚ö† Conflit Windows potentiel : ');
        WriteLn('    - ', FFichiers[i]);
        WriteLn('    - ', FFichiers[j]);
        Inc(conflits);
      end;
    end;
  end;
  {$ENDIF}

  if conflits = 0 then
    WriteLn('  ‚úì Projet coh√©rent et portable')
  else
    WriteLn('  ‚úó ', conflits, ' probl√®me(s) d√©tect√©(s)');
end;

procedure TProjet.SauvegarderManifeste(const NomFichier: string);
var
  manifest: TStringList;
begin
  manifest := TStringList.Create;
  try
    manifest.Add('[PROJET]');
    manifest.Add('Nom=' + FNom);
    manifest.Add('CheminBase=' + FCheminBase);
    manifest.Add('SensibleCasse=' + BoolToStr(FSensibleCasse, True));
    manifest.Add('');
    manifest.Add('[FICHIERS]');
    manifest.AddStrings(FFichiers);

    manifest.SaveToFile(NomFichier);
    WriteLn('Manifeste sauvegard√© : ', NomFichier);
  finally
    manifest.Free;
  end;
end;

procedure TProjet.ChargerManifeste(const NomFichier: string);
var
  manifest: TStringList;
  i: Integer;
  inFiles: Boolean;
begin
  if not FileExists(NomFichier) then
  begin
    WriteLn('Erreur : manifeste introuvable : ', NomFichier);
    Exit;
  end;

  manifest := TStringList.Create;
  try
    manifest.LoadFromFile(NomFichier);
    FFichiers.Clear;
    inFiles := False;

    for i := 0 to manifest.Count - 1 do
    begin
      if manifest[i] = '[FICHIERS]' then
        inFiles := True
      else if inFiles and (manifest[i] <> '') then
        FFichiers.Add(manifest[i]);
    end;

    WriteLn('Manifeste charg√© : ', FFichiers.Count, ' fichier(s)');
  finally
    manifest.Free;
  end;
end;

// Programme principal
var
  projet: TProjet;
begin
  WriteLn('=== Gestionnaire de Projet Portable ===');
  WriteLn('Syst√®me : ',
    {$IFDEF WINDOWS}'Windows (insensible √† la casse)'{$ENDIF}
    {$IFDEF LINUX}'Linux (sensible √† la casse)'{$ENDIF}
    {$IFDEF DARWIN}'macOS'{$ENDIF}
  );
  WriteLn;

  // Cr√©er un projet de test
  projet := TProjet.Create('MonProjet', GetCurrentDir);
  try
    // Test 1 : Ajouter des fichiers avec diff√©rentes casses
    WriteLn('Test 1 : Ajout de fichiers');
    WriteLn('---------------------------');

    // Cr√©er des fichiers de test
    CreerFichierTest('readme.txt', 'Documentation en minuscules');
    CreerFichierTest('README.TXT', 'Documentation en majuscules');
    CreerFichierTest('ReadMe.txt', 'Documentation en casse mixte');

    // Les ajouter au projet
    projet.AjouterFichier('readme.txt');

    {$IFDEF WINDOWS}
    // Sur Windows, les tentatives suivantes devraient √©chouer (duplicata)
    projet.AjouterFichier('README.TXT');
    projet.AjouterFichier('ReadMe.txt');
    {$ELSE}
    // Sur Linux, tous peuvent √™tre ajout√©s
    projet.AjouterFichier('README.TXT');
    projet.AjouterFichier('ReadMe.txt');
    {$ENDIF}

    WriteLn;

    // Test 2 : Recherche de fichiers
    WriteLn('Test 2 : Recherche de fichiers');
    WriteLn('-------------------------------');

    var trouve := projet.TrouverFichier('readme.txt');
    if trouve <> '' then
      WriteLn('Trouv√© (exact) : ', trouve)
    else
      WriteLn('Non trouv√© : readme.txt');

    trouve := projet.TrouverFichier('README.TXT');
    if trouve <> '' then
      WriteLn('Trouv√© (majuscules) : ', trouve)
    else
      WriteLn('Non trouv√© : README.TXT');

    trouve := projet.TrouverFichier('ReAdMe.TxT');
    if trouve <> '' then
      WriteLn('Trouv√© (casse mixte) : ', trouve)
    else
      WriteLn('Non trouv√© : ReAdMe.TxT');

    WriteLn;

    // Test 3 : Lister et v√©rifier la coh√©rence
    WriteLn('Test 3 : Liste et coh√©rence');
    WriteLn('----------------------------');
    projet.ListerFichiers;
    WriteLn;
    projet.VerifierCoherence;
    WriteLn;

    // Test 4 : Sauvegarder et recharger le manifeste
    WriteLn('Test 4 : Persistance');
    WriteLn('--------------------');
    projet.SauvegarderManifeste('projet.manifest');

    // Cr√©er un nouveau projet et charger le manifeste
    var projet2 := TProjet.Create('ProjetCharge', GetCurrentDir);
    try
      projet2.ChargerManifeste('projet.manifest');
      projet2.ListerFichiers;

      // V√©rifier que tout est coh√©rent apr√®s rechargement
      projet2.VerifierCoherence;
    finally
      projet2.Free;
    end;

    WriteLn;

    // Test 5 : Sc√©narios de portabilit√©
    WriteLn('Test 5 : Sc√©narios de portabilit√©');
    WriteLn('----------------------------------');
    TesterPortabilite;

  finally
    // Nettoyer les fichiers de test
    NettoyerFichiersTest;
    projet.Free;
  end;

  WriteLn;
  WriteLn('Tests termin√©s. Appuyez sur Entr√©e...');
  ReadLn;
end;

// Fonctions auxiliaires pour les tests

procedure CreerFichierTest(const NomFichier, Contenu: string);
var
  flux: TFileStream;
  octets: TBytes;
begin
  if FileExists(NomFichier) then
  begin
    {$IFDEF WINDOWS}
    WriteLn('  Fichier existe d√©j√† (ou variante de casse) : ', NomFichier);
    Exit;
    {$ELSE}
    WriteLn('  Cr√©ation : ', NomFichier);
    {$ENDIF}
  end
  else
    WriteLn('  Cr√©ation : ', NomFichier);

  flux := TFileStream.Create(NomFichier, fmCreate);
  try
    octets := TEncoding.UTF8.GetBytes(Contenu);
    flux.WriteBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;
end;

procedure NettoyerFichiersTest;
begin
  WriteLn('Nettoyage des fichiers de test...');

  DeleteFile('readme.txt');
  {$IFDEF UNIX}
  // Sur Unix, supprimer toutes les variantes
  DeleteFile('README.TXT');
  DeleteFile('ReadMe.txt');
  {$ENDIF}

  DeleteFile('projet.manifest');
  DeleteFile('test.txt');
  DeleteFile('Test.txt');
  DeleteFile('TEST.txt');
end;

procedure TesterPortabilite;
var
  problemes: TStringList;
begin
  problemes := TStringList.Create;
  try
    WriteLn('Analyse de portabilit√© du r√©pertoire actuel...');

    // Simuler un transfert Windows -> Linux
    {$IFDEF WINDOWS}
    WriteLn('Simulation : transfert vers Linux');
    AnalyserTransfertVersLinux(GetCurrentDir, problemes);
    {$ELSE}
    WriteLn('Simulation : transfert vers Windows');
    AnalyserTransfertVersWindows(GetCurrentDir, problemes);
    {$ENDIF}

    if problemes.Count > 0 then
    begin
      WriteLn('Probl√®mes potentiels d√©tect√©s :');
      for var i := 0 to problemes.Count - 1 do
        WriteLn('  ! ', problemes[i]);
    end
    else
      WriteLn('  ‚úì Aucun probl√®me de portabilit√© d√©tect√©');

  finally
    problemes.Free;
  end;
end;

procedure AnalyserTransfertVersLinux(const Repertoire: string;
                                     Problemes: TStringList);
var
  sr: TSearchRec;
begin
  if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*',
               faAnyFile, sr) = 0 then
  begin
    try
      repeat
        if (sr.Name = '.') or (sr.Name = '..') then
          Continue;

        // V√©rifier les caract√®res Windows interdits sur Linux
        if Pos('\', sr.Name) > 0 then
          Problemes.Add(sr.Name + ' contient un backslash');

        // Avertir pour les noms r√©serv√©s Windows
        if MatchStr(UpperCase(ChangeFileExt(sr.Name, '')),
                   ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3',
                    'COM4', 'LPT1', 'LPT2', 'LPT3']) then
          Problemes.Add(sr.Name + ' est un nom r√©serv√© Windows');

      until FindNext(sr) <> 0;
    finally
      FindClose(sr);
    end;
  end;
end;

procedure AnalyserTransfertVersWindows(const Repertoire: string;
                                       Problemes: TStringList);
var
  sr: TSearchRec;
  fichiers: TStringList;
  i, j: Integer;
begin
  fichiers := TStringList.Create;
  try
    if FindFirst(IncludeTrailingPathDelimiter(Repertoire) + '*',
                 faAnyFile, sr) = 0 then
    begin
      try
        repeat
          if (sr.Name = '.') or (sr.Name = '..') then
            Continue;

          fichiers.Add(sr.Name);

          // V√©rifier les caract√®res interdits Windows
          for i := 1 to Length(sr.Name) do
          begin
            if sr.Name[i] in ['<', '>', ':', '"', '|', '?', '*'] then
            begin
              Problemes.Add(sr.Name + ' contient "' + sr.Name[i] +
                          '" interdit sur Windows');
              Break;
            end;
          end;

        until FindNext(sr) <> 0;
      finally
        FindClose(sr);
      end;
    end;

    // Chercher les conflits de casse
    for i := 0 to fichiers.Count - 2 do
    begin
      for j := i + 1 to fichiers.Count - 1 do
      begin
        if CompareText(fichiers[i], fichiers[j]) = 0 then
        begin
          Problemes.Add(Format('Conflit de casse : "%s" et "%s" seront identiques',
                              [fichiers[i], fichiers[j]]));
        end;
      end;
    end;
  finally
    fichiers.Free;
  end;
end;
```

## Utilitaires de diagnostic et correction

### Outil de diagnostic complet

```pascal
program DiagnosticSensibiliteCasse;

uses
  SysUtils, Classes;

type
  TRapportDiagnostic = record
    NbFichiers: Integer;
    NbRepertoires: Integer;
    NbConflitsCasse: Integer;
    NbCaracteresInterdits: Integer;
    NbNomsReserves: Integer;
    Conflits: TStringList;
    Suggestions: TStringList;
  end;

function DiagnostiquerRepertoire(const Chemin: string): TRapportDiagnostic;
var
  sr: TSearchRec;
  fichiers, repertoires: TStringList;
  i, j: Integer;
begin
  Result.NbFichiers := 0;
  Result.NbRepertoires := 0;
  Result.NbConflitsCasse := 0;
  Result.NbCaracteresInterdits := 0;
  Result.NbNomsReserves := 0;
  Result.Conflits := TStringList.Create;
  Result.Suggestions := TStringList.Create;

  fichiers := TStringList.Create;
  repertoires := TStringList.Create;
  try
    // Scanner le r√©pertoire
    if FindFirst(IncludeTrailingPathDelimiter(Chemin) + '*',
                 faAnyFile, sr) = 0 then
    begin
      try
        repeat
          if (sr.Name = '.') or (sr.Name = '..') then
            Continue;

          if (sr.Attr and faDirectory) <> 0 then
          begin
            Inc(Result.NbRepertoires);
            repertoires.Add(sr.Name);
          end
          else
          begin
            Inc(Result.NbFichiers);
            fichiers.Add(sr.Name);
          end;

          // V√©rifier les caract√®res probl√©matiques
          if VerifierCaracteresInterdits(sr.Name) then
          begin
            Inc(Result.NbCaracteresInterdits);
            Result.Conflits.Add('Caract√®res interdits : ' + sr.Name);
            Result.Suggestions.Add('Renommer : ' + sr.Name + ' -> ' +
                                  NettoyerNomFichier(sr.Name));
          end;

          // V√©rifier les noms r√©serv√©s
          if EstNomReserve(sr.Name) then
          begin
            Inc(Result.NbNomsReserves);
            Result.Conflits.Add('Nom r√©serv√© : ' + sr.Name);
            Result.Suggestions.Add('Renommer : ' + sr.Name + ' -> ' +
                                  sr.Name + '_file');
          end;

        until FindNext(sr) <> 0;
      finally
        FindClose(sr);
      end;
    end;

    // Analyser les conflits de casse dans les fichiers
    for i := 0 to fichiers.Count - 2 do
    begin
      for j := i + 1 to fichiers.Count - 1 do
      begin
        if CompareText(fichiers[i], fichiers[j]) = 0 then
        begin
          Inc(Result.NbConflitsCasse);
          Result.Conflits.Add(Format('Conflit fichiers : "%s" ‚âà "%s"',
                                    [fichiers[i], fichiers[j]]));
          Result.Suggestions.Add(Format('Renommer un des deux : %s ou %s',
                                       [fichiers[i], fichiers[j]]));
        end;
      end;
    end;

    // Analyser les conflits dans les r√©pertoires
    for i := 0 to repertoires.Count - 2 do
    begin
      for j := i + 1 to repertoires.Count - 1 do
      begin
        if CompareText(repertoires[i], repertoires[j]) = 0 then
        begin
          Inc(Result.NbConflitsCasse);
          Result.Conflits.Add(Format('Conflit r√©pertoires : "%s" ‚âà "%s"',
                                    [repertoires[i], repertoires[j]]));
          Result.Suggestions.Add(Format('Renommer un des deux : %s ou %s',
                                       [repertoires[i], repertoires[j]]));
        end;
      end;
    end;

  finally
    fichiers.Free;
    repertoires.Free;
  end;
end;

function VerifierCaracteresInterdits(const Nom: string): Boolean;
const
  {$IFDEF WINDOWS}
  INTERDITS = ['<', '>', ':', '"', '|', '?', '*'];
  {$ELSE}
  INTERDITS = [#0]; // Seul le caract√®re nul est interdit sur Unix
  {$ENDIF}
var
  c: Char;
begin
  Result := False;
  for c in Nom do
  begin
    if c in INTERDITS then
      Exit(True);
  end;
end;

function EstNomReserve(const Nom: string): Boolean;
const
  RESERVES: array[0..21] of string = (
    'CON', 'PRN', 'AUX', 'NUL',
    'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9',
    'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'
  );
var
  nomSansExt: string;
  i: Integer;
begin
  Result := False;

  {$IFDEF WINDOWS}
  nomSansExt := UpperCase(ChangeFileExt(Nom, ''));
  for i := 0 to High(RESERVES) do
  begin
    if nomSansExt = RESERVES[i] then
      Exit(True);
  end;
  {$ENDIF}
end;

function NettoyerNomFichier(const Nom: string): string;
begin
  Result := Nom;

  // Remplacer les caract√®res interdits
  Result := StringReplace(Result, '<', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '>', '_', [rfReplaceAll]);
  Result := StringReplace(Result, ':', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '"', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '|', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '?', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '*', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '\', '_', [rfReplaceAll]);
  Result := StringReplace(Result, '/', '_', [rfReplaceAll]);

  // Normaliser en minuscules pour √©viter les conflits
  Result := LowerCase(Result);
end;

procedure AfficherRapport(const Rapport: TRapportDiagnostic);
begin
  WriteLn('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  WriteLn('‚ïë     RAPPORT DE DIAGNOSTIC - SENSIBILIT√â     ‚ïë');
  WriteLn('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  WriteLn;

  WriteLn('üìä STATISTIQUES');
  WriteLn('   Fichiers analys√©s : ', Rapport.NbFichiers);
  WriteLn('   R√©pertoires analys√©s : ', Rapport.NbRepertoires);
  WriteLn;

  WriteLn('‚ö†Ô∏è  PROBL√àMES D√âTECT√âS');
  WriteLn('   Conflits de casse : ', Rapport.NbConflitsCasse);
  WriteLn('   Caract√®res interdits : ', Rapport.NbCaracteresInterdits);
  WriteLn('   Noms r√©serv√©s : ', Rapport.NbNomsReserves);
  WriteLn;

  if Rapport.Conflits.Count > 0 then
  begin
    WriteLn('üî¥ D√âTAILS DES CONFLITS');
    for var i := 0 to Min(9, Rapport.Conflits.Count - 1) do
      WriteLn('   ', Rapport.Conflits[i]);
    if Rapport.Conflits.Count > 10 then
      WriteLn('   ... et ', Rapport.Conflits.Count - 10, ' autres');
    WriteLn;
  end;

  if Rapport.Suggestions.Count > 0 then
  begin
    WriteLn('üí° SUGGESTIONS DE CORRECTION');
    for var i := 0 to Min(9, Rapport.Suggestions.Count - 1) do
      WriteLn('   ', Rapport.Suggestions[i]);
    if Rapport.Suggestions.Count > 10 then
      WriteLn('   ... et ', Rapport.Suggestions.Count - 10, ' autres');
    WriteLn;
  end;

  // Score de portabilit√©
  var score := 100;
  score := score - (Rapport.NbConflitsCasse * 10);
  score := score - (Rapport.NbCaracteresInterdits * 5);
  score := score - (Rapport.NbNomsReserves * 15);
  if score < 0 then score := 0;

  WriteLn('üìà SCORE DE PORTABILIT√â : ', score, '%');

  if score >= 90 then
    WriteLn('   ‚úÖ Excellent - Projet tr√®s portable')
  else if score >= 70 then
    WriteLn('   ‚ö†Ô∏è  Bon - Quelques ajustements recommand√©s')
  else if score >= 50 then
    WriteLn('   ‚ö†Ô∏è  Moyen - Corrections n√©cessaires')
  else
    WriteLn('   ‚ùå Faible - Nombreux probl√®mes √† corriger');
end;

// Programme principal de diagnostic
var
  chemin: string;
  rapport: TRapportDiagnostic;
begin
  WriteLn('=== Outil de Diagnostic - Sensibilit√© √† la Casse ===');
  WriteLn;

  // Utiliser le r√©pertoire courant ou celui pass√© en param√®tre
  if ParamCount > 0 then
    chemin := ParamStr(1)
  else
    chemin := GetCurrentDir;

  WriteLn('Analyse du r√©pertoire : ', chemin);
  WriteLn('Syst√®me : ',
    {$IFDEF WINDOWS}'Windows (insensible)'{$ENDIF}
    {$IFDEF LINUX}'Linux (sensible)'{$ENDIF}
  );
  WriteLn;

  rapport := DiagnostiquerRepertoire(chemin);
  AfficherRapport(rapport);

  // Lib√©rer les listes
  rapport.Conflits.Free;
  rapport.Suggestions.Free;

  WriteLn;
  WriteLn('Analyse termin√©e. Appuyez sur Entr√©e...');
  ReadLn;
end.
```

## Tableau r√©capitulatif des diff√©rences

| Aspect | Windows | Linux/Unix | macOS | Solution FreePascal |
|--------|---------|------------|-------|-------------------|
| **Syst√®me de fichiers** | NTFS (insensible) | ext4 (sensible) | APFS (configurable) | Compilation conditionnelle |
| **Comparaison fichiers** | `File.txt = file.txt` | `File.txt ‚â† file.txt` | D√©pend config | CompareText vs CompareStr |
| **Recherche** | Trouve toutes variantes | Exact seulement | Variable | FindFirst avec normalisation |
| **Base de donn√©es** | D√©pend config | Sensible par d√©faut | Variable | COLLATE clauses |
| **Noms r√©serv√©s** | CON, PRN, AUX, etc. | Aucun | Aucun | V√©rification Windows |
| **Caract√®res interdits** | `< > : " | ? * \` | Seulement `\0` | Seulement `\0` | Validation stricte |
| **Longueur max nom** | 255 caract√®res | 255 octets | 255 caract√®res | 255 minimum garanti |

## Points cl√©s √† retenir

1. **La sensibilit√© √† la casse est LA diff√©rence majeure** entre Windows et Linux pour les fichiers

2. **Toujours tester sur les deux plateformes** - Ce qui fonctionne sur l'un peut √©chouer sur l'autre

3. **Utiliser des noms en minuscules** est la solution la plus simple et portable

4. **Les outils de compilation conditionnelle** (`{$IFDEF}`) sont vos amis

5. **Impl√©menter une couche d'abstraction** pour les op√©rations critiques sur les fichiers

6. **Documenter les conventions** de nommage dans votre projet

7. **Automatiser les tests** de portabilit√© dans votre CI/CD

## Recommandations finales

### Pour un nouveau projet

- Adoptez une convention stricte : tout en minuscules, underscores pour les espaces
- Utilisez un gestionnaire de fichiers abstrait d√®s le d√©but
- Mettez en place des tests automatiques multi-plateformes
- Documentez clairement les r√®gles de nommage

### Pour un projet existant

- Faites un audit avec l'outil de diagnostic
- Corrigez progressivement les conflits d√©tect√©s
- Ajoutez des tests de r√©gression
- Migrez vers une couche d'abstraction

### Pour la maintenance

- V√©rifiez r√©guli√®rement la portabilit√©
- Formez l'√©quipe aux diff√©rences de sensibilit√©
- Utilisez des outils de CI/CD multi-plateformes
- Gardez une documentation √† jour

## Conclusion

La gestion de la sensibilit√© √† la casse est un d√©fi incontournable du d√©veloppement multi-plateforme. Windows traite `Document.txt` et `document.txt` comme identiques, tandis que Linux les consid√®re comme deux fichiers distincts. Cette diff√©rence fondamentale peut causer des bugs subtils et frustrants.

Avec FreePascal/Lazarus, vous disposez d'outils puissants pour g√©rer ces diff√©rences : compilation conditionnelle, fonctions de comparaison adapt√©es, et possibilit√© de cr√©er des couches d'abstraction robustes. En suivant les bonnes pratiques pr√©sent√©es dans ce tutoriel, vous pouvez cr√©er des applications v√©ritablement portables qui fonctionnent parfaitement sur Windows et Linux.

N'oubliez pas : **la meilleure approche est la pr√©vention**. Adoptez des conventions strictes, utilisez des noms simples, et testez syst√©matiquement sur toutes vos plateformes cibles. Votre futur vous en remerciera !

‚è≠Ô∏è [Compilation conditionnelle avanc√©e](/05-developpement-multiplateforme-approfondi/04-compilation-conditionnelle-avancee.md)
