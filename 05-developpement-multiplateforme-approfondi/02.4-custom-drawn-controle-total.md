üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.4 Custom Drawn pour contr√¥le total

## Introduction au Widgetset Custom Drawn

### Qu'est-ce que Custom Drawn ?

Le widgetset **Custom Drawn** est unique : au lieu d'utiliser les contr√¥les natifs du syst√®me (comme Win32, GTK ou Qt), il **dessine tout lui-m√™me** pixel par pixel. C'est comme peindre votre interface sur une toile blanche, vous avez le contr√¥le total sur chaque aspect visuel.

**Analogie simple :** Imaginez la diff√©rence entre :
- **Widgetsets natifs** : Utiliser des LEGO pr√©fabriqu√©s (boutons Windows, contr√¥les GTK)
- **Custom Drawn** : Sculpter vos propres pi√®ces dans de l'argile

### Pourquoi Custom Drawn ?

**Avantages uniques :**
- ‚úì **Apparence 100% identique** sur tous les OS
- ‚úì **Contr√¥le pixel-perfect** de l'interface
- ‚úì **Aucune d√©pendance externe** (pas de GTK, Qt, etc.)
- ‚úì **Interfaces non-standard** possibles (jeux, kiosques, embedded)
- ‚úì **Taille r√©duite** : pas de biblioth√®ques externes
- ‚úì **Personnalisation totale** : vous d√©finissez TOUT

**Inconv√©nients :**
- ‚úó **Ne respecte pas le look natif** du syst√®me
- ‚úó **Plus de travail** pour impl√©menter les fonctionnalit√©s
- ‚úó **Performance** potentiellement moindre (tout est dessin√©)
- ‚úó **Accessibilit√© limit√©e** (lecteurs d'√©cran, etc.)
- ‚úó **Fonctionnalit√©s manquantes** : encore en d√©veloppement

## Architecture de Custom Drawn

### Comment √ßa Fonctionne

```
Votre Code Lazarus
        ‚Üì
   TButton (LCL)
        ‚Üì
TCustomDrawnWSButton (Widgetset Custom Drawn)
        ‚Üì
   Dessin manuel avec Canvas
        ‚Üì
   Bitmap en m√©moire
        ‚Üì
   Affichage √† l'√©cran
```

Au lieu d'appeler `CreateWindow` (Windows) ou `gtk_button_new` (GTK), Custom Drawn dessine un rectangle avec du texte pour cr√©er un "bouton".

### Exemple Conceptuel

```pascal
// Ce que fait Win32/GTK/Qt :
Button := CreateNativeButton();  // Demande au syst√®me

// Ce que fait Custom Drawn :
procedure DrawButton(Canvas: TCanvas; Rect: TRect; Caption: string);
begin
  // Dessiner le fond
  Canvas.Brush.Color := clBtnFace;
  Canvas.FillRect(Rect);

  // Dessiner la bordure
  Canvas.Pen.Color := clBtnShadow;
  Canvas.Rectangle(Rect);

  // Dessiner le texte
  Canvas.TextOut(
    Rect.Left + (Rect.Width - Canvas.TextWidth(Caption)) div 2,
    Rect.Top + (Rect.Height - Canvas.TextHeight(Caption)) div 2,
    Caption
  );
end;
```

## Installation et Configuration

### Activer Custom Drawn dans Lazarus

#### Dans l'IDE

1. **Projet** ‚Üí **Options du projet**
2. **Compilateur** ‚Üí **Ajouts et Substitutions**
3. **LCLWidgetType** ‚Üí S√©lectionner **customdrawn**

#### En Ligne de Commande

```bash
# Compiler avec Custom Drawn
lazbuild --ws=customdrawn monprojet.lpi
```

#### Dans le Code

```pascal
program MonApplication;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  Interfaces, // Charge Custom Drawn automatiquement
  Forms,
  customdrawncontrols, // Unit√© sp√©cifique Custom Drawn
  Unit1;

begin
  Application.Initialize;
  Application.CreateForm(TForm1, Form1);
  Application.Run;
end.
```

### V√©rifier l'Activation

```pascal
uses LCLPlatformDef, InterfaceBase;

procedure VerifierCustomDrawn;
begin
  if WidgetSet.LCLPlatform = lpCustomDrawn then
    ShowMessage('Custom Drawn activ√© !')
  else
    ShowMessage('Autre widgetset : ' +
                IntToStr(Ord(WidgetSet.LCLPlatform)));
end;
```

## Concepts Fondamentaux

### 1. Tout est Dessin√©

Dans Custom Drawn, CHAQUE √©l√©ment visuel est dessin√© par code :

```pascal
// Un "bouton" Custom Drawn simplifi√©
procedure TCustomDrawnButton.Paint;
var
  TextSize: TSize;
begin
  with Canvas do
  begin
    // √âtat normal
    if not FPressed then
    begin
      Brush.Color := clBtnFace;
      Pen.Color := clBtnHighlight;
    end
    else
    begin
      // √âtat press√©
      Brush.Color := clBtnShadow;
      Pen.Color := clBtnText;
    end;

    // Dessiner le fond
    FillRect(ClientRect);

    // Dessiner la bordure 3D
    if not FPressed then
    begin
      // Bordure relev√©e
      Pen.Color := clBtnHighlight;
      MoveTo(0, Height - 1);
      LineTo(0, 0);
      LineTo(Width - 1, 0);

      Pen.Color := clBtnShadow;
      LineTo(Width - 1, Height - 1);
      LineTo(0, Height - 1);
    end
    else
    begin
      // Bordure enfonc√©e
      Pen.Color := clBtnShadow;
      MoveTo(0, Height - 1);
      LineTo(0, 0);
      LineTo(Width - 1, 0);

      Pen.Color := clBtnHighlight;
      LineTo(Width - 1, Height - 1);
      LineTo(0, Height - 1);
    end;

    // Dessiner le texte centr√©
    TextSize := TextExtent(Caption);
    TextOut(
      (Width - TextSize.cx) div 2 + IfThen(FPressed, 1, 0),
      (Height - TextSize.cy) div 2 + IfThen(FPressed, 1, 0),
      Caption
    );

    // Dessiner le rectangle de focus si n√©cessaire
    if Focused then
    begin
      Pen.Style := psDot;
      Pen.Color := clBtnText;
      Brush.Style := bsClear;
      Rectangle(2, 2, Width - 2, Height - 2);
      Pen.Style := psSolid;
      Brush.Style := bsSolid;
    end;
  end;
end;
```

### 2. Gestion des √âv√©nements

Les √©v√©nements souris et clavier doivent √™tre g√©r√©s manuellement :

```pascal
type
  TCustomControl = class(TGraphicControl)
  private
    FPressed: Boolean;
    FHover: Boolean;
  protected
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
                       X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
                     X, Y: Integer); override;
    procedure MouseEnter; override;
    procedure MouseLeave; override;
    procedure Paint; override;
  end;

procedure TCustomControl.MouseDown(Button: TMouseButton;
                                   Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbLeft then
  begin
    FPressed := True;
    Invalidate; // Redessiner
  end;
  inherited;
end;

procedure TCustomControl.MouseUp(Button: TMouseButton;
                                 Shift: TShiftState; X, Y: Integer);
begin
  if FPressed and (Button = mbLeft) then
  begin
    FPressed := False;
    Invalidate;

    // D√©clencher OnClick si toujours sur le contr√¥le
    if PtInRect(ClientRect, Point(X, Y)) then
      if Assigned(OnClick) then
        OnClick(Self);
  end;
  inherited;
end;

procedure TCustomControl.MouseEnter;
begin
  FHover := True;
  Invalidate;
  inherited;
end;

procedure TCustomControl.MouseLeave;
begin
  FHover := False;
  FPressed := False;
  Invalidate;
  inherited;
end;
```

## Cr√©er des Contr√¥les Personnalis√©s

### Exemple 1 : Bouton Circulaire

```pascal
type
  TCircularButton = class(TGraphicControl)
  private
    FPressed: Boolean;
    FHover: Boolean;
    FCaption: string;
    procedure SetCaption(const Value: string);
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
                       X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
                     X, Y: Integer); override;
    function IsPointInside(X, Y: Integer): Boolean;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Caption: string read FCaption write SetCaption;
    property OnClick;
  end;

constructor TCircularButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 100;
  Height := 100;
  FCaption := 'Bouton';
end;

procedure TCircularButton.SetCaption(const Value: string);
begin
  if FCaption <> Value then
  begin
    FCaption := Value;
    Invalidate;
  end;
end;

function TCircularButton.IsPointInside(X, Y: Integer): Boolean;
var
  CenterX, CenterY, Radius: Integer;
  Distance: Double;
begin
  CenterX := Width div 2;
  CenterY := Height div 2;
  Radius := Min(Width, Height) div 2;

  Distance := Sqrt(Sqr(X - CenterX) + Sqr(Y - CenterY));
  Result := Distance <= Radius;
end;

procedure TCircularButton.Paint;
var
  CenterX, CenterY, Radius: Integer;
  TextSize: TSize;
begin
  CenterX := Width div 2;
  CenterY := Height div 2;
  Radius := Min(Width, Height) div 2 - 2;

  with Canvas do
  begin
    // Antialiasing
    AntialiasingMode := amOn;

    // Couleur selon l'√©tat
    if FPressed then
      Brush.Color := clBtnShadow
    else if FHover then
      Brush.Color := clBtnHighlight
    else
      Brush.Color := clBtnFace;

    // Dessiner le cercle
    Pen.Color := clBtnText;
    Pen.Width := 2;
    Ellipse(CenterX - Radius, CenterY - Radius,
            CenterX + Radius, CenterY + Radius);

    // Dessiner l'ombre
    if not FPressed then
    begin
      Pen.Color := clGray;
      Arc(CenterX - Radius + 2, CenterY - Radius + 2,
          CenterX + Radius + 2, CenterY + Radius + 2,
          0, 180 * 16);
    end;

    // Dessiner le texte
    Font.Style := [fsBold];
    TextSize := TextExtent(FCaption);
    TextOut(CenterX - TextSize.cx div 2,
            CenterY - TextSize.cy div 2,
            FCaption);
  end;
end;

procedure TCircularButton.MouseDown(Button: TMouseButton;
                                    Shift: TShiftState; X, Y: Integer);
begin
  if (Button = mbLeft) and IsPointInside(X, Y) then
  begin
    FPressed := True;
    Invalidate;
  end;
  inherited;
end;

procedure TCircularButton.MouseUp(Button: TMouseButton;
                                  Shift: TShiftState; X, Y: Integer);
begin
  if FPressed then
  begin
    FPressed := False;
    Invalidate;

    if IsPointInside(X, Y) and Assigned(OnClick) then
      OnClick(Self);
  end;
  inherited;
end;
```

### Exemple 2 : Switch iOS-Style

```pascal
type
  TCustomSwitch = class(TGraphicControl)
  private
    FChecked: Boolean;
    FAnimationPos: Integer;
    FAnimationTimer: TTimer;
    FOnChange: TNotifyEvent;
    procedure SetChecked(Value: Boolean);
    procedure AnimationTimerTick(Sender: TObject);
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
                       X, Y: Integer); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Checked: Boolean read FChecked write SetChecked;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

constructor TCustomSwitch.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 60;
  Height := 30;
  FAnimationTimer := TTimer.Create(nil);
  FAnimationTimer.Interval := 20;
  FAnimationTimer.Enabled := False;
  FAnimationTimer.OnTimer := @AnimationTimerTick;
end;

destructor TCustomSwitch.Destroy;
begin
  FAnimationTimer.Free;
  inherited;
end;

procedure TCustomSwitch.SetChecked(Value: Boolean);
begin
  if FChecked <> Value then
  begin
    FChecked := Value;
    FAnimationTimer.Enabled := True;

    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TCustomSwitch.AnimationTimerTick(Sender: TObject);
var
  TargetPos: Integer;
begin
  if FChecked then
    TargetPos := Width - Height + 4
  else
    TargetPos := 4;

  if FAnimationPos < TargetPos then
    Inc(FAnimationPos, 3)
  else if FAnimationPos > TargetPos then
    Dec(FAnimationPos, 3);

  if Abs(FAnimationPos - TargetPos) < 3 then
  begin
    FAnimationPos := TargetPos;
    FAnimationTimer.Enabled := False;
  end;

  Invalidate;
end;

procedure TCustomSwitch.Paint;
var
  Radius: Integer;
begin
  with Canvas do
  begin
    // Antialiasing pour les courbes douces
    AntialiasingMode := amOn;

    // Fond du switch
    if FChecked then
      Brush.Color := clLime
    else
      Brush.Color := clSilver;

    Pen.Style := psClear;

    // Dessiner la piste arrondie
    Radius := Height div 2;
    RoundRect(0, 0, Width, Height, Radius, Radius);

    // Dessiner le bouton
    Brush.Color := clWhite;
    Pen.Color := clGray;
    Pen.Style := psSolid;

    Ellipse(FAnimationPos, 4,
            FAnimationPos + Height - 8, Height - 4);
  end;
end;

procedure TCustomSwitch.MouseDown(Button: TMouseButton;
                                  Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbLeft then
    Checked := not Checked;
  inherited;
end;
```

## Th√®mes et Styles Personnalis√©s

### Syst√®me de Th√®mes

```pascal
type
  TThemeColors = record
    Background: TColor;
    ButtonFace: TColor;
    ButtonText: TColor;
    ButtonHover: TColor;
    ButtonPressed: TColor;
    Border: TColor;
    Focus: TColor;
  end;

  TThemeManager = class
  private
    FCurrentTheme: TThemeColors;
  public
    procedure LoadLightTheme;
    procedure LoadDarkTheme;
    procedure LoadCustomTheme(const Theme: TThemeColors);
    property CurrentTheme: TThemeColors read FCurrentTheme;
  end;

var
  ThemeManager: TThemeManager;

procedure TThemeManager.LoadLightTheme;
begin
  FCurrentTheme.Background := clWhite;
  FCurrentTheme.ButtonFace := clBtnFace;
  FCurrentTheme.ButtonText := clBtnText;
  FCurrentTheme.ButtonHover := clSkyBlue;
  FCurrentTheme.ButtonPressed := clNavy;
  FCurrentTheme.Border := clGray;
  FCurrentTheme.Focus := clBlue;
end;

procedure TThemeManager.LoadDarkTheme;
begin
  FCurrentTheme.Background := $202020;
  FCurrentTheme.ButtonFace := $404040;
  FCurrentTheme.ButtonText := $F0F0F0;
  FCurrentTheme.ButtonHover := $505050;
  FCurrentTheme.ButtonPressed := $303030;
  FCurrentTheme.Border := $606060;
  FCurrentTheme.Focus := $0080FF;
end;

// Utilisation dans un contr√¥le
procedure TThemedButton.Paint;
begin
  with Canvas do
  begin
    Brush.Color := ThemeManager.CurrentTheme.ButtonFace;
    Font.Color := ThemeManager.CurrentTheme.ButtonText;

    if FHover then
      Brush.Color := ThemeManager.CurrentTheme.ButtonHover;
    if FPressed then
      Brush.Color := ThemeManager.CurrentTheme.ButtonPressed;

    // Dessiner avec les couleurs du th√®me
    FillRect(ClientRect);
    TextOut(10, 10, Caption);
  end;
end;
```

### Effets Visuels Avanc√©s

```pascal
// Ombre port√©e
procedure DrawDropShadow(Canvas: TCanvas; Rect: TRect;
                        ShadowSize: Integer; ShadowColor: TColor);
var
  i: Integer;
  Alpha: Byte;
begin
  for i := ShadowSize downto 1 do
  begin
    Alpha := 255 - (i * 255 div ShadowSize);
    Canvas.Pen.Color := ShadowColor;
    Canvas.Brush.Style := bsClear;

    // Cr√©er un effet de d√©grad√©
    Canvas.Rectangle(Rect.Left + i, Rect.Top + i,
                    Rect.Right + i, Rect.Bottom + i);
  end;
end;

// D√©grad√©
procedure DrawGradient(Canvas: TCanvas; Rect: TRect;
                       Color1, Color2: TColor; Vertical: Boolean);
var
  i, Steps: Integer;
  R1, G1, B1, R2, G2, B2: Byte;
  R, G, B: Byte;
begin
  Color1 := ColorToRGB(Color1);
  Color2 := ColorToRGB(Color2);

  R1 := GetRValue(Color1);
  G1 := GetGValue(Color1);
  B1 := GetBValue(Color1);

  R2 := GetRValue(Color2);
  G2 := GetGValue(Color2);
  B2 := GetBValue(Color2);

  if Vertical then
    Steps := Rect.Bottom - Rect.Top
  else
    Steps := Rect.Right - Rect.Left;

  for i := 0 to Steps - 1 do
  begin
    R := R1 + (R2 - R1) * i div Steps;
    G := G1 + (G2 - G1) * i div Steps;
    B := B1 + (B2 - B1) * i div Steps;

    Canvas.Pen.Color := RGB(R, G, B);

    if Vertical then
    begin
      Canvas.MoveTo(Rect.Left, Rect.Top + i);
      Canvas.LineTo(Rect.Right, Rect.Top + i);
    end
    else
    begin
      Canvas.MoveTo(Rect.Left + i, Rect.Top);
      Canvas.LineTo(Rect.Left + i, Rect.Bottom);
    end;
  end;
end;

// Effet de verre (glass)
procedure DrawGlassEffect(Canvas: TCanvas; Rect: TRect);
var
  MidY: Integer;
begin
  MidY := Rect.Top + (Rect.Bottom - Rect.Top) div 2;

  // Partie sup√©rieure plus claire
  DrawGradient(Canvas,
               Types.Rect(Rect.Left, Rect.Top, Rect.Right, MidY),
               $F0F0F0, $D0D0D0, True);

  // Partie inf√©rieure plus sombre
  DrawGradient(Canvas,
               Types.Rect(Rect.Left, MidY, Rect.Right, Rect.Bottom),
               $C0C0C0, $A0A0A0, True);

  // Reflet
  Canvas.Pen.Color := $FFFFFF;
  Canvas.Pen.Width := 1;
  Canvas.MoveTo(Rect.Left + 2, Rect.Top + 2);
  Canvas.LineTo(Rect.Right - 2, Rect.Top + 2);
end;
```

## Optimisation et Performance

### Double Buffering

```pascal
type
  TDoubleBufferedControl = class(TGraphicControl)
  private
    FBuffer: TBitmap;
  protected
    procedure Paint; override;
    procedure Resize; override;
    procedure PaintBuffer; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

constructor TDoubleBufferedControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FBuffer := TBitmap.Create;
end;

destructor TDoubleBufferedControl.Destroy;
begin
  FBuffer.Free;
  inherited;
end;

procedure TDoubleBufferedControl.Resize;
begin
  inherited;
  FBuffer.SetSize(Width, Height);
end;

procedure TDoubleBufferedControl.Paint;
begin
  // Dessiner dans le buffer
  PaintBuffer;

  // Copier le buffer sur le canvas
  Canvas.Draw(0, 0, FBuffer);
end;

procedure TDoubleBufferedControl.PaintBuffer;
begin
  // Dessiner sur FBuffer.Canvas au lieu de Canvas
  with FBuffer.Canvas do
  begin
    // Effacer le fond
    Brush.Color := clWhite;
    FillRect(Rect(0, 0, Width, Height));

    // Dessiner le contenu
    // ...
  end;
end;
```

### R√©gions de Clipping

```pascal
// Optimiser le redessin en limitant aux zones modifi√©es
procedure OptimizedPaint(Canvas: TCanvas; UpdateRect: TRect);
var
  ClipRgn: HRGN;
begin
  // Cr√©er une r√©gion de clipping
  ClipRgn := CreateRectRgn(UpdateRect.Left, UpdateRect.Top,
                           UpdateRect.Right, UpdateRect.Bottom);
  try
    // Appliquer la r√©gion
    SelectClipRgn(Canvas.Handle, ClipRgn);

    // Dessiner seulement dans cette r√©gion
    DrawComplexInterface(Canvas);
  finally
    // Restaurer
    SelectClipRgn(Canvas.Handle, 0);
    DeleteObject(ClipRgn);
  end;
end;
```

## Gestion des Polices et du Texte

### Mesure et Alignement du Texte

```pascal
type
  TTextAlignment = (taLeft, taCenter, taRight, taJustify);
  TVerticalAlignment = (vaTop, vaMiddle, vaBottom);

procedure DrawAlignedText(Canvas: TCanvas; const Text: string;
                         Rect: TRect; HAlign: TTextAlignment;
                         VAlign: TVerticalAlignment);
var
  TextWidth, TextHeight: Integer;
  X, Y: Integer;
begin
  TextWidth := Canvas.TextWidth(Text);
  TextHeight := Canvas.TextHeight(Text);

  // Alignement horizontal
  case HAlign of
    taLeft:   X := Rect.Left;
    taCenter: X := Rect.Left + (Rect.Width - TextWidth) div 2;
    taRight:  X := Rect.Right - TextWidth;
    taJustify: X := Rect.Left; // Plus complexe, n√©cessite word-wrapping
  end;

  // Alignement vertical
  case VAlign of
    vaTop:    Y := Rect.Top;
    vaMiddle: Y := Rect.Top + (Rect.Height - TextHeight) div 2;
    vaBottom: Y := Rect.Bottom - TextHeight;
  end;

  Canvas.TextOut(X, Y, Text);
end;

// Texte multi-ligne avec wrapping
procedure DrawWrappedText(Canvas: TCanvas; const Text: string;
                         Rect: TRect);
var
  Lines: TStringList;
  CurrentLine: string;
  Words: TStringList;
  i, Y: Integer;
  LineHeight: Integer;
begin
  Lines := TStringList.Create;
  Words := TStringList.Create;
  try
    // Diviser en mots
    Words.Delimiter := ' ';
    Words.DelimitedText := Text;

    // Construire les lignes
    CurrentLine := '';
    for i := 0 to Words.Count - 1 do
    begin
      if Canvas.TextWidth(CurrentLine + ' ' + Words[i]) > Rect.Width then
      begin
        if CurrentLine <> '' then
          Lines.Add(CurrentLine);
        CurrentLine := Words[i];
      end
      else
      begin
        if CurrentLine <> '' then
          CurrentLine := CurrentLine + ' ';
        CurrentLine := CurrentLine + Words[i];
      end;
    end;
    if CurrentLine <> '' then
      Lines.Add(CurrentLine);

    // Dessiner les lignes
    LineHeight := Canvas.TextHeight('Ag');
    Y := Rect.Top;
    for i := 0 to Lines.Count - 1 do
    begin
      Canvas.TextOut(Rect.Left, Y, Lines[i]);
      Inc(Y, LineHeight);

      if Y + LineHeight > Rect.Bottom then
        Break;
    end;
  finally
    Lines.Free;
    Words.Free;
  end;
end;
```

## D√©ploiement d'Applications Custom Drawn

### Avantages du D√©ploiement

```pascal
// Custom Drawn = D√©ploiement ultra simple !

// Windows : Un seul .exe, pas de DLL
// Linux : Un seul binaire, pas de d√©pendances GTK/Qt
// macOS : Bundle minimal

// Structure de d√©ploiement minimale :
MonApp.exe  // C'est tout !
```

### Configuration de Build

```pascal
// Optimisations pour Custom Drawn
{$IFDEF CUSTOMDRAWN}
  {$OPTIMIZATION ON}
  {$SMARTLINK ON}     // R√©duire la taille
  {$ASSERTIONS OFF}   // Production
{$ENDIF}

// Inclure les ressources
{$R *.res}  // Ic√¥nes et ressources
```

## Cas d'Usage Id√©aux

### 1. Applications Kiosque

```pascal
// Interface fullscreen personnalis√©e
procedure CreateKioskInterface;
begin
  // Pas de bordures Windows
  BorderStyle := bsNone;

  // Plein √©cran
  WindowState := wsMaximized;

  // Interface totalement custom
  CreateCustomButtons;
  CreateBrandedInterface;
end;
```

### 2. Jeux et Applications Ludiques

```pascal
// Contr√¥les de jeu personnalis√©s
type
  TGameButton = class(TGraphicControl)
    // Apparence unique pour le jeu
  end;

  THealthBar = class(TGraphicControl)
    // Barre de vie stylis√©e
  end;
```

### 3. Syst√®mes Embarqu√©s

```pascal
// Interface pour √©cran tactile industriel
type
  TTouchButton = class(TGraphicControl)
  private
    FMinTouchSize: Integer;
  public
    constructor Create(AOwner: TComponent); override;
  end;

constructor TTouchButton.Create(AOwner: TComponent);
begin
  inherited;
  FMinTouchSize := 48; // Taille minimale pour tactile
  Width := FMinTouchSize * 2;
  Height := FMinTouchSize;
end;
```

## Probl√®mes Courants et Solutions

### 1. Scintillement

**Solution : Double buffering**
```pascal
DoubleBuffered := True;
// Ou utiliser TDoubleBufferedControl
```

### 2. Performance Lente

**Solution : Optimiser le dessin**
```pascal
// Ne redessiner que ce qui change
InvalidateRect(Handle, @ChangedRect, False);

// D√©sactiver l'antialiasing si pas n√©cessaire
Canvas.AntialiasingMode := amOff;
```

### 3. Texte Flou

**Solution : D√©sactiver l'antialiasing pour le texte**
```pascal
Canvas.Font.Quality := fqNonAntialiased;
```

## Conclusion

Le widgetset **Custom Drawn** offre une libert√© totale pour cr√©er des interfaces uniques et identiques sur toutes les plateformes.

### ‚úÖ Points Forts
- **Contr√¥le total** sur l'apparence
- **Aucune d√©pendance** externe
- **Coh√©rence parfaite** entre OS
- **Cr√©ativit√© illimit√©e** dans le design
- **D√©ploiement simple** (un seul fichier)

### ‚ö†Ô∏è Limitations
- **Travail suppl√©mentaire** pour tout impl√©menter
- **Pas de look natif** du syst√®me
- **Accessibilit√©** √† impl√©menter manuellement
- **Performance** √† optimiser
- **Fonctionnalit√©s** encore en d√©veloppement

### üéØ Utilisez Custom Drawn pour :
- Applications avec **interface unique**
- **Jeux** et applications ludiques
- **Kiosques** et bornes interactives
- **Syst√®mes embarqu√©s** avec √©crans sp√©cifiques
- Applications n√©cessitant une **identit√© visuelle forte**
- Prototypes d'**interfaces exp√©rimentales**

### ‚ùå √âvitez Custom Drawn pour :
- Applications d'**entreprise standard**
- Logiciels n√©cessitant le **look natif** du syst√®me
- Applications avec beaucoup de **texte et formulaires**
- Projets avec **d√©lais serr√©s**
- Applications n√©cessitant l'**accessibilit√©** compl√®te

## Exemples Complets d'Applications

### Exemple 1 : Calculatrice Custom

```pascal
unit CustomCalculator;

interface

uses
  Classes, SysUtils, Graphics, Controls, Forms;

type
  TCalcButton = class(TGraphicControl)
  private
    FCaption: string;
    FPressed: Boolean;
    FIsOperator: Boolean;
    FOnCalcClick: TNotifyEvent;
    procedure SetCaption(const Value: string);
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
                       X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
                     X, Y: Integer); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Caption: string read FCaption write SetCaption;
    property IsOperator: Boolean read FIsOperator write FIsOperator;
    property OnCalcClick: TNotifyEvent read FOnCalcClick write FOnCalcClick;
  end;

  TCustomCalculator = class(TCustomControl)
  private
    FDisplay: string;
    FButtons: array of TCalcButton;
    FCurrentValue: Double;
    FStoredValue: Double;
    FOperation: Char;
    procedure CreateButtons;
    procedure ButtonClick(Sender: TObject);
    procedure PerformCalculation;
  protected
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

implementation

constructor TCalcButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 50;
  Height := 50;
  FCaption := '0';
end;

procedure TCalcButton.SetCaption(const Value: string);
begin
  if FCaption <> Value then
  begin
    FCaption := Value;
    // D√©terminer si c'est un op√©rateur
    FIsOperator := Value[1] in ['+', '-', '*', '/', '=', 'C'];
    Invalidate;
  end;
end;

procedure TCalcButton.Paint;
var
  TextSize: TSize;
  ColorBase, ColorText: TColor;
begin
  with Canvas do
  begin
    // Antialiasing pour des boutons lisses
    AntialiasingMode := amOn;

    // Couleurs selon le type et l'√©tat
    if FIsOperator then
    begin
      if FPressed then
        ColorBase := $FF8000  // Orange fonc√©
      else
        ColorBase := $FFA040; // Orange
      ColorText := clWhite;
    end
    else
    begin
      if FPressed then
        ColorBase := $E0E0E0  // Gris clair
      else
        ColorBase := $F0F0F0; // Presque blanc
      ColorText := clBlack;
    end;

    // Dessiner le bouton avec coins arrondis
    Brush.Color := ColorBase;
    Pen.Color := ColorBase;
    RoundRect(2, 2, Width - 2, Height - 2, 10, 10);

    // Effet 3D simple
    if not FPressed then
    begin
      // Ombre
      Pen.Color := $C0C0C0;
      Arc(3, Height - 5, Width - 3, Height - 2, 0, 180 * 16);
    end;

    // Texte centr√©
    Font.Size := 14;
    Font.Style := [fsBold];
    Font.Color := ColorText;

    TextSize := TextExtent(FCaption);
    TextOut((Width - TextSize.cx) div 2 + IfThen(FPressed, 1, 0),
            (Height - TextSize.cy) div 2 + IfThen(FPressed, 1, 0),
            FCaption);
  end;
end;

procedure TCalcButton.MouseDown(Button: TMouseButton; Shift: TShiftState;
                               X, Y: Integer);
begin
  if Button = mbLeft then
  begin
    FPressed := True;
    Invalidate;
  end;
  inherited;
end;

procedure TCalcButton.MouseUp(Button: TMouseButton; Shift: TShiftState;
                             X, Y: Integer);
begin
  if FPressed then
  begin
    FPressed := False;
    Invalidate;

    if PtInRect(ClientRect, Point(X, Y)) then
      if Assigned(FOnCalcClick) then
        FOnCalcClick(Self);
  end;
  inherited;
end;

constructor TCustomCalculator.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 240;
  Height := 320;
  FDisplay := '0';
  CreateButtons;
end;

destructor TCustomCalculator.Destroy;
var
  i: Integer;
begin
  for i := 0 to High(FButtons) do
    FButtons[i].Free;
  inherited;
end;

procedure TCustomCalculator.CreateButtons;
const
  ButtonLayout: array[0..15] of string = (
    '7', '8', '9', '/',
    '4', '5', '6', '*',
    '1', '2', '3', '-',
    'C', '0', '=', '+'
  );
var
  i, Row, Col: Integer;
  Btn: TCalcButton;
begin
  SetLength(FButtons, 16);

  for i := 0 to 15 do
  begin
    Row := i div 4;
    Col := i mod 4;

    Btn := TCalcButton.Create(Self);
    Btn.Parent := Self;
    Btn.Caption := ButtonLayout[i];
    Btn.SetBounds(10 + Col * 55, 80 + Row * 55, 50, 50);
    Btn.OnCalcClick := @ButtonClick;

    FButtons[i] := Btn;
  end;
end;

procedure TCustomCalculator.ButtonClick(Sender: TObject);
var
  Btn: TCalcButton;
  Digit: Integer;
begin
  Btn := TCalcButton(Sender);

  // Traiter selon le bouton
  if Btn.Caption = 'C' then
  begin
    FDisplay := '0';
    FCurrentValue := 0;
    FStoredValue := 0;
    FOperation := #0;
  end
  else if Btn.Caption = '=' then
  begin
    PerformCalculation;
    FDisplay := FloatToStr(FCurrentValue);
    FOperation := #0;
  end
  else if Btn.IsOperator then
  begin
    if FOperation <> #0 then
      PerformCalculation;
    FStoredValue := FCurrentValue;
    FOperation := Btn.Caption[1];
    FDisplay := '0';
  end
  else
  begin
    // Chiffre
    if FDisplay = '0' then
      FDisplay := Btn.Caption
    else
      FDisplay := FDisplay + Btn.Caption;
    FCurrentValue := StrToFloat(FDisplay);
  end;

  Invalidate;
end;

procedure TCustomCalculator.PerformCalculation;
begin
  case FOperation of
    '+': FCurrentValue := FStoredValue + FCurrentValue;
    '-': FCurrentValue := FStoredValue - FCurrentValue;
    '*': FCurrentValue := FStoredValue * FCurrentValue;
    '/': if FCurrentValue <> 0 then
           FCurrentValue := FStoredValue / FCurrentValue;
  end;
end;

procedure TCustomCalculator.Paint;
var
  DisplayRect: TRect;
begin
  with Canvas do
  begin
    // Fond de la calculatrice
    Brush.Color := $202020;
    FillRect(ClientRect);

    // √âcran d'affichage
    DisplayRect := Rect(10, 10, Width - 10, 60);

    // Fond de l'√©cran
    Brush.Color := $404040;
    Pen.Color := $606060;
    RoundRect(DisplayRect, 5, 5);

    // Texte de l'affichage
    Font.Color := clLime;
    Font.Size := 18;
    Font.Style := [fsBold];

    TextOut(DisplayRect.Right - TextWidth(FDisplay) - 10,
            DisplayRect.Top + 15,
            FDisplay);
  end;
end;

end.
```

### Exemple 2 : Gauge Circulaire Anim√©

```pascal
type
  TCircularGauge = class(TGraphicControl)
  private
    FMin, FMax, FValue: Double;
    FAnimatedValue: Double;
    FAnimationTimer: TTimer;
    FCaption: string;
    FUnit: string;
    procedure SetValue(const AValue: Double);
    procedure AnimationTick(Sender: TObject);
  protected
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Min: Double read FMin write FMin;
    property Max: Double read FMax write FMax;
    property Value: Double read FValue write SetValue;
    property Caption: string read FCaption write FCaption;
    property Units: string read FUnit write FUnit;
  end;

constructor TCircularGauge.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 200;
  Height := 200;
  FMin := 0;
  FMax := 100;
  FValue := 0;
  FAnimatedValue := 0;
  FCaption := 'Gauge';
  FUnit := '%';

  FAnimationTimer := TTimer.Create(nil);
  FAnimationTimer.Interval := 30;
  FAnimationTimer.OnTimer := @AnimationTick;
end;

destructor TCircularGauge.Destroy;
begin
  FAnimationTimer.Free;
  inherited;
end;

procedure TCircularGauge.SetValue(const AValue: Double);
begin
  FValue := AValue;
  if FValue < FMin then FValue := FMin;
  if FValue > FMax then FValue := FMax;

  FAnimationTimer.Enabled := True;
end;

procedure TCircularGauge.AnimationTick(Sender: TObject);
var
  Delta: Double;
begin
  Delta := (FValue - FAnimatedValue) * 0.1;

  if Abs(Delta) < 0.01 then
  begin
    FAnimatedValue := FValue;
    FAnimationTimer.Enabled := False;
  end
  else
    FAnimatedValue := FAnimatedValue + Delta;

  Invalidate;
end;

procedure TCircularGauge.Paint;
var
  CenterX, CenterY, Radius: Integer;
  StartAngle, EndAngle, CurrentAngle: Double;
  X1, Y1, X2, Y2: Integer;
  Percentage: Double;
  ValueText: string;
  TextSize: TSize;
  i: Integer;
begin
  CenterX := Width div 2;
  CenterY := Height div 2;
  Radius := Min(Width, Height) div 2 - 20;

  with Canvas do
  begin
    // Antialiasing
    AntialiasingMode := amOn;

    // Fond
    Brush.Color := clWhite;
    FillRect(ClientRect);

    // Arc de fond
    Pen.Color := $E0E0E0;
    Pen.Width := 15;
    Pen.EndCap := pecRound;
    Arc(CenterX - Radius, CenterY - Radius,
        CenterX + Radius, CenterY + Radius,
        0, 360 * 16);

    // Arc de valeur
    Percentage := (FAnimatedValue - FMin) / (FMax - FMin);
    StartAngle := 135;
    EndAngle := StartAngle + (270 * Percentage);

    // Couleur selon la valeur
    if Percentage < 0.3 then
      Pen.Color := clGreen
    else if Percentage < 0.7 then
      Pen.Color := clYellow
    else
      Pen.Color := clRed;

    Arc(CenterX - Radius, CenterY - Radius,
        CenterX + Radius, CenterY + Radius,
        Round(StartAngle * 16), Round((EndAngle - StartAngle) * 16));

    // Graduations
    Pen.Width := 1;
    Pen.Color := clGray;
    for i := 0 to 10 do
    begin
      CurrentAngle := (135 + i * 27) * PI / 180;
      X1 := CenterX + Round((Radius - 20) * Cos(CurrentAngle));
      Y1 := CenterY + Round((Radius - 20) * Sin(CurrentAngle));
      X2 := CenterX + Round((Radius - 10) * Cos(CurrentAngle));
      Y2 := CenterY + Round((Radius - 10) * Sin(CurrentAngle));

      MoveTo(X1, Y1);
      LineTo(X2, Y2);
    end;

    // Valeur au centre
    Font.Size := 24;
    Font.Style := [fsBold];
    Font.Color := clBlack;
    ValueText := FormatFloat('0.0', FAnimatedValue);
    TextSize := TextExtent(ValueText);
    TextOut(CenterX - TextSize.cx div 2,
            CenterY - TextSize.cy div 2,
            ValueText);

    // Unit√©
    Font.Size := 12;
    Font.Style := [];
    TextSize := TextExtent(FUnit);
    TextOut(CenterX - TextSize.cx div 2,
            CenterY + 20,
            FUnit);

    // Caption
    Font.Size := 10;
    Font.Color := clGray;
    TextSize := TextExtent(FCaption);
    TextOut(CenterX - TextSize.cx div 2,
            Height - 25,
            FCaption);
  end;
end;
```

## Int√©gration avec le Syst√®me

### Gestion du Drag & Drop

```pascal
type
  TCustomDropTarget = class(TCustomControl)
  private
    FAcceptDrop: Boolean;
    FOnFilesDropped: TNotifyEvent;
  protected
    procedure Paint; override;
    procedure DragOver(Source: TObject; X, Y: Integer;
                      State: TDragState; var Accept: Boolean); override;
    procedure DragDrop(Source: TObject; X, Y: Integer); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property OnFilesDropped: TNotifyEvent read FOnFilesDropped
                                          write FOnFilesDropped;
  end;

constructor TCustomDropTarget.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 200;
  Height := 150;
  FAcceptDrop := False;
end;

procedure TCustomDropTarget.Paint;
var
  TextStr: string;
  TextSize: TSize;
begin
  with Canvas do
  begin
    // Fond
    if FAcceptDrop then
      Brush.Color := $E0FFE0  // Vert clair
    else
      Brush.Color := $F0F0F0; // Gris clair

    Pen.Color := clGray;
    Pen.Style := psDash;
    Pen.Width := 2;

    Rectangle(ClientRect);

    // Ic√¥ne et texte
    Font.Size := 12;
    Font.Color := clGray;
    TextStr := 'Glissez des fichiers ici';
    TextSize := TextExtent(TextStr);
    TextOut((Width - TextSize.cx) div 2,
            (Height - TextSize.cy) div 2,
            TextStr);
  end;
end;

procedure TCustomDropTarget.DragOver(Source: TObject; X, Y: Integer;
                                    State: TDragState; var Accept: Boolean);
begin
  Accept := True; // Accepter le drag
  FAcceptDrop := (State = dsDragEnter) or (State = dsDragMove);
  Invalidate;
end;

procedure TCustomDropTarget.DragDrop(Source: TObject; X, Y: Integer);
begin
  FAcceptDrop := False;
  Invalidate;

  if Assigned(FOnFilesDropped) then
    FOnFilesDropped(Self);
end;
```

### Menu Contextuel Personnalis√©

```pascal
type
  TCustomPopupMenu = class(TCustomControl)
  private
    FItems: TStringList;
    FSelectedIndex: Integer;
    FOnItemClick: TNotifyEvent;
  protected
    procedure Paint; override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure Click; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddItem(const Caption: string);
    procedure ShowAt(X, Y: Integer);
  end;

constructor TCustomPopupMenu.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FItems := TStringList.Create;
  FSelectedIndex := -1;
  Visible := False;
  Width := 150;
end;

procedure TCustomPopupMenu.Paint;
var
  i, ItemHeight: Integer;
  ItemRect: TRect;
begin
  ItemHeight := 25;
  Height := FItems.Count * ItemHeight + 2;

  with Canvas do
  begin
    // Fond du menu
    Brush.Color := clWhite;
    Pen.Color := clGray;
    Rectangle(ClientRect);

    // Dessiner les items
    for i := 0 to FItems.Count - 1 do
    begin
      ItemRect := Rect(1, 1 + i * ItemHeight,
                       Width - 1, 1 + (i + 1) * ItemHeight);

      // Surbrillance
      if i = FSelectedIndex then
      begin
        Brush.Color := $FFE0E0;
        FillRect(ItemRect);
      end;

      // Texte
      Font.Color := clBlack;
      TextOut(10, ItemRect.Top + 5, FItems[i]);
    end;
  end;
end;
```

## Comparaison avec les Autres Widgetsets

### Tableau Comparatif Final

| Caract√©ristique | Win32 | GTK | Qt5 | Custom Drawn |
|-----------------|-------|-----|-----|---------------|
| **D√©pendances** | Aucune | GTK libs | Qt libs | Aucune |
| **Look natif** | ‚úÖ Parfait | ‚úÖ Bon | ‚ö†Ô∏è Moyen | ‚ùå Aucun |
| **Personnalisation** | ‚ö†Ô∏è Limit√©e | ‚ö†Ô∏è Moyenne | ‚úÖ Bonne | ‚úÖ Totale |
| **Performance** | ‚úÖ Excellente | ‚úÖ Bonne | ‚úÖ Bonne | ‚ö†Ô∏è Variable |
| **Taille binaire** | ‚úÖ Petite | ‚úÖ Moyenne | ‚ùå Grande | ‚úÖ Petite |
| **Effort d√©veloppement** | ‚úÖ Minimal | ‚úÖ Minimal | ‚ö†Ô∏è Moyen | ‚ùå Important |
| **Coh√©rence cross-platform** | ‚ùå | ‚ö†Ô∏è | ‚úÖ | ‚úÖ Parfaite |
| **Maturit√©** | ‚úÖ Stable | ‚úÖ Stable | ‚úÖ Stable | ‚ö†Ô∏è Exp√©rimental |

## Guide de Migration vers Custom Drawn

### √âtapes de Migration

```pascal
// 1. Identifier les contr√¥les personnalis√©s n√©cessaires
type
  TControlMapping = record
    StandardClass: TComponentClass;
    CustomClass: TComponentClass;
  end;

const
  ControlMappings: array[0..2] of TControlMapping = (
    (StandardClass: TButton; CustomClass: TCustomButton),
    (StandardClass: TEdit; CustomClass: TCustomEdit),
    (StandardClass: TListBox; CustomClass: TCustomListBox)
  );

// 2. Remplacer progressivement
procedure MigrateForm(Form: TForm);
var
  i: Integer;
  OldControl, NewControl: TControl;
begin
  for i := Form.ComponentCount - 1 downto 0 do
  begin
    if Form.Components[i] is TButton then
    begin
      OldControl := TControl(Form.Components[i]);
      NewControl := TCustomButton.Create(Form);
      CopyProperties(OldControl, NewControl);
      OldControl.Free;
    end;
  end;
end;

// 3. Adapter les √©v√©nements
procedure AdaptEvents(OldControl, NewControl: TControl);
begin
  // Copier les handlers d'√©v√©nements
  if OldControl is TButton then
  begin
    TCustomButton(NewControl).OnClick := TButton(OldControl).OnClick;
  end;
end;
```

## Ressources et Documentation

### Outils Utiles

1. **√âditeurs de th√®me** : Cr√©er des th√®mes visuels
2. **G√©n√©rateurs de sprites** : Pour les √©l√©ments graphiques
3. **Biblioth√®ques de dessin** : BGRABitmap, Graphics32
4. **Exemples de code** : lazarus/examples/customdrawn/

### Documentation

- Wiki Lazarus Custom Drawn : https://wiki.lazarus.freepascal.org/Custom_Drawn_Interface
- Forum d√©di√© : https://forum.lazarus.freepascal.org/
- Exemples GitHub : Rechercher "lazarus custom drawn"

## Conclusion Finale

Le widgetset **Custom Drawn** repr√©sente l'ultime libert√© en mati√®re d'interface utilisateur. C'est le choix id√©al quand vous voulez :

### ‚úÖ **Contr√¥le Total**
- Chaque pixel est sous votre contr√¥le
- Aucune limitation impos√©e par le syst√®me
- Cr√©ativit√© sans limite

### ‚úÖ **Ind√©pendance**
- Aucune d√©pendance externe
- D√©ploiement ultra-simple
- Comportement identique partout

### ‚ö†Ô∏è **Mais attention**
- Demande plus de travail
- Pas de look natif
- Encore en d√©veloppement

**Le mot de la fin :** Custom Drawn est pour les d√©veloppeurs qui veulent cr√©er quelque chose de vraiment unique, qui sort des sentiers battus, et qui ont le temps et la passion pour impl√©menter leur vision exacte de l'interface utilisateur parfaite.

C'est le widgetset des artistes du code, des perfectionnistes du pixel, et des innovateurs de l'interface. Si c'est votre profil, Custom Drawn vous attend !

‚è≠Ô∏è [Gestion des diff√©rences plateforme](/05-developpement-multiplateforme-approfondi/03-gestion-differences-plateforme.md)
