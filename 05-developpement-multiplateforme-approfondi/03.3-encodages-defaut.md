🔝 Retour au [Sommaire](/SOMMAIRE.md)

# Gestion des encodages par défaut en FreePascal/Lazarus
## Développement multi-plateforme Windows/Linux

## Introduction

Avez-vous déjà ouvert un fichier texte et vu des caractères bizarres comme � ou □ à la place des accents ? Ou envoyé un fichier à un collègue qui se plaint que "ça s'affiche mal" ? C'est un problème d'encodage de caractères !

L'encodage détermine comment les caractères (lettres, chiffres, symboles) sont stockés en mémoire ou dans les fichiers. Windows et Linux utilisent parfois des encodages différents par défaut, ce qui peut créer des problèmes quand on développe des applications multi-plateformes.

Ce tutoriel vous expliquera tout ce que vous devez savoir sur les encodages pour créer des applications FreePascal/Lazarus qui fonctionnent parfaitement partout.

## Comprendre les encodages de caractères

### Qu'est-ce qu'un encodage ?

Un encodage est une table de correspondance entre :
- Les caractères que nous voyons (A, é, €, 你...)
- Les nombres binaires stockés dans l'ordinateur

Par exemple, la lettre 'A' :
- En ASCII/UTF-8 : code 65 (01000001 en binaire)
- Toujours le même dans tous les encodages modernes

Mais le caractère 'é' :
- En ISO-8859-1 (Latin-1) : code 233
- En Windows-1252 : code 233 aussi
- En UTF-8 : séquence de 2 octets (195, 169)

### Les principaux encodages

**ASCII (American Standard Code)**
- 7 bits, 128 caractères
- Lettres anglaises, chiffres, ponctuation basique
- Pas d'accents ni de caractères spéciaux
- Identique partout (c'est la base)

**ISO-8859-1 (Latin-1)**
- 8 bits, 256 caractères
- Extension d'ASCII avec accents européens occidentaux
- Souvent utilisé sur Linux/Unix historiquement
- Un octet par caractère

**Windows-1252 (CP1252)**
- 8 bits, 256 caractères
- Version Microsoft de Latin-1 avec quelques différences
- Encodage par défaut sur Windows occidental
- Un octet par caractère

**UTF-8**
- 1 à 4 octets par caractère
- Peut représenter TOUS les caractères du monde
- Compatible ASCII pour les caractères anglais
- Standard moderne, de plus en plus utilisé partout

**UTF-16**
- 2 ou 4 octets par caractère
- Utilisé en interne par Windows et Java
- Plus efficace pour les langues asiatiques

### Encodages par défaut selon les systèmes

**Windows (occidental) :**
- Console : CP850 ou CP437 (DOS)
- Applications GUI : Windows-1252 (ANSI)
- Notepad moderne : UTF-8 avec BOM
- Interne : UTF-16

**Linux/Ubuntu :**
- Presque tout : UTF-8
- Quelques vieux systèmes : ISO-8859-1
- Terminal : UTF-8

**macOS :**
- UTF-8 partout

## Détection et configuration en FreePascal

### Obtenir l'encodage système

```pascal
uses
  SysUtils;

procedure AfficherEncodageSysteme;
begin
  WriteLn('Encodage par défaut du système :');
  WriteLn('DefaultSystemCodePage : ', DefaultSystemCodePage);
  WriteLn('DefaultUnicodeCodePage : ', DefaultUnicodeCodePage);
  WriteLn('DefaultFileSystemCodePage : ', DefaultFileSystemCodePage);
  WriteLn('DefaultRTLFileSystemCodePage : ', DefaultRTLFileSystemCodePage);

  // Affichage des noms d'encodage
  case DefaultSystemCodePage of
    1252: WriteLn('Windows-1252 (Windows Latin-1)');
    65001: WriteLn('UTF-8');
    850: WriteLn('CP850 (DOS Latin-1)');
    1250: WriteLn('Windows-1250 (Europe Centrale)');
    else WriteLn('Autre encodage : ', DefaultSystemCodePage);
  end;
end;
```

### Configuration de l'encodage console

```pascal
{$IFDEF WINDOWS}
uses
  Windows;
{$ENDIF}

procedure ConfigurerConsoleUTF8;
begin
  {$IFDEF WINDOWS}
  // Sur Windows, configurer la console en UTF-8
  SetConsoleCP(CP_UTF8);        // Entrée
  SetConsoleOutputCP(CP_UTF8);  // Sortie
  WriteLn('Console Windows configurée en UTF-8');
  {$ENDIF}

  {$IFDEF UNIX}
  // Linux/Unix est généralement déjà en UTF-8
  WriteLn('Console Unix (probablement déjà en UTF-8)');
  {$ENDIF}
end;
```

## Gestion des chaînes de caractères

### Types de chaînes en FreePascal

```pascal
program TypesDeChaines;

var
  s1: AnsiString;      // Chaîne 8-bits, encodage selon système
  s2: UTF8String;      // Chaîne UTF-8 garantie
  s3: UnicodeString;   // Chaîne UTF-16
  s4: WideString;      // Chaîne UTF-16 (compatible COM sur Windows)
  s5: String;          // Type par défaut (AnsiString ou UnicodeString selon config)
  s6: RawByteString;   // Chaîne sans encodage spécifique

begin
  // Exemple avec accent
  s2 := 'Café français €';  // UTF-8
  s3 := 'Café français €';  // UTF-16

  WriteLn('Longueur UTF8String : ', Length(s2), ' caractères');
  WriteLn('Octets UTF8String : ', Length(s2) * SizeOf(s2[1]), ' octets');

  WriteLn('Longueur UnicodeString : ', Length(s3), ' caractères');
  WriteLn('Octets UnicodeString : ', Length(s3) * SizeOf(s3[1]), ' octets');
end;
```

### Conversion entre encodages

```pascal
uses
  SysUtils, LConvEncoding;

function ConvertirEncodage(const Texte: string;
                          DeEncodage, VersEncodage: string): string;
begin
  // Utilisation de l'unité LConvEncoding de Lazarus
  Result := ConvertEncoding(Texte, DeEncodage, VersEncodage);
end;

procedure ExemplesConversion;
var
  texteOriginal, texteConverti: string;
begin
  texteOriginal := 'Voilà des caractères accentués : é è ê ë €';

  // Convertir de Windows-1252 vers UTF-8
  texteConverti := ConvertEncoding(texteOriginal, 'cp1252', 'utf8');

  // Convertir de UTF-8 vers ISO-8859-1
  texteConverti := ConvertEncoding(texteOriginal, 'utf8', 'iso88591');

  // Constantes pratiques disponibles
  texteConverti := ConvertEncoding(texteOriginal, EncodingCP1252, EncodingUTF8);

  // Détecter et convertir automatiquement vers UTF-8
  texteConverti := ConvertEncodingToUTF8(texteOriginal);
end;
```

## Lecture et écriture de fichiers avec encodage

### Lecture de fichiers avec détection d'encodage

```pascal
uses
  Classes, SysUtils, LConvEncoding;

function LireFichierAvecEncodage(const NomFichier: string;
                                 DetecterAuto: Boolean = True): string;
var
  flux: TFileStream;
  octets: TBytes;
  encodageDetecte: string;
begin
  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
  try
    SetLength(octets, flux.Size);
    flux.ReadBuffer(octets[0], flux.Size);
  finally
    flux.Free;
  end;

  if DetecterAuto then
  begin
    // Détection automatique avec GuessEncoding
    encodageDetecte := GuessEncoding(PChar(@octets[0]));
    WriteLn('Encodage détecté : ', encodageDetecte);
    Result := ConvertEncodingToUTF8(TEncoding.Default.GetString(octets), encodageDetecte);
  end
  else
  begin
    // Supposer encodage système par défaut
    Result := TEncoding.Default.GetString(octets);
  end;
end;
```

### Écriture de fichiers avec encodage spécifique

```pascal
uses
  Classes, SysUtils, LConvEncoding;

procedure EcrireFichierUTF8(const NomFichier, Contenu: string;
                           AvecBOM: Boolean = False);
var
  flux: TFileStream;
  utf8Bytes: TBytes;
  bom: array[0..2] of Byte = ($EF, $BB, $BF);  // BOM UTF-8
begin
  flux := TFileStream.Create(NomFichier, fmCreate);
  try
    // Ajouter BOM si demandé (aide certains éditeurs Windows)
    if AvecBOM then
      flux.WriteBuffer(bom, 3);

    // Convertir en UTF-8 et écrire
    utf8Bytes := TEncoding.UTF8.GetBytes(Contenu);
    flux.WriteBuffer(utf8Bytes[0], Length(utf8Bytes));
  finally
    flux.Free;
  end;

  WriteLn('Fichier écrit en UTF-8',
          IfThen(AvecBOM, ' avec BOM', ' sans BOM'));
end;

procedure EcrireFichierEncodage(const NomFichier, Contenu, Encodage: string);
var
  liste: TStringList;
begin
  liste := TStringList.Create;
  try
    liste.Text := Contenu;

    // Méthode simple avec TStringList
    case LowerCase(Encodage) of
      'utf8', 'utf-8':
        liste.SaveToFile(NomFichier, TEncoding.UTF8);
      'utf16', 'utf-16':
        liste.SaveToFile(NomFichier, TEncoding.Unicode);
      'ascii':
        liste.SaveToFile(NomFichier, TEncoding.ASCII);
      else
        liste.SaveToFile(NomFichier, TEncoding.Default);
    end;
  finally
    liste.Free;
  end;
end;
```

## Le BOM (Byte Order Mark)

### Qu'est-ce que le BOM ?

Le BOM est une séquence d'octets au début d'un fichier qui indique :
- L'encodage utilisé
- L'ordre des octets (big-endian ou little-endian)

**BOM par encodage :**
- UTF-8 : EF BB BF (3 octets)
- UTF-16 LE : FF FE (2 octets)
- UTF-16 BE : FE FF (2 octets)
- UTF-32 LE : FF FE 00 00 (4 octets)

### Détecter et gérer le BOM

```pascal
type
  TBOMType = (bomNone, bomUTF8, bomUTF16LE, bomUTF16BE, bomUTF32LE, bomUTF32BE);

function DetecterBOM(const NomFichier: string): TBOMType;
var
  flux: TFileStream;
  octets: array[0..3] of Byte;
  lu: Integer;
begin
  Result := bomNone;

  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
  try
    lu := flux.Read(octets, 4);

    if lu >= 3 then
    begin
      // Vérifier UTF-8 BOM
      if (octets[0] = $EF) and (octets[1] = $BB) and (octets[2] = $BF) then
        Exit(bomUTF8);
    end;

    if lu >= 2 then
    begin
      // Vérifier UTF-16 BOM
      if (octets[0] = $FF) and (octets[1] = $FE) then
      begin
        if (lu >= 4) and (octets[2] = $00) and (octets[3] = $00) then
          Exit(bomUTF32LE)
        else
          Exit(bomUTF16LE);
      end;

      if (octets[0] = $FE) and (octets[1] = $FF) then
        Exit(bomUTF16BE);
    end;
  finally
    flux.Free;
  end;
end;

procedure LireFichierSansBOM(const NomFichier: string; out Contenu: string);
var
  flux: TFileStream;
  tailleBOM: Integer;
  octets: TBytes;
  bomType: TBOMType;
begin
  bomType := DetecterBOM(NomFichier);

  case bomType of
    bomUTF8:    tailleBOM := 3;
    bomUTF16LE,
    bomUTF16BE: tailleBOM := 2;
    bomUTF32LE,
    bomUTF32BE: tailleBOM := 4;
    else        tailleBOM := 0;
  end;

  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    // Sauter le BOM s'il existe
    flux.Seek(tailleBOM, soFromBeginning);

    SetLength(octets, flux.Size - tailleBOM);
    flux.ReadBuffer(octets[0], Length(octets));

    // Convertir selon le type détecté
    case bomType of
      bomUTF8:    Contenu := TEncoding.UTF8.GetString(octets);
      bomUTF16LE: Contenu := TEncoding.Unicode.GetString(octets);
      bomUTF16BE: Contenu := TEncoding.BigEndianUnicode.GetString(octets);
      else        Contenu := TEncoding.Default.GetString(octets);
    end;
  finally
    flux.Free;
  end;
end;
```

## Problèmes courants et solutions

### Problème 1 : Affichage incorrect des accents

```pascal
procedure CorrigerAffichageAccents;
var
  texte: string;
begin
  // Texte avec accents
  texte := 'Les élèves français étudient à l''école';

  {$IFDEF WINDOWS}
  // Sur Windows, s'assurer que la console supporte UTF-8
  SetConsoleOutputCP(CP_UTF8);
  {$ENDIF}

  // Convertir explicitement en UTF-8 pour l'affichage
  WriteLn(UTF8Encode(texte));

  // Ou utiliser UTF8String
  var texteUTF8: UTF8String;
  texteUTF8 := texte;
  WriteLn(texteUTF8);
end;
```

### Problème 2 : Fichiers CSV avec caractères spéciaux

```pascal
uses
  Classes, SysUtils, LConvEncoding;

procedure TraiterCSVMultiEncodage(const NomFichier: string);
var
  lignes: TStringList;
  i: Integer;
  ligne: string;
begin
  lignes := TStringList.Create;
  try
    // Charger en détectant l'encodage
    lignes.LoadFromFile(NomFichier);

    // Si problème d'affichage, essayer conversion explicite
    for i := 0 to lignes.Count - 1 do
    begin
      ligne := lignes[i];

      // Détecter si la ligne contient des caractères mal encodés
      if Pos('�', ligne) > 0 then
      begin
        WriteLn('Ligne mal encodée détectée, tentative de correction...');
        ligne := ConvertEncodingToUTF8(ligne, GuessEncoding(ligne));
        lignes[i] := ligne;
      end;
    end;

    // Sauvegarder en UTF-8 pour éviter les problèmes futurs
    lignes.SaveToFile(ChangeFileExt(NomFichier, '_utf8.csv'), TEncoding.UTF8);
  finally
    lignes.Free;
  end;
end;
```

### Problème 3 : Communication réseau entre systèmes

```pascal
uses
  SysUtils, Sockets;

procedure EnvoyerDonneesReseau(Socket: TSocket; const Message: string);
var
  utf8Bytes: TBytes;
begin
  // TOUJOURS utiliser UTF-8 pour la communication réseau
  utf8Bytes := TEncoding.UTF8.GetBytes(Message);

  // Envoyer la taille d'abord (pour que le récepteur sache combien lire)
  var taille: Integer := Length(utf8Bytes);
  Send(Socket, taille, SizeOf(taille), 0);

  // Puis envoyer les données
  Send(Socket, utf8Bytes[0], Length(utf8Bytes), 0);
end;

function RecevoirDonneesReseau(Socket: TSocket): string;
var
  taille: Integer;
  utf8Bytes: TBytes;
begin
  // Recevoir la taille
  Recv(Socket, taille, SizeOf(taille), 0);

  // Recevoir les données
  SetLength(utf8Bytes, taille);
  Recv(Socket, utf8Bytes[0], taille, 0);

  // Convertir de UTF-8 vers string
  Result := TEncoding.UTF8.GetString(utf8Bytes);
end;
```

## Gestion dans l'interface graphique

### Configuration des composants visuels

```pascal
procedure ConfigurerComposantsUTF8(Form: TForm);
begin
  // Pour un TEdit
  Form.Edit1.Text := UTF8Decode('Texte avec é è à ç');

  // Pour un TMemo
  Form.Memo1.Lines.Text := UTF8Decode('Première ligne accentuée' + LineEnding +
                                      'Deuxième ligne avec €');

  // Pour un TLabel
  Form.Label1.Caption := UTF8Decode('Étiquette avec accents');

  // Lazarus gère généralement bien UTF-8 automatiquement
  // mais parfois la conversion explicite est nécessaire
end;
```

### Lecture de fichiers dans l'interface

```pascal
procedure ChargerFichierDansInterface(const NomFichier: string; Memo: TMemo);
var
  flux: TFileStream;
  octets: TBytes;
  contenu: string;
  encodage: string;
begin
  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    SetLength(octets, flux.Size);
    flux.Read(octets[0], flux.Size);
  finally
    flux.Free;
  end;

  // Détection automatique de l'encodage
  encodage := GuessEncoding(PChar(@octets[0]));

  case encodage of
    EncodingUTF8:
      contenu := TEncoding.UTF8.GetString(octets);
    EncodingCP1252:
      contenu := TEncoding.GetEncoding(1252).GetString(octets);
    else
      contenu := TEncoding.Default.GetString(octets);
  end;

  // Afficher dans le Memo
  Memo.Lines.Text := contenu;

  // Afficher l'encodage détecté dans la barre de statut
  Application.MainForm.Caption := Format('Fichier : %s [%s]',
                                        [ExtractFileName(NomFichier), encodage]);
end;
```

## Base de données et encodages

### Configuration de la connexion

```pascal
uses
  SQLdb;

procedure ConfigurerConnexionUTF8(Connection: TSQLConnection);
begin
  // Pour MySQL/MariaDB
  if Connection is TMySQL57Connection then
  begin
    Connection.CharSet := 'utf8mb4';  // Support complet UTF-8 incluant emojis
    Connection.Params.Add('charset=utf8mb4');
  end;

  // Pour PostgreSQL
  if Connection is TPQConnection then
  begin
    Connection.CharSet := 'UTF8';
    Connection.Params.Add('client_encoding=UTF8');
  end;

  // Pour SQLite
  if Connection is TSQLite3Connection then
  begin
    // SQLite utilise UTF-8 par défaut
    Connection.Params.Add('StringFormat=Unicode');
  end;

  // Pour Firebird
  if Connection is TIBConnection then
  begin
    Connection.CharSet := 'UTF8';
    Connection.Params.Add('lc_ctype=UTF8');
  end;
end;
```

### Insertion et récupération de données

```pascal
procedure GererDonneesUnicode(Connection: TSQLConnection);
var
  query: TSQLQuery;
  texteAvecEmoji: string;
begin
  texteAvecEmoji := 'Bonjour 😊 Ça va? €100 北京';

  query := TSQLQuery.Create(nil);
  try
    query.Database := Connection;

    // Insertion
    query.SQL.Text := 'INSERT INTO messages (contenu) VALUES (:contenu)';
    query.ParamByName('contenu').AsString := UTF8Encode(texteAvecEmoji);
    query.ExecSQL;

    // Lecture
    query.SQL.Text := 'SELECT contenu FROM messages';
    query.Open;

    while not query.EOF do
    begin
      WriteLn('Message : ', UTF8Decode(query.FieldByName('contenu').AsString));
      query.Next;
    end;
  finally
    query.Free;
  end;
end;
```

## Configuration de projet pour UTF-8

### Directives de compilation

```pascal
{$codepage UTF8}           // Force UTF-8 pour les constantes string
{$mode objfpc}{$H+}       // Mode Object Pascal avec strings longues

program MonProgrammeUTF8;

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  Classes, SysUtils;

begin
  // Configuration globale UTF-8
  SetMultiByteConversionCodePage(CP_UTF8);
  SetMultiByteFileSystemCodePage(CP_UTF8);
  SetMultiByteRTLFileSystemCodePage(CP_UTF8);

  WriteLn('Programme configuré en UTF-8');
end.
```

### Options de projet Lazarus

```xml
<!-- Dans le fichier .lpi du projet -->
<CompilerOptions>
  <Target>
    <Filename Value="monprojet"/>
  </Target>
  <SearchPaths>
    <IncludeFiles Value="$(ProjOutDir)"/>
  </SearchPaths>
  <Parsing>
    <SyntaxOptions>
      <UseAnsiStrings Value="False"/>  <!-- Utiliser UnicodeString -->
    </SyntaxOptions>
  </Parsing>
  <CodeGeneration>
    <SmartLinkUnit Value="True"/>
  </CodeGeneration>
  <Other>
    <!-- Force UTF-8 -->
    <CustomOptions Value="-FcUTF8"/>
  </Other>
</CompilerOptions>
```

## Outils de débogage pour les encodages

### Analyser un fichier

```pascal
procedure AnalyserEncodageFichier(const NomFichier: string);
var
  flux: TFileStream;
  echantillon: array[0..1023] of Byte;
  lu: Integer;
  i: Integer;
  aASCII, aUTF8Valide, aLatin1: Boolean;
  sequenceUTF8: Integer;
begin
  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    lu := flux.Read(echantillon, SizeOf(echantillon));

    aASCII := True;
    aUTF8Valide := True;
    aLatin1 := False;
    sequenceUTF8 := 0;

    for i := 0 to lu - 1 do
    begin
      // Vérifier ASCII pur
      if echantillon[i] > 127 then
        aASCII := False;

      // Vérifier séquences UTF-8
      if sequenceUTF8 > 0 then
      begin
        if (echantillon[i] and $C0) <> $80 then
          aUTF8Valide := False;
        Dec(sequenceUTF8);
      end
      else if echantillon[i] >= $80 then
      begin
        if (echantillon[i] and $E0) = $C0 then
          sequenceUTF8 := 1
        else if (echantillon[i] and $F0) = $E0 then
          sequenceUTF8 := 2
        else if (echantillon[i] and $F8) = $F0 then
          sequenceUTF8 := 3
        else if echantillon[i] >= $A0 then
          aLatin1 := True;
      end;
    end;

    WriteLn('Analyse du fichier : ', NomFichier);
    WriteLn('Taille échantillon : ', lu, ' octets');

    if aASCII then
      WriteLn('=> ASCII pur (7-bit)')
    else if aUTF8Valide and (sequenceUTF8 = 0) then
      WriteLn('=> UTF-8 valide')
    else if aLatin1 then
      WriteLn('=> Probablement ISO-8859-1 ou Windows-1252')
    else
      WriteLn('=> Encodage inconnu ou fichier binaire');

    // Vérifier BOM
    case DetecterBOM(NomFichier) of
      bomUTF8:    WriteLn('   BOM UTF-8 détecté');
      bomUTF16LE: WriteLn('   BOM UTF-16 LE détecté');
      bomUTF16BE: WriteLn('   BOM UTF-16 BE détecté');
    end;
  finally
    flux.Free;
  end;
end;
```

### Afficher les codes des caractères

```pascal
procedure AfficherCodesCaracteres(const Texte: string);
var
  i: Integer;
  c: Char;
  utf8Bytes: TBytes;
begin
  WriteLn('Analyse caractère par caractère :');
  WriteLn('-----------------------------------');

  for i := 1 to Length(Texte) do
  begin
    c := Texte[i];
    Write(Format('"%s" : ', [c]));
    Write(Format('Code=%d (0x%2.2X) ', [Ord(c), Ord(c)]));

    // Afficher les octets UTF-8
    utf8Bytes := TEncoding.UTF8.GetBytes(c);
    Write('UTF-8=[');
    for var b in utf8Bytes do
      Write(Format('0x%2.2X ', [b]));
    Write('] ');

    WriteLn;
  end;
end;

// Utilisation
begin
  AfficherCodesCaracteres('Café €');
  // Affichera quelque chose comme :
  // "C" : Code=67 (0x43) UTF-8=[0x43]
  // "a" : Code=97 (0x61) UTF-8=[0x61]
  // "f" : Code=102 (0x66) UTF-8=[0x66]
  // "é" : Code=233 (0xE9) UTF-8=[0xC3 0xA9]
  // " " : Code=32 (0x20) UTF-8=[0x20]
  // "€" : Code=8364 (0x20AC) UTF-8=[0xE2 0x82 0xAC]
end;
```

## Exemple complet : Éditeur de texte multi-encodage

```pascal
program EditeurMultiEncodage;

uses
  SysUtils, Classes, LConvEncoding;

type
  TEditeurEncodage = class
  private
    FContenu: string;
    FEncodageActuel: string;
    FNomFichier: string;
  public
    constructor Create;

    procedure ChargerFichier(const NomFichier: string);
    procedure SauvegarderFichier(const NomFichier: string;
                                const Encodage: string = '');
    procedure ConvertirEncodage(const NouvelEncodage: string);
    procedure AfficherInfos;

    property Contenu: string read FContenu write FContenu;
    property EncodageActuel: string read FEncodageActuel;
  end;

constructor TEditeurEncodage.Create;
begin
  FEncodageActuel := EncodingUTF8;
  FContenu := '';
end;

procedure TEditeurEncodage.ChargerFichier(const NomFichier: string);
var
  flux: TFileStream;
  octets: TBytes;
  bomType: TBOMType;
  decalage: Integer;
begin
  FNomFichier := NomFichier;

  // Détecter BOM
  bomType := DetecterBOM(NomFichier);
  case bomType of
    bomUTF8:    begin decalage := 3; FEncodageActuel := EncodingUTF8; end;
    bomUTF16LE: begin decalage := 2; FEncodageActuel := EncodingUCS2LE; end;
    bomUTF16BE: begin decalage := 2; FEncodageActuel := EncodingUCS2BE; end;
    else        begin decalage := 0; FEncodageActuel := ''; end;
  end;

  // Lire le fichier
  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
  try
    flux.Seek(decalage, soFromBeginning);
    SetLength(octets, flux.Size - decalage);
    if Length(octets) > 0 then
      flux.ReadBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;

  // Si pas de BOM, essayer de détecter l'encodage
  if FEncodageActuel = '' then
  begin
    FEncodageActuel := GuessEncoding(PChar(@octets[0]));
    WriteLn('Encodage auto-détecté : ', FEncodageActuel);
  end
  else
    WriteLn('BOM détecté, encodage : ', FEncodageActuel);

  // Convertir en string selon l'encodage
  case FEncodageActuel of
    EncodingUTF8:
      FContenu := TEncoding.UTF8.GetString(octets);
    EncodingUCS2LE:
      FContenu := TEncoding.Unicode.GetString(octets);
    EncodingUCS2BE:
      FContenu := TEncoding.BigEndianUnicode.GetString(octets);
    EncodingCP1252:
      FContenu := TEncoding.GetEncoding(1252).GetString(octets);
    else
      // Par défaut, utiliser l'encodage système
      FContenu := TEncoding.Default.GetString(octets);
  end;

  WriteLn('Fichier chargé : ', ExtractFileName(NomFichier));
  WriteLn('Taille : ', Length(FContenu), ' caractères');
end;

procedure TEditeurEncodage.SauvegarderFichier(const NomFichier: string;
                                              const Encodage: string = '');
var
  flux: TFileStream;
  octets: TBytes;
  encodageUtilise: string;
  ajouterBOM: Boolean;
  bom: array[0..3] of Byte;
  bomTaille: Integer;
begin
  // Déterminer l'encodage à utiliser
  if Encodage <> '' then
    encodageUtilise := Encodage
  else
    encodageUtilise := FEncodageActuel;

  ajouterBOM := False;
  bomTaille := 0;

  // Préparer le BOM si nécessaire
  case encodageUtilise of
    EncodingUTF8:
      begin
        // Optionnel pour UTF-8, mais aide certains éditeurs Windows
        if MessageDlg('Ajouter BOM UTF-8?', mtConfirmation, [mbYes, mbNo], 0) = mrYes then
        begin
          ajouterBOM := True;
          bom[0] := $EF; bom[1] := $BB; bom[2] := $BF;
          bomTaille := 3;
        end;
        octets := TEncoding.UTF8.GetBytes(FContenu);
      end;

    EncodingUCS2LE:
      begin
        ajouterBOM := True;
        bom[0] := $FF; bom[1] := $FE;
        bomTaille := 2;
        octets := TEncoding.Unicode.GetBytes(FContenu);
      end;

    EncodingUCS2BE:
      begin
        ajouterBOM := True;
        bom[0] := $FE; bom[1] := $FF;
        bomTaille := 2;
        octets := TEncoding.BigEndianUnicode.GetBytes(FContenu);
      end;

    EncodingCP1252:
      octets := TEncoding.GetEncoding(1252).GetBytes(FContenu);

    else
      octets := TEncoding.Default.GetBytes(FContenu);
  end;

  // Écrire le fichier
  flux := TFileStream.Create(NomFichier, fmCreate);
  try
    // Écrire BOM si nécessaire
    if ajouterBOM then
      flux.WriteBuffer(bom[0], bomTaille);

    // Écrire le contenu
    if Length(octets) > 0 then
      flux.WriteBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;

  FEncodageActuel := encodageUtilise;
  WriteLn('Fichier sauvegardé : ', ExtractFileName(NomFichier));
  WriteLn('Encodage : ', encodageUtilise);
  if ajouterBOM then
    WriteLn('BOM ajouté');
end;

procedure TEditeurEncodage.ConvertirEncodage(const NouvelEncodage: string);
begin
  WriteLn('Conversion de ', FEncodageActuel, ' vers ', NouvelEncodage);

  // La conversion est implicite car FContenu est en Unicode interne
  // Il suffit de changer l'encodage pour la prochaine sauvegarde
  FEncodageActuel := NouvelEncodage;

  WriteLn('Conversion effectuée (sera appliquée à la sauvegarde)');
end;

procedure TEditeurEncodage.AfficherInfos;
var
  i: Integer;
  nbASCII, nbLatin1, nbUnicode: Integer;
begin
  WriteLn('=== Informations sur le contenu ===');
  WriteLn('Encodage actuel : ', FEncodageActuel);
  WriteLn('Nombre de caractères : ', Length(FContenu));

  // Analyser les caractères
  nbASCII := 0;
  nbLatin1 := 0;
  nbUnicode := 0;

  for i := 1 to Length(FContenu) do
  begin
    if Ord(FContenu[i]) < 128 then
      Inc(nbASCII)
    else if Ord(FContenu[i]) < 256 then
      Inc(nbLatin1)
    else
      Inc(nbUnicode);
  end;

  WriteLn('Caractères ASCII (0-127) : ', nbASCII);
  WriteLn('Caractères Latin-1 (128-255) : ', nbLatin1);
  WriteLn('Caractères Unicode (>255) : ', nbUnicode);

  // Afficher les premiers caractères
  Write('Début du texte : "');
  for i := 1 to Min(50, Length(FContenu)) do
  begin
    if FContenu[i] in [#13, #10] then
      Write('¶')
    else
      Write(FContenu[i]);
  end;
  WriteLn('"...');
end;

// Programme principal de test
var
  editeur: TEditeurEncodage;
  choix: string;
begin
  {$IFDEF WINDOWS}
  SetConsoleCP(CP_UTF8);
  SetConsoleOutputCP(CP_UTF8);
  {$ENDIF}

  editeur := TEditeurEncodage.Create;
  try
    WriteLn('=== Éditeur Multi-Encodage ===');
    WriteLn;

    // Test 1 : Créer et sauvegarder en différents encodages
    editeur.Contenu := 'Test avec accents : é è à ç ù' + LineEnding +
                      'Symboles : € £ ¥' + LineEnding +
                      'Autres : œ æ ñ ø' + LineEnding +
                      'Emoji : 😊 (si supporté)';

    editeur.AfficherInfos;
    WriteLn;

    // Sauvegarder en UTF-8
    editeur.SauvegarderFichier('test_utf8.txt', EncodingUTF8);

    // Sauvegarder en Windows-1252
    editeur.ConvertirEncodage(EncodingCP1252);
    editeur.SauvegarderFichier('test_cp1252.txt');

    // Sauvegarder en UTF-16
    editeur.ConvertirEncodage(EncodingUCS2LE);
    editeur.SauvegarderFichier('test_utf16.txt');

    WriteLn;
    WriteLn('Test 2 : Recharger les fichiers');
    WriteLn;

    // Recharger et vérifier
    editeur.ChargerFichier('test_utf8.txt');
    editeur.AfficherInfos;

    WriteLn;
    editeur.ChargerFichier('test_cp1252.txt');
    editeur.AfficherInfos;

  finally
    editeur.Free;
  end;

  WriteLn;
  WriteLn('Appuyez sur Entrée pour terminer...');
  ReadLn;
end.
```

## Bonnes pratiques pour la gestion des encodages

### 1. Standardiser sur UTF-8

UTF-8 est le meilleur choix pour la portabilité :

```pascal
// ✅ BON : Utiliser UTF-8 partout
procedure InitialiserApplicationUTF8;
begin
  {$IFDEF WINDOWS}
  // Configurer Windows pour UTF-8
  SetConsoleCP(CP_UTF8);
  SetConsoleOutputCP(CP_UTF8);
  {$ENDIF}

  // Configurer FreePascal pour UTF-8
  SetMultiByteConversionCodePage(CP_UTF8);
  SetMultiByteFileSystemCodePage(CP_UTF8);

  // Utiliser UTF-8 pour tous les fichiers
  DefaultSystemCodePage := CP_UTF8;
end;

// ❌ MAUVAIS : Mélanger les encodages
procedure MauvaiseGestion;
var
  texte: string;
begin
  // Ne pas faire ça !
  texte := LoadFromFile('data.txt');  // Encodage inconnu
  SaveToFile('output.txt', texte);    // Encodage système par défaut
end;
```

### 2. Toujours spécifier l'encodage explicitement

```pascal
// ✅ BON : Encodage explicite
procedure BonneGestionFichiers;
var
  liste: TStringList;
begin
  liste := TStringList.Create;
  try
    // Charger avec encodage spécifique
    liste.LoadFromFile('data.txt', TEncoding.UTF8);

    // Traiter...

    // Sauvegarder avec encodage spécifique
    liste.SaveToFile('output.txt', TEncoding.UTF8);
  finally
    liste.Free;
  end;
end;

// ❌ MAUVAIS : Encodage implicite
procedure MauvaiseGestionFichiers;
var
  liste: TStringList;
begin
  liste := TStringList.Create;
  try
    liste.LoadFromFile('data.txt');  // Utilise l'encodage par défaut
    liste.SaveToFile('output.txt');  // Peut être différent !
  finally
    liste.Free;
  end;
end;
```

### 3. Gérer les erreurs d'encodage

```pascal
procedure GestionRobuste(const NomFichier: string);
var
  contenu: string;
  encodages: array[0..3] of string = (EncodingUTF8, EncodingCP1252,
                                      EncodingAnsi, EncodingUTF16LE);
  i: Integer;
  succes: Boolean;
begin
  succes := False;

  // Essayer plusieurs encodages
  for i := 0 to High(encodages) do
  begin
    try
      contenu := ConvertEncodingToUTF8(LoadFileToString(NomFichier), encodages[i]);

      // Vérifier si le résultat semble correct
      if Pos('�', contenu) = 0 then
      begin
        WriteLn('Encodage détecté : ', encodages[i]);
        succes := True;
        Break;
      end;
    except
      on E: Exception do
        WriteLn('Échec avec ', encodages[i], ': ', E.Message);
    end;
  end;

  if not succes then
    raise Exception.Create('Impossible de déterminer l''encodage du fichier');
end;
```

### 4. Documenter les encodages utilisés

```pascal
{ Configuration d'encodage pour ce projet :
  - Tous les fichiers sources : UTF-8 sans BOM
  - Fichiers de configuration : UTF-8 avec BOM (compatibilité Windows)
  - Communication réseau : UTF-8
  - Base de données : UTF-8 (charset utf8mb4 pour MySQL)
  - Fichiers d'export : Windows-1252 pour Excel ancien, UTF-8 pour le reste }

type
  TEncodageProjet = (
    epSource,      // UTF-8 sans BOM
    epConfig,      // UTF-8 avec BOM
    epReseau,      // UTF-8
    epBaseDonnees, // UTF-8
    epExportExcel, // Windows-1252
    epExportTexte  // UTF-8
  );

function ObtenirEncodage(TypeFichier: TEncodageProjet): string;
begin
  case TypeFichier of
    epSource, epReseau, epBaseDonnees, epExportTexte:
      Result := EncodingUTF8;
    epConfig:
      Result := EncodingUTF8BOM;
    epExportExcel:
      Result := EncodingCP1252;
  end;
end;
```

## Cas d'usage spécifiques

### Importation de fichiers Excel/CSV

```pascal
procedure ImporterCSV(const NomFichier: string);
var
  lignes: TStringList;
  encodageDetecte: string;
  separateur: Char;
begin
  lignes := TStringList.Create;
  try
    // Excel exporte souvent en Windows-1252 ou UTF-16
    encodageDetecte := GuessEncoding(LoadFileToString(NomFichier));

    if encodageDetecte = EncodingUTF16LE then
    begin
      // Excel moderne avec Unicode
      lignes.LoadFromFile(NomFichier, TEncoding.Unicode);
    end
    else if encodageDetecte = EncodingCP1252 then
    begin
      // Excel ancien ou export standard
      lignes.LoadFromFile(NomFichier, TEncoding.GetEncoding(1252));
    end
    else
    begin
      // Essayer UTF-8 par défaut
      lignes.LoadFromFile(NomFichier, TEncoding.UTF8);
    end;

    // Détecter le séparateur (peut varier selon les régions)
    if Pos(#9, lignes.Text) > 0 then
      separateur := #9  // Tab
    else if Pos(';', lignes.Text) > Pos(',', lignes.Text) then
      separateur := ';'  // Point-virgule (Europe)
    else
      separateur := ','; // Virgule (US/UK)

    lignes.Delimiter := separateur;
    lignes.StrictDelimiter := True;

    // Traiter les données...
    ProcesserDonneesCSV(lignes);

  finally
    lignes.Free;
  end;
end;
```

### Génération de rapports HTML

```pascal
procedure GenererRapportHTML(const Titre, Contenu: string;
                            const NomFichier: string);
var
  html: TStringList;
begin
  html := TStringList.Create;
  try
    html.Add('<!DOCTYPE html>');
    html.Add('<html lang="fr">');
    html.Add('<head>');
    html.Add('  <meta charset="UTF-8">');  // Déclaration UTF-8
    html.Add('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
    html.Add('  <title>' + HTMLEncode(Titre) + '</title>');
    html.Add('</head>');
    html.Add('<body>');
    html.Add('  <h1>' + HTMLEncode(Titre) + '</h1>');
    html.Add('  <div class="content">');
    html.Add('    ' + HTMLEncode(Contenu));
    html.Add('  </div>');
    html.Add('</body>');
    html.Add('</html>');

    // Sauvegarder en UTF-8 pour compatibilité maximale
    html.SaveToFile(NomFichier, TEncoding.UTF8);

    WriteLn('Rapport HTML généré : ', NomFichier);
  finally
    html.Free;
  end;
end;

function HTMLEncode(const S: string): string;
begin
  Result := StringReplace(S, '&', '&amp;', [rfReplaceAll]);
  Result := StringReplace(Result, '<', '&lt;', [rfReplaceAll]);
  Result := StringReplace(Result, '>', '&gt;', [rfReplaceAll]);
  Result := StringReplace(Result, '"', '&quot;', [rfReplaceAll]);
  Result := StringReplace(Result, '''', '&#39;', [rfReplaceAll]);
end;
```

### Logs multi-plateformes

```pascal
type
  TLoggerMultiPlateforme = class
  private
    FNomFichier: string;
    FEncodage: TEncoding;
  public
    constructor Create(const NomFichier: string);
    destructor Destroy; override;
    procedure Log(const Message: string);
    procedure LogErreur(const Erreur: string);
  end;

constructor TLoggerMultiPlateforme.Create(const NomFichier: string);
begin
  FNomFichier := NomFichier;

  // UTF-8 pour tous les logs (portable)
  FEncodage := TEncoding.UTF8;

  // Créer le fichier avec BOM pour meilleure compatibilité Windows
  if not FileExists(FNomFichier) then
  begin
    var flux := TFileStream.Create(FNomFichier, fmCreate);
    try
      // Ajouter BOM UTF-8
      var bom: array[0..2] of Byte = ($EF, $BB, $BF);
      flux.WriteBuffer(bom, 3);
    finally
      flux.Free;
    end;
  end;
end;

procedure TLoggerMultiPlateforme.Log(const Message: string);
var
  flux: TFileStream;
  ligne: string;
  octets: TBytes;
begin
  ligne := FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' | INFO | ' +
           Message + LineEnding;

  octets := FEncodage.GetBytes(ligne);

  flux := TFileStream.Create(FNomFichier, fmOpenWrite or fmShareDenyWrite);
  try
    flux.Seek(0, soFromEnd);
    flux.WriteBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;
end;

procedure TLoggerMultiPlateforme.LogErreur(const Erreur: string);
begin
  Log('ERREUR : ' + Erreur);
end;
```

## Tableau récapitulatif des encodages

| Aspect | Windows | Linux/Ubuntu | Solution FreePascal |
|--------|---------|--------------|-------------------|
| **Console** | CP850/CP437 | UTF-8 | SetConsoleCP(CP_UTF8) |
| **GUI** | Windows-1252 | UTF-8 | UTF8String |
| **Fichiers texte** | ANSI/UTF-16 | UTF-8 | TEncoding.UTF8 |
| **BOM** | Souvent présent | Rarement utilisé | Détecter avec DetecterBOM() |
| **Base de données** | Varie | UTF-8 | CharSet := 'UTF8' |
| **Web** | UTF-8 recommandé | UTF-8 | Content-Type: charset=utf-8 |
| **Source code** | ANSI ou UTF-8 | UTF-8 | {$codepage UTF8} |

## Points clés à retenir

1. **UTF-8 est votre ami** : C'est le seul encodage vraiment universel et portable

2. **Soyez explicite** : Spécifiez toujours l'encodage au lieu de compter sur les valeurs par défaut

3. **Testez sur les deux plateformes** : Un fichier qui s'affiche bien sur Windows peut avoir des problèmes sur Linux et vice versa

4. **Gérez le BOM avec soin** : Windows l'aime, Linux ne l'exige pas, détectez-le toujours

5. **Convertissez aux frontières** : Lors de l'import/export, convertissez immédiatement vers votre encodage interne (UTF-8)

6. **Documentez vos choix** : Indiquez clairement quel encodage est utilisé pour chaque type de fichier

## Conclusion

La gestion correcte des encodages est essentielle pour créer des applications FreePascal/Lazarus véritablement portables. Les différences entre Windows (souvent Windows-1252) et Linux (UTF-8 quasi-universel) peuvent causer des problèmes subtils mais frustrants.

En suivant les bonnes pratiques présentées dans ce tutoriel - notamment l'utilisation systématique d'UTF-8, la spécification explicite des encodages et la gestion appropriée du BOM - vous pouvez créer des applications robustes qui fonctionnent parfaitement sur toutes les plateformes, quelle que soit la langue ou les caractères spéciaux utilisés.

N'oubliez pas : quand vous voyez des caractères � ou □, c'est presque toujours un problème d'encodage. Avec les outils et techniques présentés ici, vous saurez les diagnostiquer et les résoudre efficacement.

⏭️ [Sensibilité à la casse](/05-developpement-multiplateforme-approfondi/03.4-sensibilite-casse.md)
