üîù Retour au [Sommaire](/SOMMAIRE.md)

# PostgreSQL avec FreePascal/Lazarus - Guide Complet pour D√©butants

## Introduction √† PostgreSQL

### Qu'est-ce que PostgreSQL ?

PostgreSQL (souvent abr√©g√© "Postgres") est un syst√®me de gestion de base de donn√©es relationnelle-objet (SGBDRO) open source, reconnu pour sa fiabilit√©, sa robustesse et ses fonctionnalit√©s avanc√©es. C'est l'un des SGBD les plus respect√©s dans l'industrie, utilis√© aussi bien par des startups que par de grandes entreprises.

### Pourquoi choisir PostgreSQL ?

1. **Gratuit et open source** : Aucune licence √† payer, m√™me pour un usage commercial
2. **Tr√®s fiable** : Con√ßu pour ne jamais perdre vos donn√©es
3. **Conforme aux standards** : Respect strict du SQL standard
4. **Extensible** : Possibilit√© d'ajouter des types et fonctions personnalis√©es
5. **Performant** : Optimiseur de requ√™tes sophistiqu√©
6. **Multi-plateforme** : Fonctionne identiquement sur Windows et Linux
7. **Support JSON** : Id√©al pour les donn√©es semi-structur√©es
8. **ACID complet** : Garantit l'int√©grit√© des transactions

### Cas d'usage typiques

- Applications d'entreprise n√©cessitant une fiabilit√© maximale
- Syst√®mes g√©ographiques (avec l'extension PostGIS)
- Applications web √† forte charge
- Syst√®mes analytiques et data warehouses
- Applications financi√®res n√©cessitant des transactions complexes

## Installation de PostgreSQL

### Installation sur Windows

#### M√©thode 1 : Installateur officiel

1. T√©l√©charger depuis https://www.postgresql.org/download/windows/
2. Lancer l'installateur EDB
3. Choisir les composants :
   - PostgreSQL Server (obligatoire)
   - pgAdmin 4 (interface graphique recommand√©e)
   - Stack Builder (pour extensions)
   - Command Line Tools

4. Configuration pendant l'installation :
   ```
   Port : 5432 (par d√©faut)
   Superutilisateur : postgres
   Mot de passe : [choisir un mot de passe fort]
   Locale : French_France.1252 ou Default
   ```

#### M√©thode 2 : Via Chocolatey

```powershell
# Dans PowerShell en administrateur
choco install postgresql
```

### Installation sur Linux/Ubuntu

#### Installation via APT

```bash
# Mise √† jour des paquets
sudo apt update

# Installation du serveur et client
sudo apt install postgresql postgresql-client

# Installation des outils de d√©veloppement (pour la biblioth√®que cliente)
sudo apt install postgresql-server-dev-all

# V√©rification de l'installation
sudo systemctl status postgresql
```

#### Configuration post-installation Ubuntu

```bash
# Se connecter en tant que postgres
sudo -u postgres psql

# Cr√©er un utilisateur pour votre application
CREATE USER monapp WITH PASSWORD 'motdepasse';

# Cr√©er une base de donn√©es
CREATE DATABASE mabase OWNER monapp;

# Donner tous les droits sur la base
GRANT ALL PRIVILEGES ON DATABASE mabase TO monapp;

# Quitter
\q
```

### Installation de la biblioth√®que cliente uniquement

Si le serveur PostgreSQL est sur une autre machine :

#### Windows
T√©l√©charger libpq.dll depuis le site PostgreSQL ou copier depuis une installation compl√®te.

#### Linux/Ubuntu
```bash
# Installer uniquement le client
sudo apt install libpq-dev
```

## Configuration de PostgreSQL pour FreePascal/Lazarus

### Le composant TPQConnection

TPQConnection est le composant Lazarus d√©di√© √† PostgreSQL. Il offre un acc√®s natif optimis√©.

```pascal
uses
  PQConnection;  // Unit√© pour PostgreSQL

var
  PGConnection: TPQConnection;
begin
  PGConnection := TPQConnection.Create(nil);
  try
    // Configuration de base
    PGConnection.HostName := 'localhost';
    PGConnection.DatabaseName := 'mabase';
    PGConnection.UserName := 'monapp';
    PGConnection.Password := 'motdepasse';
    PGConnection.Port := 5432;  // Port par d√©faut

    // Tentative de connexion
    PGConnection.Open;
    ShowMessage('Connect√© √† PostgreSQL !');
  finally
    PGConnection.Free;
  end;
end;
```

### Configuration dans l'IDE Lazarus

1. D√©poser un `TPQConnection` sur la fiche
2. Dans l'inspecteur d'objets, configurer :
   - **DatabaseName** : nom de votre base
   - **HostName** : localhost ou IP du serveur
   - **UserName** : utilisateur PostgreSQL
   - **Password** : mot de passe
   - **Port** : 5432 (sauf si modifi√©)

### Param√®tres de connexion avanc√©s

```pascal
// Param√®tres suppl√©mentaires via Params
PGConnection.Params.Add('sslmode=require');           // Forcer SSL
PGConnection.Params.Add('connect_timeout=10');        // Timeout en secondes
PGConnection.Params.Add('client_encoding=UTF8');      // Encodage
PGConnection.Params.Add('application_name=MonApp');   // Nom de l'application
PGConnection.Params.Add('search_path=public,monschema'); // Sch√©mas
```

## Sp√©cificit√©s PostgreSQL dans FreePascal

### Types de donn√©es PostgreSQL vs Pascal

| PostgreSQL | Pascal/Lazarus | Notes |
|------------|---------------|--------|
| INTEGER | Integer | 32 bits |
| BIGINT | Int64 | 64 bits |
| SMALLINT | SmallInt | 16 bits |
| SERIAL | Integer | Auto-incr√©ment√© |
| BIGSERIAL | Int64 | Auto-incr√©ment√© 64 bits |
| REAL | Single | Flottant simple pr√©cision |
| DOUBLE PRECISION | Double | Flottant double pr√©cision |
| NUMERIC/DECIMAL | Currency ou BCD | Pr√©cision d√©cimale exacte |
| VARCHAR/TEXT | String/AnsiString | Texte variable |
| CHAR | String[n] | Texte fixe |
| DATE | TDate | Date seule |
| TIME | TTime | Heure seule |
| TIMESTAMP | TDateTime | Date et heure |
| BOOLEAN | Boolean | Vrai/Faux |
| BYTEA | TBytes/TBlobField | Donn√©es binaires |
| UUID | TGUID/String | Identifiant unique |
| JSON/JSONB | String/Variant | Donn√©es JSON |
| ARRAY | Array dynamique | Tableaux |

### Gestion des s√©quences (SERIAL)

PostgreSQL utilise des s√©quences pour les colonnes auto-incr√©ment√©es :

```pascal
// R√©cup√©rer la derni√®re valeur ins√©r√©e
procedure InsertAndGetID;
var
  NewID: Integer;
begin
  // M√©thode 1 : RETURNING
  SQLQuery.SQL.Text := 'INSERT INTO clients (nom, email) ' +
                      'VALUES (:nom, :email) RETURNING id';
  SQLQuery.ParamByName('nom').AsString := 'Dupont';
  SQLQuery.ParamByName('email').AsString := 'dupont@email.com';
  SQLQuery.Open;
  NewID := SQLQuery.FieldByName('id').AsInteger;
  SQLQuery.Close;

  // M√©thode 2 : lastval()
  SQLQuery.SQL.Text := 'INSERT INTO clients (nom, email) VALUES (:nom, :email)';
  SQLQuery.ParamByName('nom').AsString := 'Martin';
  SQLQuery.ParamByName('email').AsString := 'martin@email.com';
  SQLQuery.ExecSQL;

  SQLQuery.SQL.Text := 'SELECT lastval()';
  SQLQuery.Open;
  NewID := SQLQuery.Fields[0].AsInteger;
  SQLQuery.Close;
end;
```

### Gestion des sch√©mas

PostgreSQL organise les tables dans des sch√©mas :

```pascal
// Sp√©cifier le sch√©ma dans les requ√™tes
SQLQuery.SQL.Text := 'SELECT * FROM monschema.matable';

// Ou d√©finir le search_path
PGConnection.ExecuteDirect('SET search_path TO monschema, public');

// Cr√©er un nouveau sch√©ma
PGConnection.ExecuteDirect('CREATE SCHEMA IF NOT EXISTS monapp');

// Lister les sch√©mas
SQLQuery.SQL.Text := 'SELECT schema_name FROM information_schema.schemata';
SQLQuery.Open;
```

### Arrays PostgreSQL

PostgreSQL supporte les tableaux natifs :

```pascal
// Insertion d'un tableau
SQLQuery.SQL.Text := 'INSERT INTO produits (nom, tags) VALUES (:nom, :tags)';
SQLQuery.ParamByName('nom').AsString := 'Ordinateur';
SQLQuery.ParamByName('tags').AsString := '{informatique,bureautique,portable}';
SQLQuery.ExecSQL;

// Lecture d'un tableau
SQLQuery.SQL.Text := 'SELECT tags FROM produits WHERE id = :id';
SQLQuery.ParamByName('id').AsInteger := 1;
SQLQuery.Open;
// Le r√©sultat est une cha√Æne comme : {tag1,tag2,tag3}
var
  Tags: string;
  TagList: TStringList;
begin
  Tags := SQLQuery.FieldByName('tags').AsString;
  // Parser le tableau
  Tags := Copy(Tags, 2, Length(Tags) - 2); // Enlever {}
  TagList := TStringList.Create;
  try
    TagList.Delimiter := ',';
    TagList.DelimitedText := Tags;
    // Utiliser TagList
  finally
    TagList.Free;
  end;
end;
```

## Fonctionnalit√©s avanc√©es de PostgreSQL

### Support JSON/JSONB

PostgreSQL excelle dans le stockage de donn√©es JSON :

```pascal
// Cr√©er une table avec JSONB
PGConnection.ExecuteDirect(
  'CREATE TABLE IF NOT EXISTS evenements (' +
  'id SERIAL PRIMARY KEY,' +
  'donnees JSONB NOT NULL)'
);

// Ins√©rer du JSON
SQLQuery.SQL.Text := 'INSERT INTO evenements (donnees) VALUES (:json)';
SQLQuery.ParamByName('json').AsString :=
  '{"type": "connexion", "user": "jean", "timestamp": "2024-01-01T10:00:00"}';
SQLQuery.ExecSQL;

// Requ√™te sur du JSON
SQLQuery.SQL.Text :=
  'SELECT * FROM evenements ' +
  'WHERE donnees @> ''{"type": "connexion"}''';
SQLQuery.Open;

// Extraire une valeur JSON
SQLQuery.SQL.Text :=
  'SELECT donnees->>''user'' as utilisateur FROM evenements';
SQLQuery.Open;
```

### Proc√©dures stock√©es et fonctions

```pascal
// Cr√©er une fonction
PGConnection.ExecuteDirect(
  'CREATE OR REPLACE FUNCTION calculer_tva(montant NUMERIC) ' +
  'RETURNS NUMERIC AS $$ ' +
  'BEGIN ' +
  '  RETURN montant * 1.20; ' +
  'END; ' +
  '$$ LANGUAGE plpgsql'
);

// Appeler la fonction
SQLQuery.SQL.Text := 'SELECT calculer_tva(:montant) as montant_ttc';
SQLQuery.ParamByName('montant').AsFloat := 100.00;
SQLQuery.Open;
ShowMessage('Montant TTC: ' + SQLQuery.FieldByName('montant_ttc').AsString);

// Proc√©dure avec param√®tres OUT
PGConnection.ExecuteDirect(
  'CREATE OR REPLACE PROCEDURE get_stats(' +
  '  OUT total_clients INTEGER,' +
  '  OUT total_commandes INTEGER) ' +
  'LANGUAGE plpgsql AS $$ ' +
  'BEGIN ' +
  '  SELECT COUNT(*) INTO total_clients FROM clients; ' +
  '  SELECT COUNT(*) INTO total_commandes FROM commandes; ' +
  'END; $$'
);

// Appel
SQLQuery.SQL.Text := 'CALL get_stats(NULL, NULL)';
SQLQuery.Open;
```

### Triggers

```pascal
// Cr√©er un trigger pour l'audit
PGConnection.ExecuteDirect(
  'CREATE TABLE audit_log (' +
  '  id SERIAL PRIMARY KEY,' +
  '  table_name TEXT,' +
  '  action TEXT,' +
  '  user_name TEXT,' +
  '  action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP' +
  ')'
);

PGConnection.ExecuteDirect(
  'CREATE OR REPLACE FUNCTION log_changes() RETURNS TRIGGER AS $$ ' +
  'BEGIN ' +
  '  INSERT INTO audit_log (table_name, action, user_name) ' +
  '  VALUES (TG_TABLE_NAME, TG_OP, current_user); ' +
  '  RETURN NEW; ' +
  'END; ' +
  '$$ LANGUAGE plpgsql'
);

PGConnection.ExecuteDirect(
  'CREATE TRIGGER clients_audit ' +
  'AFTER INSERT OR UPDATE OR DELETE ON clients ' +
  'FOR EACH ROW EXECUTE FUNCTION log_changes()'
);
```

### Vues mat√©rialis√©es

```pascal
// Cr√©er une vue mat√©rialis√©e pour les performances
PGConnection.ExecuteDirect(
  'CREATE MATERIALIZED VIEW stats_mensuelles AS ' +
  'SELECT ' +
  '  DATE_TRUNC(''month'', date_commande) as mois,' +
  '  COUNT(*) as nb_commandes,' +
  '  SUM(montant) as total ' +
  'FROM commandes ' +
  'GROUP BY DATE_TRUNC(''month'', date_commande)'
);

// Rafra√Æchir la vue
PGConnection.ExecuteDirect('REFRESH MATERIALIZED VIEW stats_mensuelles');

// Utiliser comme une table normale
SQLQuery.SQL.Text := 'SELECT * FROM stats_mensuelles ORDER BY mois DESC';
SQLQuery.Open;
```

## Optimisation avec PostgreSQL

### Index et performance

```pascal
// Cr√©er diff√©rents types d'index
begin
  // Index B-tree standard
  PGConnection.ExecuteDirect(
    'CREATE INDEX idx_clients_email ON clients(email)'
  );

  // Index unique
  PGConnection.ExecuteDirect(
    'CREATE UNIQUE INDEX idx_clients_email_unique ON clients(email)'
  );

  // Index compos√©
  PGConnection.ExecuteDirect(
    'CREATE INDEX idx_commandes_client_date ON commandes(client_id, date_commande)'
  );

  // Index partiel (seulement certaines lignes)
  PGConnection.ExecuteDirect(
    'CREATE INDEX idx_commandes_recentes ON commandes(date_commande) ' +
    'WHERE date_commande > CURRENT_DATE - INTERVAL ''30 days'''
  );

  // Index GIN pour JSONB
  PGConnection.ExecuteDirect(
    'CREATE INDEX idx_donnees_json ON evenements USING GIN (donnees)'
  );

  // Index full-text search
  PGConnection.ExecuteDirect(
    'CREATE INDEX idx_articles_recherche ON articles ' +
    'USING GIN (to_tsvector(''french'', titre || '' '' || contenu))'
  );
end;
```

### Analyse des requ√™tes avec EXPLAIN

```pascal
procedure AnalyserRequete(const ASQL: string);
var
  Plan: TStringList;
begin
  Plan := TStringList.Create;
  try
    SQLQuery.SQL.Text := 'EXPLAIN ANALYZE ' + ASQL;
    SQLQuery.Open;

    while not SQLQuery.EOF do
    begin
      Plan.Add(SQLQuery.Fields[0].AsString);
      SQLQuery.Next;
    end;

    // Afficher ou logger le plan
    ShowMessage('Plan d''ex√©cution:' + LineEnding + Plan.Text);

    // Analyser les points d'attention
    if Pos('Seq Scan', Plan.Text) > 0 then
      ShowMessage('Attention: Scan s√©quentiel d√©tect√©, consid√©rez un index');

    if Pos('Nested Loop', Plan.Text) > 0 then
      ShowMessage('Attention: Boucles imbriqu√©es, v√©rifiez les jointures');
  finally
    Plan.Free;
    SQLQuery.Close;
  end;
end;
```

### Configuration des param√®tres de connexion pour la performance

```pascal
// Pool de connexions optimis√© pour PostgreSQL
type
  TPGConnectionPool = class
  private
    FConnections: TThreadList;
    FConfig: TPGConfig;
  public
    function GetConnection: TPQConnection;
    procedure ReleaseConnection(AConn: TPQConnection);
  end;

function TPGConnectionPool.GetConnection: TPQConnection;
begin
  Result := TPQConnection.Create(nil);
  Result.HostName := FConfig.HostName;
  Result.DatabaseName := FConfig.DatabaseName;
  Result.UserName := FConfig.UserName;
  Result.Password := FConfig.Password;

  // Optimisations de connexion
  Result.Params.Add('application_name=' + Application.Title);
  Result.Params.Add('statement_timeout=30000');  // 30 secondes max par requ√™te
  Result.Params.Add('idle_in_transaction_session_timeout=60000'); // 60 secondes
  Result.Params.Add('tcp_keepalives_idle=60');
  Result.Params.Add('tcp_keepalives_interval=10');

  Result.Open;
end;
```

## Gestion des transactions avec PostgreSQL

### Niveaux d'isolation

PostgreSQL supporte tous les niveaux d'isolation SQL standard :

```pascal
procedure SetIsolationLevel(ALevel: string);
begin
  // READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE
  PGConnection.ExecuteDirect('SET TRANSACTION ISOLATION LEVEL ' + ALevel);
end;

// Transaction avec isolation sp√©cifique
procedure TransactionIsolee;
begin
  SQLTransaction.StartTransaction;
  try
    PGConnection.ExecuteDirect('SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');

    // Op√©rations critiques
    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = solde - :montant WHERE id = :id1';
    SQLQuery.ExecSQL;

    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = solde + :montant WHERE id = :id2';
    SQLQuery.ExecSQL;

    SQLTransaction.Commit;
  except
    SQLTransaction.Rollback;
    raise;
  end;
end;
```

### Savepoints

Les savepoints permettent des rollbacks partiels :

```pascal
procedure TransactionAvecSavepoints;
begin
  SQLTransaction.StartTransaction;
  try
    // Premi√®re op√©ration
    SQLQuery.SQL.Text := 'INSERT INTO logs (message) VALUES (:msg)';
    SQLQuery.ParamByName('msg').AsString := 'D√©but op√©ration';
    SQLQuery.ExecSQL;

    // Cr√©er un savepoint
    PGConnection.ExecuteDirect('SAVEPOINT sp1');

    try
      // Op√©ration risqu√©e
      SQLQuery.SQL.Text := 'UPDATE critiques SET valeur = :val WHERE id = :id';
      SQLQuery.ExecSQL;
    except
      // Revenir au savepoint sans annuler toute la transaction
      PGConnection.ExecuteDirect('ROLLBACK TO SAVEPOINT sp1');
    end;

    // Continuer la transaction
    SQLQuery.SQL.Text := 'INSERT INTO logs (message) VALUES (:msg)';
    SQLQuery.ParamByName('msg').AsString := 'Fin op√©ration';
    SQLQuery.ExecSQL;

    SQLTransaction.Commit;
  except
    SQLTransaction.Rollback;
    raise;
  end;
end;
```

## S√©curit√© avec PostgreSQL

### Authentification SSL/TLS

```pascal
procedure ConnexionSecurisee;
begin
  PGConnection := TPQConnection.Create(nil);
  try
    PGConnection.HostName := 'serveur.exemple.com';
    PGConnection.DatabaseName := 'base_sensible';
    PGConnection.UserName := 'utilisateur';
    PGConnection.Password := 'motdepasse';

    // Forcer SSL
    PGConnection.Params.Add('sslmode=require');

    // Pour une s√©curit√© maximale avec certificats
    {$IFDEF WINDOWS}
    PGConnection.Params.Add('sslcert=' + ExtractFilePath(ParamStr(0)) + 'certs\client-cert.pem');
    PGConnection.Params.Add('sslkey=' + ExtractFilePath(ParamStr(0)) + 'certs\client-key.pem');
    PGConnection.Params.Add('sslrootcert=' + ExtractFilePath(ParamStr(0)) + 'certs\ca-cert.pem');
    {$ENDIF}

    {$IFDEF UNIX}
    PGConnection.Params.Add('sslcert=/etc/postgresql/client-cert.pem');
    PGConnection.Params.Add('sslkey=/etc/postgresql/client-key.pem');
    PGConnection.Params.Add('sslrootcert=/etc/postgresql/ca-cert.pem');
    {$ENDIF}

    PGConnection.Open;
  finally
    PGConnection.Free;
  end;
end;
```

### Row Level Security (RLS)

PostgreSQL permet de s√©curiser au niveau des lignes :

```pascal
// Configuration RLS
procedure ConfigurerRLS;
begin
  // Activer RLS sur une table
  PGConnection.ExecuteDirect('ALTER TABLE documents ENABLE ROW LEVEL SECURITY');

  // Cr√©er une politique
  PGConnection.ExecuteDirect(
    'CREATE POLICY documents_policy ON documents ' +
    'FOR ALL ' +
    'USING (proprietaire = current_user) ' +
    'WITH CHECK (proprietaire = current_user)'
  );

  // Dans l'application, d√©finir l'utilisateur
  PGConnection.ExecuteDirect('SET SESSION ROLE ''utilisateur_app''');
end;
```

## Sauvegarde et restauration

### Backup depuis FreePascal

```pascal
procedure BackupDatabase(const AOutputFile: string);
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\PostgreSQL\14\bin\pg_dump.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/pg_dump';
    {$ENDIF}

    Process.Parameters.Add('-h');
    Process.Parameters.Add(PGConnection.HostName);
    Process.Parameters.Add('-U');
    Process.Parameters.Add(PGConnection.UserName);
    Process.Parameters.Add('-d');
    Process.Parameters.Add(PGConnection.DatabaseName);
    Process.Parameters.Add('-f');
    Process.Parameters.Add(AOutputFile);
    Process.Parameters.Add('--verbose');

    // Variable d'environnement pour le mot de passe
    Process.Environment.Add('PGPASSWORD=' + PGConnection.Password);

    Process.Options := Process.Options + [poWaitOnExit, poUsePipes];
    Process.Execute;

    if Process.ExitStatus = 0 then
      ShowMessage('Sauvegarde r√©ussie')
    else
      ShowMessage('Erreur de sauvegarde');
  finally
    Process.Free;
  end;
end;
```

## Monitoring et diagnostics

### Requ√™tes actives et statistiques

```pascal
// Voir les requ√™tes en cours
procedure AfficherRequetesActives;
begin
  SQLQuery.SQL.Text :=
    'SELECT pid, usename, application_name, state, query ' +
    'FROM pg_stat_activity ' +
    'WHERE state <> ''idle'' ' +
    'ORDER BY query_start DESC';
  SQLQuery.Open;
end;

// Statistiques des tables
procedure StatsTable(const ATableName: string);
begin
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  n_live_tup as lignes_actives,' +
    '  n_dead_tup as lignes_mortes,' +
    '  last_vacuum,' +
    '  last_autovacuum ' +
    'FROM pg_stat_user_tables ' +
    'WHERE tablename = :table';
  SQLQuery.ParamByName('table').AsString := ATableName;
  SQLQuery.Open;
end;

// Taille des bases et tables
procedure AfficherTailles;
begin
  // Taille de la base
  SQLQuery.SQL.Text :=
    'SELECT pg_size_pretty(pg_database_size(current_database())) as taille_base';
  SQLQuery.Open;
  ShowMessage('Taille base: ' + SQLQuery.FieldByName('taille_base').AsString);

  // Top 10 des plus grosses tables
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  tablename,' +
    '  pg_size_pretty(pg_total_relation_size(schemaname||''.''||tablename)) as taille ' +
    'FROM pg_tables ' +
    'WHERE schemaname = ''public'' ' +
    'ORDER BY pg_total_relation_size(schemaname||''.''||tablename) DESC ' +
    'LIMIT 10';
  SQLQuery.Open;
end;
```

## Gestion des erreurs sp√©cifiques √† PostgreSQL

```pascal
procedure GererErreurPG(E: EPQDatabaseError);
begin
  case E.ErrorCode of
    '23505': ShowMessage('Violation de contrainte unique');
    '23503': ShowMessage('Violation de cl√© √©trang√®re');
    '23502': ShowMessage('Violation NOT NULL');
    '23514': ShowMessage('Violation de contrainte CHECK');
    '22001': ShowMessage('Cha√Æne trop longue pour le champ');
    '22003': ShowMessage('Valeur num√©rique hors limites');
    '42P01': ShowMessage('Table inexistante');
    '42703': ShowMessage('Colonne inexistante');
    '42883': ShowMessage('Fonction inexistante');
    '08001': ShowMessage('Impossible de se connecter au serveur');
    '08006': ShowMessage('Connexion perdue');
    '28000': ShowMessage('Authentification √©chou√©e');
    '28P01': ShowMessage('Mot de passe invalide');
    '57P01': ShowMessage('Serveur en cours d''arr√™t');
    '57P03': ShowMessage('Serveur non disponible');
  else
    ShowMessage('Erreur PostgreSQL: ' + E.Message);
  end;
end;

// Utilisation
try
  SQLQuery.ExecSQL;
except
  on E: EPQDatabaseError do
    GererErreurPG(E);
  on E: Exception do
    ShowMessage('Erreur: ' + E.Message);
end;
```

## Conclusion et bonnes pratiques

### R√©capitulatif des points cl√©s

1. **Toujours utiliser des requ√™tes param√©tr√©es** pour la s√©curit√©
2. **G√©rer les transactions correctement** avec commit/rollback
3. **Cr√©er des index appropri√©s** pour les performances
4. **Utiliser EXPLAIN** pour analyser les requ√™tes lentes
5. **Configurer SSL** pour les connexions sensibles
6. **Surveiller les statistiques** de la base r√©guli√®rement
7. **Sauvegarder r√©guli√®rement** avec pg_dump
8. **Utiliser les fonctionnalit√©s avanc√©es** (JSON, arrays, etc.) quand appropri√©

### Ressources utiles

- Documentation PostgreSQL : https://www.postgresql.org/docs/
- Wiki FreePascal pour PostgreSQL : https://wiki.freepascal.org/postgres
- pgAdmin pour l'administration graphique
- DBeaver comme alternative multi-plateforme

PostgreSQL avec FreePascal/Lazarus offre une solution robuste, performante et totalement portable entre Windows et Linux, id√©ale pour les applications professionnelles exigeantes.

‚è≠Ô∏è [MySQL/MariaDB](/08-bases-donnees-orm-multiplatefomes/02.2-mysql-mariadb.md)
