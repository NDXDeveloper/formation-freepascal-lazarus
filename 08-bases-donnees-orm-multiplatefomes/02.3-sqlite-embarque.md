üîù Retour au [Sommaire](/SOMMAIRE.md)

# SQLite (embarqu√©) avec FreePascal/Lazarus - Guide Complet pour D√©butants

## Introduction √† SQLite

### Qu'est-ce que SQLite ?

SQLite est un moteur de base de donn√©es relationnelle unique en son genre. Contrairement √† MySQL ou PostgreSQL qui n√©cessitent un serveur, SQLite est une biblioth√®que embarqu√©e qui stocke toute la base de donn√©es dans un seul fichier. C'est la base de donn√©es la plus d√©ploy√©e au monde, pr√©sente dans chaque smartphone, navigateur web et d'innombrables applications.

### Pourquoi SQLite est-il qualifi√© d'"embarqu√©" ?

Le terme "embarqu√©" signifie que SQLite :
- **S'int√®gre directement** dans votre application (pas de processus serveur s√©par√©)
- **Ne n√©cessite aucune installation** ou configuration
- **Fonctionne sans administration** syst√®me
- **S'ex√©cute dans le m√™me processus** que votre application
- **Acc√®de directement au fichier** de base de donn√©es

### Avantages de SQLite

1. **Z√©ro configuration** : Fonctionne imm√©diatement sans setup
2. **Portable** : Un fichier unique facilement copiable
3. **L√©ger** : Biblioth√®que de moins de 1 MB
4. **Rapide** : Pas de communication r√©seau, acc√®s direct au disque
5. **Fiable** : Transactions ACID compl√®tes
6. **Multiplateforme** : M√™me format de fichier sur tous les OS
7. **Domaine public** : Aucune licence, totalement libre
8. **Autonome** : Pas de d√©pendances externes

### Limitations de SQLite

1. **Mono-utilisateur en √©criture** : Une seule √©criture √† la fois
2. **Taille limit√©e** : Recommand√© jusqu'√† quelques GB
3. **Pas de gestion utilisateurs** : Pas d'authentification int√©gr√©e
4. **Fonctionnalit√©s r√©duites** : Pas de proc√©dures stock√©es natives
5. **Types de donn√©es simplifi√©s** : Typage dynamique
6. **Pas adapt√© au web haute charge** : Pour applications locales principalement

### Cas d'usage id√©aux pour SQLite

- Applications desktop mono-utilisateur
- Applications mobiles (Android, iOS)
- Stockage de configuration
- Cache local d'applications
- Prototypage rapide
- Tests unitaires de base de donn√©es
- Bases de donn√©es embarqu√©es dans des appareils
- Format de fichier d'application (remplace XML/JSON)
- Sites web √† faible trafic
- Analyse de donn√©es locales

## Installation et configuration

### La beaut√© de SQLite : Rien √† installer !

L'un des grands avantages de SQLite est qu'il n'y a pas de serveur √† installer. Seule la biblioth√®que cliente est n√©cessaire.

### Sur Windows

#### Obtenir sqlite3.dll

M√©thode 1 : T√©l√©chargement officiel
```
1. Aller sur https://www.sqlite.org/download.html
2. T√©l√©charger "sqlite-dll-win64-x64-*.zip" (ou win32 selon votre syst√®me)
3. Extraire sqlite3.dll
4. Placer dans le dossier de votre application
```

M√©thode 2 : Via Lazarus
```
Souvent inclus avec Lazarus dans le dossier :
C:\lazarus\fpc\3.2.2\bin\x86_64-win64\sqlite3.dll
```

### Sur Linux/Ubuntu

```bash
# Installation de la biblioth√®que
sudo apt update
sudo apt install sqlite3 libsqlite3-dev

# V√©rification de l'installation
sqlite3 --version

# La biblioth√®que est install√©e dans :
# /usr/lib/x86_64-linux-gnu/libsqlite3.so.0
```

### Outils d'administration SQLite

#### Outils en ligne de commande
```bash
# Cr√©er/ouvrir une base
sqlite3 mabase.db

# Commandes utiles dans sqlite3
.tables              # Liste des tables
.schema              # Structure des tables
.mode column         # Affichage en colonnes
.headers on          # Afficher les en-t√™tes
.quit                # Quitter
```

#### Outils graphiques recommand√©s
- **DB Browser for SQLite** : Interface simple et compl√®te (Windows/Linux/Mac)
- **SQLiteStudio** : Tr√®s complet et portable
- **HeidiSQL** : Support SQLite en plus de MySQL/PostgreSQL
- **DBeaver** : IDE de base de donn√©es universel

## Configuration avec FreePascal/Lazarus

### Le composant TSQLite3Connection

```pascal
uses
  SQLite3Conn, sqldb;

var
  SQLiteConnection: TSQLite3Connection;
  Transaction: TSQLTransaction;
begin
  // Cr√©er la connexion
  SQLiteConnection := TSQLite3Connection.Create(nil);
  Transaction := TSQLTransaction.Create(nil);
  try
    // Configuration minimale
    SQLiteConnection.DatabaseName := 'mabase.db';  // Fichier de base de donn√©es
    SQLiteConnection.Transaction := Transaction;
    Transaction.Database := SQLiteConnection;

    // Connexion (cr√©e le fichier s'il n'existe pas)
    SQLiteConnection.Open;
    ShowMessage('Base SQLite ouverte avec succ√®s !');
  finally
    SQLiteConnection.Free;
    Transaction.Free;
  end;
end;
```

### Gestion du fichier de base de donn√©es

```pascal
uses
  SysUtils;

procedure GererFichierBD;
var
  DBPath: string;
begin
  // Chemins relatifs et absolus
  DBPath := ExtractFilePath(ParamStr(0)) + 'data' + PathDelim + 'mabase.db';

  // Cr√©er le r√©pertoire si n√©cessaire
  ForceDirectories(ExtractFilePath(DBPath));

  // V√©rifier si la base existe
  if not FileExists(DBPath) then
  begin
    ShowMessage('Cr√©ation d''une nouvelle base de donn√©es');
    // SQLite cr√©era automatiquement le fichier √† la connexion
  end
  else
  begin
    ShowMessage('Ouverture de la base existante');
    // Optionnel : v√©rifier l'int√©grit√©
    VerifierIntegrite(DBPath);
  end;

  SQLiteConnection.DatabaseName := DBPath;
end;

procedure VerifierIntegrite(const ADBPath: string);
var
  FileSize: Int64;
begin
  FileSize := FileSize(ADBPath);
  if FileSize = 0 then
    raise Exception.Create('Fichier de base de donn√©es vide ou corrompu');

  // Test d'ouverture rapide
  SQLiteConnection.DatabaseName := ADBPath;
  try
    SQLiteConnection.Open;
    SQLiteConnection.Close;
  except
    on E: Exception do
      raise Exception.Create('Base de donn√©es corrompue : ' + E.Message);
  end;
end;
```

### Configuration en m√©moire

SQLite permet de cr√©er des bases enti√®rement en RAM :

```pascal
procedure BaseEnMemoire;
begin
  // Base en m√©moire (perdue √† la fermeture)
  SQLiteConnection.DatabaseName := ':memory:';
  SQLiteConnection.Open;

  // Cr√©er les tables
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE temp_data (id INTEGER PRIMARY KEY, valeur TEXT)'
  );

  // Utilisation normale...
  // Les donn√©es sont perdues quand la connexion se ferme
end;

// Base temporaire (fichier temporaire auto-supprim√©)
procedure BaseTemporraire;
begin
  SQLiteConnection.DatabaseName := '';  // Cha√Æne vide = base temporaire
  SQLiteConnection.Open;
  // SQLite cr√©e un fichier temporaire qui sera supprim√© automatiquement
end;
```

## Types de donn√©es SQLite

### Le syst√®me de types flexibles

SQLite utilise un syst√®me de "typage dynamique" unique. Les types sont des suggestions, pas des contraintes strictes.

### Classes d'affinit√©

| Classe | Types SQL accept√©s | Type Pascal/Lazarus |
|--------|-------------------|-------------------|
| **INTEGER** | INT, INTEGER, TINYINT, SMALLINT, MEDIUMINT, BIGINT, etc. | Integer, Int64 |
| **REAL** | REAL, DOUBLE, FLOAT | Single, Double |
| **TEXT** | CHARACTER, VARCHAR, TEXT, CLOB | String, AnsiString |
| **BLOB** | BLOB | TBytes, TBlobField |
| **NUMERIC** | NUMERIC, DECIMAL, BOOLEAN, DATE, DATETIME | Variant |

### Gestion des types sp√©ciaux

```pascal
// SQLite n'a pas de type BOOLEAN natif
procedure GererBoolean;
begin
  // Cr√©ation avec INTEGER (0 = false, 1 = true)
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE utilisateurs (' +
    '  id INTEGER PRIMARY KEY,' +
    '  nom TEXT NOT NULL,' +
    '  actif INTEGER DEFAULT 1 CHECK (actif IN (0, 1))' +
    ')'
  );

  // Insertion
  SQLQuery.SQL.Text := 'INSERT INTO utilisateurs (nom, actif) VALUES (:nom, :actif)';
  SQLQuery.ParamByName('nom').AsString := 'Jean';
  SQLQuery.ParamByName('actif').AsInteger := 1;  // true
  SQLQuery.ExecSQL;

  // Lecture avec conversion
  SQLQuery.SQL.Text := 'SELECT * FROM utilisateurs';
  SQLQuery.Open;
  var IsActif: Boolean := SQLQuery.FieldByName('actif').AsInteger = 1;
end;

// Dates et heures
procedure GererDates;
begin
  // SQLite stocke les dates comme TEXT, REAL ou INTEGER
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE evenements (' +
    '  id INTEGER PRIMARY KEY,' +
    '  description TEXT,' +
    '  date_text TEXT,' +              // Format ISO 8601
    '  date_real REAL,' +              // Jours Julian
    '  date_int INTEGER' +             // Unix timestamp
    ')'
  );

  // Insertion de dates
  SQLQuery.SQL.Text :=
    'INSERT INTO evenements (description, date_text, date_real, date_int) ' +
    'VALUES (:desc, datetime(''now''), julianday(''now''), strftime(''%s'', ''now''))';
  SQLQuery.ParamByName('desc').AsString := 'Test';
  SQLQuery.ExecSQL;

  // Avec TDateTime de Pascal
  var MaDate: TDateTime := Now;
  SQLQuery.SQL.Text := 'INSERT INTO evenements (description, date_text) VALUES (:desc, :date)';
  SQLQuery.ParamByName('desc').AsString := 'Avec Pascal';
  SQLQuery.ParamByName('date').AsDateTime := MaDate;
  SQLQuery.ExecSQL;
end;
```

## Fonctionnalit√©s sp√©cifiques SQLite

### AUTOINCREMENT et cl√©s primaires

```pascal
// INTEGER PRIMARY KEY est automatiquement auto-incr√©ment√© (ROWID)
procedure ClesPrimaires;
begin
  // Version simple (recommand√©e)
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE clients (' +
    '  id INTEGER PRIMARY KEY,' +  // Auto-incr√©ment√© automatiquement
    '  nom TEXT NOT NULL' +
    ')'
  );

  // Version explicite (l√©g√®rement plus lente)
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE commandes (' +
    '  id INTEGER PRIMARY KEY AUTOINCREMENT,' +  // Force l'unicit√© permanente
    '  numero TEXT UNIQUE' +
    ')'
  );

  // R√©cup√©rer le dernier ID ins√©r√©
  SQLQuery.SQL.Text := 'INSERT INTO clients (nom) VALUES (:nom)';
  SQLQuery.ParamByName('nom').AsString := 'Nouveau Client';
  SQLQuery.ExecSQL;

  // M√©thode 1 : last_insert_rowid()
  SQLQuery.SQL.Text := 'SELECT last_insert_rowid() as id';
  SQLQuery.Open;
  var NewID: Integer := SQLQuery.FieldByName('id').AsInteger;
  SQLQuery.Close;
end;
```

### Contraintes et v√©rifications

```pascal
procedure ContraintesAvancees;
begin
  // Activer les contraintes de cl√©s √©trang√®res (d√©sactiv√©es par d√©faut!)
  SQLiteConnection.ExecuteDirect('PRAGMA foreign_keys = ON');

  // Table avec contraintes
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE produits (' +
    '  id INTEGER PRIMARY KEY,' +
    '  nom TEXT NOT NULL UNIQUE,' +
    '  prix REAL CHECK (prix >= 0),' +
    '  stock INTEGER DEFAULT 0 CHECK (stock >= 0),' +
    '  categorie_id INTEGER,' +
    '  FOREIGN KEY (categorie_id) REFERENCES categories(id) ON DELETE SET NULL' +
    ')'
  );

  // Contraintes de table
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE commande_items (' +
    '  commande_id INTEGER,' +
    '  produit_id INTEGER,' +
    '  quantite INTEGER CHECK (quantite > 0),' +
    '  prix_unitaire REAL,' +
    '  PRIMARY KEY (commande_id, produit_id),' +
    '  FOREIGN KEY (commande_id) REFERENCES commandes(id) ON DELETE CASCADE,' +
    '  FOREIGN KEY (produit_id) REFERENCES produits(id)' +
    ')'
  );
end;
```

### Triggers SQLite

```pascal
procedure CreerTriggers;
begin
  // Trigger pour mise √† jour automatique
  SQLiteConnection.ExecuteDirect(
    'CREATE TRIGGER update_timestamp ' +
    'AFTER UPDATE ON clients ' +
    'BEGIN ' +
    '  UPDATE clients SET date_modification = datetime(''now'') ' +
    '  WHERE id = NEW.id; ' +
    'END'
  );

  // Trigger pour audit
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE audit_log (' +
    '  id INTEGER PRIMARY KEY,' +
    '  table_name TEXT,' +
    '  operation TEXT,' +
    '  old_value TEXT,' +
    '  new_value TEXT,' +
    '  timestamp TEXT DEFAULT (datetime(''now''))' +
    ')'
  );

  SQLiteConnection.ExecuteDirect(
    'CREATE TRIGGER audit_clients_update ' +
    'AFTER UPDATE ON clients ' +
    'BEGIN ' +
    '  INSERT INTO audit_log (table_name, operation, old_value, new_value) ' +
    '  VALUES (''clients'', ''UPDATE'', OLD.nom, NEW.nom); ' +
    'END'
  );

  // Trigger pour validation complexe
  SQLiteConnection.ExecuteDirect(
    'CREATE TRIGGER check_stock ' +
    'BEFORE INSERT ON commande_items ' +
    'BEGIN ' +
    '  SELECT CASE ' +
    '    WHEN (SELECT stock FROM produits WHERE id = NEW.produit_id) < NEW.quantite ' +
    '    THEN RAISE(ABORT, ''Stock insuffisant'') ' +
    '  END; ' +
    'END'
  );
end;
```

### Vues SQLite

```pascal
procedure CreerVues;
begin
  // Vue simple
  SQLiteConnection.ExecuteDirect(
    'CREATE VIEW vue_clients_actifs AS ' +
    'SELECT * FROM clients WHERE actif = 1'
  );

  // Vue avec jointures
  SQLiteConnection.ExecuteDirect(
    'CREATE VIEW vue_commandes_details AS ' +
    'SELECT ' +
    '  c.id as commande_id,' +
    '  c.date_commande,' +
    '  cl.nom as client_nom,' +
    '  SUM(ci.quantite * ci.prix_unitaire) as total ' +
    'FROM commandes c ' +
    'JOIN clients cl ON c.client_id = cl.id ' +
    'JOIN commande_items ci ON c.id = ci.commande_id ' +
    'GROUP BY c.id'
  );

  // Utilisation comme une table
  SQLQuery.SQL.Text := 'SELECT * FROM vue_commandes_details WHERE total > 100';
  SQLQuery.Open;
end;
```

### Index et optimisation

```pascal
procedure CreerIndex;
begin
  // Index simple
  SQLiteConnection.ExecuteDirect(
    'CREATE INDEX idx_clients_nom ON clients(nom)'
  );

  // Index unique
  SQLiteConnection.ExecuteDirect(
    'CREATE UNIQUE INDEX idx_clients_email ON clients(email)'
  );

  // Index compos√©
  SQLiteConnection.ExecuteDirect(
    'CREATE INDEX idx_commandes_date_client ON commandes(date_commande, client_id)'
  );

  // Index partiel (SQLite 3.8.0+)
  SQLiteConnection.ExecuteDirect(
    'CREATE INDEX idx_commandes_recentes ON commandes(date_commande) ' +
    'WHERE date_commande > date(''now'', ''-30 days'')'
  );

  // Index sur expressions
  SQLiteConnection.ExecuteDirect(
    'CREATE INDEX idx_clients_nom_upper ON clients(UPPER(nom))'
  );

  // Analyser les tables pour optimiser
  SQLiteConnection.ExecuteDirect('ANALYZE');
end;
```

## Fonctions int√©gr√©es et expressions

### Fonctions de dates

```pascal
procedure FonctionsDates;
begin
  // Date et heure actuelles
  SQLQuery.SQL.Text := 'SELECT datetime(''now'') as maintenant';

  // Calculs de dates
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  date(''now'') as aujourd_hui,' +
    '  date(''now'', ''+1 day'') as demain,' +
    '  date(''now'', ''-1 month'') as mois_dernier,' +
    '  strftime(''%Y'', ''now'') as annee,' +
    '  strftime(''%W'', ''now'') as semaine';

  // Diff√©rence entre dates
  SQLQuery.SQL.Text :=
    'SELECT julianday(''now'') - julianday(''2024-01-01'') as jours_ecoules';

  // Formatage personnalis√©
  SQLQuery.SQL.Text :=
    'SELECT strftime(''%d/%m/%Y %H:%M'', ''now'') as date_fr';
end;
```

### Fonctions de cha√Ænes

```pascal
procedure FonctionsChaines;
begin
  // Manipulation de texte
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  UPPER(nom) as nom_maj,' +
    '  LOWER(nom) as nom_min,' +
    '  LENGTH(nom) as longueur,' +
    '  SUBSTR(nom, 1, 3) as trois_lettres,' +
    '  TRIM(nom) as sans_espaces,' +
    '  REPLACE(nom, ''a'', ''A'') as remplace ' +
    'FROM clients';

  // Concat√©nation
  SQLQuery.SQL.Text :=
    'SELECT nom || '' '' || prenom as nom_complet FROM clients';

  // Pattern matching
  SQLQuery.SQL.Text :=
    'SELECT * FROM clients WHERE nom LIKE ''D%''';  // Commence par D

  SQLQuery.SQL.Text :=
    'SELECT * FROM clients WHERE email GLOB ''*@gmail.com''';  // Finit par @gmail.com
end;
```

### Fonctions d'agr√©gation

```pascal
procedure FonctionsAgregation;
begin
  // Statistiques de base
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  COUNT(*) as total,' +
    '  COUNT(DISTINCT categorie_id) as nb_categories,' +
    '  MIN(prix) as prix_min,' +
    '  MAX(prix) as prix_max,' +
    '  AVG(prix) as prix_moyen,' +
    '  SUM(stock) as stock_total ' +
    'FROM produits';

  // GROUP BY avec HAVING
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  categorie_id,' +
    '  COUNT(*) as nb_produits,' +
    '  AVG(prix) as prix_moyen ' +
    'FROM produits ' +
    'GROUP BY categorie_id ' +
    'HAVING COUNT(*) > 5';
end;
```

## Transactions et concurrence

### Gestion des transactions

```pascal
procedure TransactionComplete;
begin
  // Commencer une transaction
  SQLTransaction.StartTransaction;
  try
    // Op√©ration 1
    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = solde - :montant WHERE id = :id';
    SQLQuery.ParamByName('montant').AsFloat := 100.00;
    SQLQuery.ParamByName('id').AsInteger := 1;
    SQLQuery.ExecSQL;

    // V√©rification
    SQLQuery.SQL.Text := 'SELECT solde FROM comptes WHERE id = :id';
    SQLQuery.ParamByName('id').AsInteger := 1;
    SQLQuery.Open;
    if SQLQuery.FieldByName('solde').AsFloat < 0 then
      raise Exception.Create('Solde insuffisant');
    SQLQuery.Close;

    // Op√©ration 2
    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = solde + :montant WHERE id = :id';
    SQLQuery.ParamByName('montant').AsFloat := 100.00;
    SQLQuery.ParamByName('id').AsInteger := 2;
    SQLQuery.ExecSQL;

    // Valider
    SQLTransaction.Commit;
    ShowMessage('Transaction r√©ussie');
  except
    on E: Exception do
    begin
      SQLTransaction.Rollback;
      ShowMessage('Transaction annul√©e : ' + E.Message);
    end;
  end;
end;
```

### Modes de journalisation

```pascal
procedure ConfigurerJournal;
begin
  // Mode DELETE (par d√©faut) - Plus compatible
  SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = DELETE');

  // Mode WAL (Write-Ahead Logging) - Plus performant
  SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = WAL');

  // Mode MEMORY - Plus rapide mais moins s√ªr
  SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = MEMORY');

  // Mode OFF - Tr√®s rapide mais dangereux (pas de rollback)
  SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = OFF');
end;

// Configuration pour performance vs s√©curit√©
procedure OptimiserPerformance(ASecurite: Boolean);
begin
  if ASecurite then
  begin
    // Maximum de s√©curit√©
    SQLiteConnection.ExecuteDirect('PRAGMA synchronous = FULL');
    SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = DELETE');
  end
  else
  begin
    // Maximum de performance (risque de corruption)
    SQLiteConnection.ExecuteDirect('PRAGMA synchronous = OFF');
    SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = MEMORY');
    SQLiteConnection.ExecuteDirect('PRAGMA temp_store = MEMORY');
  end;
end;
```

### Gestion de la concurrence

```pascal
procedure GererAccesConcurrents;
begin
  // Timeout pour attendre si la base est verrouill√©e
  SQLiteConnection.Params.Add('BusyTimeout=5000');  // 5 secondes

  // Ou via PRAGMA
  SQLiteConnection.ExecuteDirect('PRAGMA busy_timeout = 5000');

  // Mode de verrouillage
  SQLiteConnection.ExecuteDirect('PRAGMA locking_mode = NORMAL');  // Par d√©faut
  // PRAGMA locking_mode = EXCLUSIVE  // Un seul processus

  // Tenter une √©criture avec retry
  var Retries: Integer := 0;
  while Retries < 3 do
  begin
    try
      SQLQuery.ExecSQL;
      Break;  // Succ√®s
    except
      on E: Exception do
      begin
        if Pos('database is locked', E.Message) > 0 then
        begin
          Inc(Retries);
          Sleep(1000);  // Attendre 1 seconde
          if Retries >= 3 then
            raise Exception.Create('Base de donn√©es verrouill√©e apr√®s 3 tentatives');
        end
        else
          raise;  // Autre erreur
      end;
    end;
  end;
end;
```

## Optimisation et performance

### PRAGMA pour l'optimisation

```pascal
procedure OptimiserBase;
begin
  // Taille du cache en pages (par d√©faut 2000)
  SQLiteConnection.ExecuteDirect('PRAGMA cache_size = 10000');

  // Taille d'une page (par d√©faut 4096)
  SQLiteConnection.ExecuteDirect('PRAGMA page_size = 8192');

  // M√©moire temporaire
  SQLiteConnection.ExecuteDirect('PRAGMA temp_store = MEMORY');

  // Optimisation automatique
  SQLiteConnection.ExecuteDirect('PRAGMA optimize');

  // Analyse des tables
  SQLiteConnection.ExecuteDirect('ANALYZE');

  // D√©fragmentation (VACUUM)
  SQLiteConnection.ExecuteDirect('VACUUM');

  // Auto-vacuum
  SQLiteConnection.ExecuteDirect('PRAGMA auto_vacuum = INCREMENTAL');
end;

// Requ√™tes par lot pour performance
procedure InsertionEnMasse;
var
  i: Integer;
begin
  // D√©sactiver autocommit pour performance
  SQLTransaction.StartTransaction;
  try
    // Optimisations temporaires
    SQLiteConnection.ExecuteDirect('PRAGMA synchronous = OFF');
    SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = MEMORY');

    // Pr√©parer la requ√™te une fois
    SQLQuery.SQL.Text := 'INSERT INTO donnees (valeur) VALUES (:val)';
    SQLQuery.Prepare;

    // Insertions multiples
    for i := 1 to 10000 do
    begin
      SQLQuery.ParamByName('val').AsString := 'Valeur ' + IntToStr(i);
      SQLQuery.ExecSQL;

      // Commit interm√©diaire tous les 1000
      if i mod 1000 = 0 then
      begin
        SQLTransaction.CommitRetaining;
      end;
    end;

    SQLTransaction.Commit;

    // Restaurer les param√®tres
    SQLiteConnection.ExecuteDirect('PRAGMA synchronous = FULL');
    SQLiteConnection.ExecuteDirect('PRAGMA journal_mode = DELETE');
  except
    SQLTransaction.Rollback;
    raise;
  end;
end;
```

### Analyse des performances avec EXPLAIN

```pascal
procedure AnalyserRequete(const ASQL: string);
var
  Plan: TStringList;
begin
  Plan := TStringList.Create;
  try
    // Plan d'ex√©cution
    SQLQuery.SQL.Text := 'EXPLAIN QUERY PLAN ' + ASQL;
    SQLQuery.Open;

    while not SQLQuery.EOF do
    begin
      Plan.Add(Format('%d | %d | %d | %s',
        [SQLQuery.Fields[0].AsInteger,  // selectid
         SQLQuery.Fields[1].AsInteger,  // order
         SQLQuery.Fields[2].AsInteger,  // from
         SQLQuery.Fields[3].AsString])); // detail

      // D√©tecter les probl√®mes
      if Pos('SCAN TABLE', SQLQuery.Fields[3].AsString) > 0 then
        ShowMessage('Attention : Scan complet de table d√©tect√©');

      SQLQuery.Next;
    end;

    ShowMessage('Plan d''ex√©cution :' + LineEnding + Plan.Text);
  finally
    Plan.Free;
    SQLQuery.Close;
  end;
end;
```

## Sauvegarde et maintenance

### Backup simple par copie de fichier

```pascal
procedure BackupParCopie(const ADestination: string);
begin
  // Fermer toutes les connexions
  SQLiteConnection.Close;

  // Copier le fichier
  if not CopyFile(PChar(SQLiteConnection.DatabaseName),
                  PChar(ADestination), False) then
    raise Exception.Create('Erreur lors de la copie du fichier');

  ShowMessage('Sauvegarde cr√©√©e : ' + ADestination);

  // Rouvrir la connexion
  SQLiteConnection.Open;
end;
```

### Backup en ligne avec l'API SQLite

```pascal
procedure BackupEnLigne(const ADestination: string);
begin
  // Utiliser la commande VACUUM INTO (SQLite 3.27.0+)
  SQLiteConnection.ExecuteDirect('VACUUM INTO ''' + ADestination + '''');

  ShowMessage('Sauvegarde en ligne cr√©√©e : ' + ADestination);
end;

// M√©thode alternative avec SQL
procedure BackupViaSQL(const ADestination: string);
var
  BackupConn: TSQLite3Connection;
  BackupTrans: TSQLTransaction;
begin
  BackupConn := TSQLite3Connection.Create(nil);
  BackupTrans := TSQLTransaction.Create(nil);
  try
    // Connexion √† la base de destination
    BackupConn.DatabaseName := ADestination;
    BackupConn.Transaction := BackupTrans;
    BackupTrans.Database := BackupConn;
    BackupConn.Open;

    // Attacher la base source
    BackupConn.ExecuteDirect('ATTACH DATABASE ''' +
      SQLiteConnection.DatabaseName + ''' AS source');

    // Copier le sch√©ma et les donn√©es
    SQLQuery.Database := BackupConn;
    SQLQuery.SQL.Text :=
      'SELECT sql FROM source.sqlite_master WHERE sql IS NOT NULL';
    SQLQuery.Open;

    while not SQLQuery.EOF do
    begin
      BackupConn.ExecuteDirect(SQLQuery.Fields[0].AsString);
      SQLQuery.Next;
    end;

    // D√©tacher
    BackupConn.ExecuteDirect('DETACH DATABASE source');

    ShowMessage('Backup SQL cr√©√©');
  finally
    BackupConn.Free;
    BackupTrans.Free;
  end;
end;
```

### Maintenance de la base

```pascal
procedure MaintenanceComplete;
var
  TailleBefore, TailleAfter: Int64;
begin
  // Taille avant
  TailleBefore := FileSize(SQLiteConnection.DatabaseName);

  // V√©rifier l'int√©grit√©
  SQLQuery.SQL.Text := 'PRAGMA integrity_check';
  SQLQuery.Open;

  if SQLQuery.Fields[0].AsString <> 'ok' then
  begin
    ShowMessage('Probl√®me d''int√©grit√© d√©tect√© : ' + SQLQuery.Fields[0].AsString);
    // Log des probl√®mes
    while not SQLQuery.EOF do
    begin
      WriteLn('Erreur : ' + SQLQuery.Fields[0].AsString);
      SQLQuery.Next;
    end;
  end
  else
    ShowMessage('Int√©grit√© OK');
  SQLQuery.Close;

  // V√©rification des cl√©s √©trang√®res
  SQLQuery.SQL.Text := 'PRAGMA foreign_key_check';
  SQLQuery.Open;
  if not SQLQuery.EOF then
  begin
    ShowMessage('Violations de cl√©s √©trang√®res d√©tect√©es');
    while not SQLQuery.EOF do
    begin
      WriteLn(Format('Table: %s, RowID: %d, Parent: %s',
        [SQLQuery.Fields[0].AsString,
         SQLQuery.Fields[1].AsInteger,
         SQLQuery.Fields[2].AsString]));
      SQLQuery.Next;
    end;
  end;
  SQLQuery.Close;

  // Reindexer
  SQLiteConnection.ExecuteDirect('REINDEX');

  // Analyser
  SQLiteConnection.ExecuteDirect('ANALYZE');

  // Optimiser
  SQLiteConnection.ExecuteDirect('PRAGMA optimize');

  // Vacuum pour compacter
  SQLiteConnection.ExecuteDirect('VACUUM');

  // Taille apr√®s
  TailleAfter := FileSize(SQLiteConnection.DatabaseName);

  ShowMessage(Format('Maintenance termin√©e. Taille: %.2f MB ‚Üí %.2f MB (%.1f%% r√©duit)',
    [TailleBefore / 1048576,
     TailleAfter / 1048576,
     (1 - TailleAfter / TailleBefore) * 100]));
end;

// Maintenance automatique programm√©e
procedure MaintenanceAutomatique;
var
  LastMaintenance: TDateTime;
begin
  // Lire la date de derni√®re maintenance
  SQLQuery.SQL.Text := 'SELECT value FROM config WHERE key = ''last_maintenance''';
  SQLQuery.Open;

  if SQLQuery.EOF then
    LastMaintenance := 0
  else
    LastMaintenance := SQLQuery.Fields[0].AsDateTime;
  SQLQuery.Close;

  // Si plus de 7 jours, faire la maintenance
  if (Now - LastMaintenance) > 7 then
  begin
    // Quick check seulement
    SQLiteConnection.ExecuteDirect('PRAGMA quick_check');
    SQLiteConnection.ExecuteDirect('ANALYZE');
    SQLiteConnection.ExecuteDirect('PRAGMA optimize');

    // Mettre √† jour la date
    SQLQuery.SQL.Text :=
      'INSERT OR REPLACE INTO config (key, value) VALUES (''last_maintenance'', :date)';
    SQLQuery.ParamByName('date').AsDateTime := Now;
    SQLQuery.ExecSQL;
  end;
end;
```

### R√©paration de base corrompue

```pascal
procedure TenterReparation(const ADBPath: string);
var
  TempDB: string;
  RecoveredRows: Integer;
begin
  TempDB := ChangeFileExt(ADBPath, '.recovered.db');
  RecoveredRows := 0;

  ShowMessage('Tentative de r√©cup√©ration de la base corrompue...');

  // Cr√©er une nouvelle base
  var NewConn := TSQLite3Connection.Create(nil);
  var NewTrans := TSQLTransaction.Create(nil);
  try
    NewConn.DatabaseName := TempDB;
    NewConn.Transaction := NewTrans;
    NewTrans.Database := NewConn;
    NewConn.Open;

    // Attacher la base corrompue
    try
      NewConn.ExecuteDirect('ATTACH DATABASE ''' + ADBPath + ''' AS damaged');
    except
      on E: Exception do
      begin
        ShowMessage('Base trop endommag√©e pour √™tre attach√©e : ' + E.Message);
        Exit;
      end;
    end;

    // R√©cup√©rer la structure
    SQLQuery.Database := NewConn;
    SQLQuery.SQL.Text :=
      'SELECT sql FROM damaged.sqlite_master ' +
      'WHERE type = ''table'' AND sql IS NOT NULL';

    try
      SQLQuery.Open;
      while not SQLQuery.EOF do
      begin
        try
          NewConn.ExecuteDirect(SQLQuery.Fields[0].AsString);
          WriteLn('Table cr√©√©e : OK');
        except
          WriteLn('Erreur cr√©ation table : ' + SQLQuery.Fields[0].AsString);
        end;
        SQLQuery.Next;
      end;
      SQLQuery.Close;
    except
      ShowMessage('Impossible de lire le sch√©ma');
    end;

    // R√©cup√©rer les donn√©es table par table
    var Tables := TStringList.Create;
    try
      NewConn.GetTableNames(Tables, 'damaged');

      for var TableName in Tables do
      begin
        try
          SQLQuery.SQL.Text := Format(
            'INSERT INTO main.%s SELECT * FROM damaged.%s',
            [TableName, TableName]);
          SQLQuery.ExecSQL;
          Inc(RecoveredRows, SQLQuery.RowsAffected);
          WriteLn(Format('Table %s : %d lignes r√©cup√©r√©es',
            [TableName, SQLQuery.RowsAffected]));
        except
          on E: Exception do
            WriteLn('Erreur sur table ' + TableName + ' : ' + E.Message);
        end;
      end;
    finally
      Tables.Free;
    end;

    // D√©tacher la base endommag√©e
    NewConn.ExecuteDirect('DETACH DATABASE damaged');

    ShowMessage(Format('R√©cup√©ration termin√©e : %d lignes sauv√©es dans %s',
      [RecoveredRows, TempDB]));
  finally
    NewConn.Free;
    NewTrans.Free;
  end;
end;
```

## Chiffrement et s√©curit√©

### Utilisation de SQLCipher (SQLite chiffr√©)

```pascal
// SQLCipher est une version de SQLite avec chiffrement AES-256
procedure UtiliserSQLCipher;
begin
  // N√©cessite la biblioth√®que SQLCipher au lieu de SQLite standard
  SQLiteConnection.DatabaseName := 'secure.db';

  // D√©finir la cl√© de chiffrement AVANT d'ouvrir
  SQLiteConnection.Params.Add('Password=MonMotDePasseTresSecure123!');

  SQLiteConnection.Open;

  // Changer la cl√©
  SQLiteConnection.ExecuteDirect('PRAGMA rekey = ''NouveauMotDePasse456!''');
end;

// Alternative : Chiffrement manuel des donn√©es sensibles
procedure ChiffrerDonneesSensibles;
var
  DataClair, DataChiffre: string;
begin
  // Cr√©er une table avec donn√©es chiffr√©es
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE users_secure (' +
    '  id INTEGER PRIMARY KEY,' +
    '  username TEXT,' +           // Non sensible
    '  password_hash TEXT,' +      // Hash, pas r√©versible
    '  credit_card BLOB,' +        // Chiffr√©
    '  salt TEXT' +                // Pour le hash
    ')'
  );

  // Insertion avec chiffrement
  DataClair := '4111-1111-1111-1111';
  DataChiffre := ChiffrerAES(DataClair, 'CleSecrete');

  SQLQuery.SQL.Text :=
    'INSERT INTO users_secure (username, password_hash, credit_card, salt) ' +
    'VALUES (:user, :pass, :card, :salt)';
  SQLQuery.ParamByName('user').AsString := 'jean';
  SQLQuery.ParamByName('pass').AsString := HashSHA256('password' + 'salt123');
  SQLQuery.ParamByName('card').AsBytes := BytesOf(DataChiffre);
  SQLQuery.ParamByName('salt').AsString := 'salt123';
  SQLQuery.ExecSQL;
end;

function HashSHA256(const AText: string): string;
begin
  // Impl√©mentation simplifi√©e - utiliser une vraie biblioth√®que crypto
  Result := 'SHA256_' + AText; // Placeholder
end;

function ChiffrerAES(const AText, AKey: string): string;
begin
  // Impl√©mentation simplifi√©e - utiliser une vraie biblioth√®que crypto
  Result := 'AES_' + AText; // Placeholder
end;
```

### S√©curisation de l'acc√®s

```pascal
procedure SecuriserAcces;
begin
  // Masquer la structure de la base
  SQLiteConnection.ExecuteDirect('PRAGMA secure_delete = ON');

  // Emp√™cher l'acc√®s depuis d'autres processus
  SQLiteConnection.ExecuteDirect('PRAGMA locking_mode = EXCLUSIVE');

  // Cr√©er des vues pour limiter l'acc√®s
  SQLiteConnection.ExecuteDirect(
    'CREATE VIEW vue_publique AS ' +
    'SELECT id, nom FROM donnees_sensibles WHERE public = 1'
  );

  // Utiliser des triggers pour l'audit de s√©curit√©
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE security_log (' +
    '  id INTEGER PRIMARY KEY,' +
    '  action TEXT,' +
    '  timestamp TEXT DEFAULT (datetime(''now'')),' +
    '  details TEXT' +
    ')'
  );

  SQLiteConnection.ExecuteDirect(
    'CREATE TRIGGER log_sensitive_access ' +
    'AFTER SELECT ON donnees_sensibles ' +
    'BEGIN ' +
    '  INSERT INTO security_log (action, details) ' +
    '  VALUES (''SELECT'', ''Acc√®s aux donn√©es sensibles''); ' +
    'END'
  );
end;
```

## Fonctionnalit√©s avanc√©es

### Full-Text Search (FTS)

```pascal
procedure ConfigurerRechercheTexte;
begin
  // Cr√©er une table FTS5 (version la plus r√©cente)
  SQLiteConnection.ExecuteDirect(
    'CREATE VIRTUAL TABLE articles_fts USING fts5(' +
    '  titre,' +
    '  contenu,' +
    '  tags,' +
    '  tokenize=''porter unicode61''' +  // Stemming et Unicode
    ')'
  );

  // Alimenter la table FTS
  SQLQuery.SQL.Text :=
    'INSERT INTO articles_fts (titre, contenu, tags) ' +
    'SELECT titre, contenu, tags FROM articles';
  SQLQuery.ExecSQL;

  // Recherche simple
  SQLQuery.SQL.Text :=
    'SELECT * FROM articles_fts WHERE articles_fts MATCH ''lazarus pascal''';
  SQLQuery.Open;

  // Recherche avanc√©e avec op√©rateurs
  SQLQuery.SQL.Text :=
    'SELECT * FROM articles_fts WHERE articles_fts MATCH ' +
    '''titre:pascal OR contenu:"free pascal" NOT obsolete''';
  SQLQuery.Open;

  // Recherche avec scoring
  SQLQuery.SQL.Text :=
    'SELECT *, rank FROM articles_fts ' +
    'WHERE articles_fts MATCH :recherche ' +
    'ORDER BY rank';
  SQLQuery.ParamByName('recherche').AsString := 'database sqlite';
  SQLQuery.Open;

  // Snippets (extraits avec mots surlign√©s)
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  snippet(articles_fts, 0, ''<b>'', ''</b>'', ''...'', 10) as titre_extrait,' +
    '  snippet(articles_fts, 1, ''<b>'', ''</b>'', ''...'', 30) as contenu_extrait ' +
    'FROM articles_fts ' +
    'WHERE articles_fts MATCH :recherche';
  SQLQuery.ParamByName('recherche').AsString := 'tutorial';
  SQLQuery.Open;
end;
```

### JSON Support (SQLite 3.9.0+)

```pascal
procedure UtiliserJSON;
begin
  // Cr√©er une table avec JSON
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE configurations (' +
    '  id INTEGER PRIMARY KEY,' +
    '  app_name TEXT,' +
    '  settings TEXT CHECK(json_valid(settings))' +  // Validation JSON
    ')'
  );

  // Ins√©rer du JSON
  SQLQuery.SQL.Text :=
    'INSERT INTO configurations (app_name, settings) VALUES (:app, :json)';
  SQLQuery.ParamByName('app').AsString := 'MonApp';
  SQLQuery.ParamByName('json').AsString :=
    '{"theme": "dark", "language": "fr", "debug": false, "version": 1.2}';
  SQLQuery.ExecSQL;

  // Extraire des valeurs JSON
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  app_name,' +
    '  json_extract(settings, ''$.theme'') as theme,' +
    '  json_extract(settings, ''$.language'') as lang ' +
    'FROM configurations';
  SQLQuery.Open;

  // Modifier du JSON
  SQLQuery.SQL.Text :=
    'UPDATE configurations ' +
    'SET settings = json_set(settings, ''$.theme'', :theme) ' +
    'WHERE id = :id';
  SQLQuery.ParamByName('theme').AsString := 'light';
  SQLQuery.ParamByName('id').AsInteger := 1;
  SQLQuery.ExecSQL;

  // Requ√™tes sur JSON
  SQLQuery.SQL.Text :=
    'SELECT * FROM configurations ' +
    'WHERE json_extract(settings, ''$.debug'') = true';
  SQLQuery.Open;

  // JSON arrays
  SQLQuery.SQL.Text :=
    'INSERT INTO configurations (app_name, settings) ' +
    'VALUES (''App2'', ''{"users": ["alice", "bob", "charlie"]}'')';
  SQLQuery.ExecSQL;

  // Parcourir un array JSON
  SQLQuery.SQL.Text :=
    'SELECT value FROM configurations, json_each(settings, ''$.users'') ' +
    'WHERE app_name = ''App2''';
  SQLQuery.Open;
end;
```

### Common Table Expressions (CTE)

```pascal
procedure UtiliserCTE;
begin
  // CTE simple
  SQLQuery.SQL.Text :=
    'WITH ventes_mensuelles AS (' +
    '  SELECT ' +
    '    strftime(''%Y-%m'', date_vente) as mois,' +
    '    SUM(montant) as total ' +
    '  FROM ventes ' +
    '  GROUP BY strftime(''%Y-%m'', date_vente)' +
    ') ' +
    'SELECT * FROM ventes_mensuelles WHERE total > 1000';
  SQLQuery.Open;

  // CTE r√©cursive (hi√©rarchie)
  SQLQuery.SQL.Text :=
    'WITH RECURSIVE arbre_categories AS (' +
    '  -- Ancre : cat√©gories racines' +
    '  SELECT id, nom, parent_id, 0 as niveau ' +
    '  FROM categories ' +
    '  WHERE parent_id IS NULL ' +
    '  UNION ALL ' +
    '  -- R√©cursion : sous-cat√©gories' +
    '  SELECT c.id, c.nom, c.parent_id, a.niveau + 1 ' +
    '  FROM categories c ' +
    '  JOIN arbre_categories a ON c.parent_id = a.id' +
    ') ' +
    'SELECT ' +
    '  printf(''%*s%s'', niveau * 2, '''', nom) as nom_indente,' +
    '  niveau ' +
    'FROM arbre_categories ' +
    'ORDER BY id';
  SQLQuery.Open;

  // CTE multiple
  SQLQuery.SQL.Text :=
    'WITH ' +
    'top_clients AS (' +
    '  SELECT client_id, SUM(montant) as total ' +
    '  FROM commandes ' +
    '  GROUP BY client_id ' +
    '  ORDER BY total DESC ' +
    '  LIMIT 10' +
    '),' +
    'stats AS (' +
    '  SELECT AVG(total) as moyenne FROM top_clients' +
    ') ' +
    'SELECT c.*, s.moyenne ' +
    'FROM top_clients c, stats s';
  SQLQuery.Open;
end;
```

### Window Functions (SQLite 3.25.0+)

```pascal
procedure UtiliserWindowFunctions;
begin
  // Rang et num√©rotation
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  nom,' +
    '  ventes,' +
    '  ROW_NUMBER() OVER (ORDER BY ventes DESC) as rang,' +
    '  RANK() OVER (ORDER BY ventes DESC) as rang_egal,' +
    '  DENSE_RANK() OVER (ORDER BY ventes DESC) as rang_dense ' +
    'FROM vendeurs';
  SQLQuery.Open;

  // Calculs cumulatifs
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  date_vente,' +
    '  montant,' +
    '  SUM(montant) OVER (ORDER BY date_vente) as cumul,' +
    '  AVG(montant) OVER (ORDER BY date_vente ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) as moy_7j ' +
    'FROM ventes';
  SQLQuery.Open;

  // Partitionnement
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  categorie,' +
    '  produit,' +
    '  prix,' +
    '  AVG(prix) OVER (PARTITION BY categorie) as prix_moy_categorie,' +
    '  prix - AVG(prix) OVER (PARTITION BY categorie) as ecart ' +
    'FROM produits';
  SQLQuery.Open;

  // Lead et Lag (valeurs pr√©c√©dentes/suivantes)
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  date,' +
    '  valeur,' +
    '  LAG(valeur, 1) OVER (ORDER BY date) as valeur_precedente,' +
    '  LEAD(valeur, 1) OVER (ORDER BY date) as valeur_suivante,' +
    '  valeur - LAG(valeur, 1) OVER (ORDER BY date) as variation ' +
    'FROM mesures';
  SQLQuery.Open;
end;
```

## Extensions SQLite

### Chargement d'extensions

```pascal
procedure ChargerExtensions;
begin
  // Activer le chargement d'extensions
  SQLiteConnection.ExecuteDirect('PRAGMA load_extension = ON');

  // Charger une extension
  {$IFDEF WINDOWS}
  SQLiteConnection.ExecuteDirect('SELECT load_extension(''spatialite.dll'')');
  {$ENDIF}
  {$IFDEF UNIX}
  SQLiteConnection.ExecuteDirect('SELECT load_extension(''mod_spatialite.so'')');
  {$ENDIF}

  // Utiliser l'extension (exemple avec SpatiaLite pour donn√©es g√©ographiques)
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE points (' +
    '  id INTEGER PRIMARY KEY,' +
    '  nom TEXT' +
    ')'
  );

  SQLiteConnection.ExecuteDirect(
    'SELECT AddGeometryColumn(''points'', ''geom'', 4326, ''POINT'', 2)'
  );
end;
```

### Fonctions personnalis√©es en Pascal

```pascal
// SQLite permet d'ajouter des fonctions personnalis√©es
type
  TCustomSQLiteFunction = class
    class procedure RegisterFunctions(AConnection: TSQLite3Connection);
    class function CalculerTVA(AContext: Pointer; AArgCount: Integer;
      AArgs: Pointer): Integer; cdecl; static;
  end;

class procedure TCustomSQLiteFunction.RegisterFunctions(AConnection: TSQLite3Connection);
begin
  // N√©cessite l'acc√®s direct √† l'API SQLite
  // Exemple conceptuel
  {
  sqlite3_create_function(
    AConnection.Handle,
    'calculer_tva',
    1,  // Nombre d'arguments
    SQLITE_UTF8,
    nil,
    @CalculerTVA,
    nil,
    nil
  );
  }
end;

class function TCustomSQLiteFunction.CalculerTVA(AContext: Pointer;
  AArgCount: Integer; AArgs: Pointer): Integer; cdecl;
begin
  // Impl√©mentation de la fonction personnalis√©e
  // R√©cup√©rer l'argument, calculer, retourner le r√©sultat
  Result := SQLITE_OK;
end;

// Utilisation apr√®s enregistrement
procedure UtiliserFonctionPersonnalisee;
begin
  SQLQuery.SQL.Text := 'SELECT prix_ht, calculer_tva(prix_ht) as prix_ttc FROM produits';
  SQLQuery.Open;
end;
```

## Int√©gration avec l'application

### SQLite comme format de document

```pascal
type
  TDocumentSQLite = class
  private
    FConnection: TSQLite3Connection;
    FTransaction: TSQLTransaction;
    FFileName: string;
  public
    constructor Create(const AFileName: string);
    destructor Destroy; override;
    procedure SaveDocument;
    procedure LoadDocument;
    property FileName: string read FFileName;
  end;

constructor TDocumentSQLite.Create(const AFileName: string);
begin
  FFileName := AFileName;
  FConnection := TSQLite3Connection.Create(nil);
  FTransaction := TSQLTransaction.Create(nil);

  FConnection.DatabaseName := FFileName;
  FConnection.Transaction := FTransaction;
  FTransaction.Database := FConnection;

  FConnection.Open;

  // Cr√©er la structure si nouveau fichier
  if not TableExists('metadata') then
  begin
    FConnection.ExecuteDirect(
      'CREATE TABLE metadata (' +
      '  key TEXT PRIMARY KEY,' +
      '  value TEXT' +
      ')'
    );

    FConnection.ExecuteDirect(
      'INSERT INTO metadata VALUES (''version'', ''1.0''),' +
      '(''created'', datetime(''now'')),' +
      '(''application'', ''MonApp'')'
    );

    // Cr√©er les autres tables selon le type de document
    CreateDocumentStructure;
  end;
end;

procedure TDocumentSQLite.SaveDocument;
begin
  // Optimiser avant sauvegarde
  FConnection.ExecuteDirect('PRAGMA optimize');
  FConnection.ExecuteDirect('VACUUM');

  // Mettre √† jour les m√©tadonn√©es
  FConnection.ExecuteDirect(
    'UPDATE metadata SET value = datetime(''now'') WHERE key = ''modified'''
  );

  FTransaction.Commit;
end;
```

### Mode multi-utilisateur simul√©

```pascal
procedure SimulerMultiUtilisateur;
var
  MasterDB, LocalDB: string;
begin
  MasterDB := '\\serveur\partage\master.db';
  LocalDB := GetTempDir + 'local_' + GetCurrentUserName + '.db';

  // Copier la base ma√Ætre localement
  CopyFile(PChar(MasterDB), PChar(LocalDB), False);

  // Travailler en local
  SQLiteConnection.DatabaseName := LocalDB;
  SQLiteConnection.Open;

  // Marquer les modifications
  SQLiteConnection.ExecuteDirect(
    'CREATE TABLE IF NOT EXISTS _sync (' +
    '  table_name TEXT,' +
    '  row_id INTEGER,' +
    '  action TEXT,' +
    '  timestamp TEXT DEFAULT (datetime(''now'')),' +
    '  user TEXT' +
    ')'
  );

  // Trigger pour tracker les changements
  SQLiteConnection.ExecuteDirect(
    'CREATE TRIGGER track_changes ' +
    'AFTER UPDATE ON donnees ' +
    'BEGIN ' +
    '  INSERT INTO _sync (table_name, row_id, action, user) ' +
    '  VALUES (''donnees'', NEW.id, ''UPDATE'', ''' + GetCurrentUserName + '''); ' +
    'END'
  );

  // Synchronisation p√©riodique
  SynchroniserAvecMaster(LocalDB, MasterDB);
end;

procedure SynchroniserAvecMaster(const ALocal, AMaster: string);
begin
  // Impl√©menter la logique de synchronisation
  // G√©rer les conflits
  // Appliquer les changements dans l'ordre chronologique
end;
```

## Monitoring et statistiques

```pascal
procedure AfficherStatistiques;
var
  Stats: TStringList;
begin
  Stats := TStringList.Create;
  try
    // Version SQLite
    SQLQuery.SQL.Text := 'SELECT sqlite_version()';
    SQLQuery.Open;
    Stats.Add('Version SQLite : ' + SQLQuery.Fields[0].AsString);
    SQLQuery.Close;

    // Taille de la base
    Stats.Add('Taille fichier : ' +
      FormatFloat('0.00', FileSize(SQLiteConnection.DatabaseName) / 1048576) + ' MB');

    // Nombre de tables
    SQLQuery.SQL.Text := 'SELECT COUNT(*) FROM sqlite_master WHERE type = ''table''';
    SQLQuery.Open;
    Stats.Add('Nombre de tables : ' + SQLQuery.Fields[0].AsString);
    SQLQuery.Close;

    // Statistiques des pages
    SQLQuery.SQL.Text := 'PRAGMA page_count';
    SQLQuery.Open;
    var PageCount := SQLQuery.Fields[0].AsInteger;
    SQLQuery.Close;

    SQLQuery.SQL.Text := 'PRAGMA page_size';
    SQLQuery.Open;
    var PageSize := SQLQuery.Fields[0].AsInteger;
    SQLQuery.Close;

    Stats.Add(Format('Pages : %d x %d octets', [PageCount, PageSize]));

    // Cache
    SQLQuery.SQL.Text := 'PRAGMA cache_size';
    SQLQuery.Open;
    Stats.Add('Taille cache : ' + SQLQuery.Fields[0].AsString + ' pages');
    SQLQuery.Close;

    ShowMessage('Statistiques SQLite :' + LineEnding + Stats.Text);
  finally
    Stats.Free;
  end;
end;
```

## Conclusion et bonnes pratiques

### R√©capitulatif des points essentiels

1. **Toujours activer les cl√©s √©trang√®res** : `PRAGMA foreign_keys = ON`
2. **Utiliser WAL pour la concurrence** : `PRAGMA journal_mode = WAL`
3. **Transactions pour les modifications multiples** : Performance et int√©grit√©
4. **VACUUM p√©riodique** : Pour maintenir les performances
5. **Index appropri√©s** : Sur les colonnes utilis√©es dans WHERE et JOIN
6. **Pr√©parer les requ√™tes r√©p√©titives** : Gain de performance
7. **Sauvegardes r√©guli√®res** : Simple copie de fichier ou VACUUM INTO
8. **V√©rifier l'int√©grit√©** : `PRAGMA integrity_check` r√©guli√®rement
9. **Types appropri√©s** : Utiliser l'affinit√© correcte pour les donn√©es
10. **Limiter la taille** : SQLite est optimal jusqu'√† quelques GB

### Cas o√π SQLite est le meilleur choix

- Applications desktop mono-utilisateur
- Prototypage rapide
- Tests unitaires
- Configuration et pr√©f√©rences
- Applications mobiles
- Donn√©es locales temporaires
- Format de fichier structur√©

### Cas o√π pr√©f√©rer autre chose

- Applications web haute charge
- √âcritures concurrentes intensives
- Bases de donn√©es > 10 GB
- Besoin de r√©plication native
- Gestion fine des utilisateurs/droits
- Proc√©dures stock√©es complexes

SQLite avec FreePascal/Lazarus offre une solution √©l√©gante pour le stockage de donn√©es local, sans la complexit√© d'un serveur de base de donn√©es, tout en conservant la puissance du SQL et la portabilit√© parfaite entre Windows et Linux.

‚è≠Ô∏è [Firebird](/08-bases-donnees-orm-multiplatefomes/02.4-firebird.md)
