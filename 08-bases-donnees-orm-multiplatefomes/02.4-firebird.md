üîù Retour au [Sommaire](/SOMMAIRE.md)

# Firebird avec FreePascal/Lazarus - Guide Complet pour D√©butants

## Introduction √† Firebird

### Qu'est-ce que Firebird ?

Firebird est un syst√®me de gestion de base de donn√©es relationnelle (SGBDR) open source, n√© du code source d'InterBase 6.0 lib√©r√© par Borland en 2000. C'est une base de donn√©es mature, robuste et compl√®te qui offre un excellent √©quilibre entre simplicit√© et fonctionnalit√©s avanc√©es.

### L'histoire Borland/InterBase

Firebird a une relation historique forte avec l'√©cosyst√®me Pascal/Delphi :
- **InterBase** √©tait la base de donn√©es de Borland (cr√©ateur de Delphi)
- **Firebird** est le fork open source d'InterBase
- **Excellente int√©gration** avec FreePascal/Lazarus gr√¢ce √† cet h√©ritage
- **M√™me architecte** : Jim Starling, pionnier des bases de donn√©es

### Pourquoi choisir Firebird ?

1. **Vraiment gratuit** : Licence tr√®s permissive (IPL/IDPL)
2. **Z√©ro administration** : Maintenance minimale requise
3. **Multi-g√©n√©rationnel (MVCC)** : Excellente gestion de la concurrence
4. **Trois architectures** : Embedded, Classic, SuperServer
5. **Multiplateforme** : Windows, Linux, macOS, Android, etc.
6. **L√©ger** : Empreinte m√©moire r√©duite
7. **Complet** : Proc√©dures stock√©es, triggers, vues, etc.
8. **Fiable** : Tr√®s stable et √©prouv√© depuis 20+ ans
9. **SQL standard** : Conforme SQL-92 et parties de SQL-99/2003

### Les trois modes de d√©ploiement

| Mode | Description | Cas d'usage |
|------|-------------|-------------|
| **Embedded** | Biblioth√®que int√©gr√©e √† l'application | Applications desktop mono-utilisateur |
| **Classic** | Un processus par connexion | Serveurs multi-CPU, peu de connexions |
| **SuperServer** | Un processus pour toutes les connexions | Beaucoup de connexions, cache partag√© |
| **SuperClassic** | Hybride : threads avec isolation | √âquilibre performance/isolation |

### Cas d'usage typiques

- Applications de gestion (ERP, CRM, comptabilit√©)
- Syst√®mes embarqu√©s et points de vente
- Applications desktop professionnelles
- Solutions m√©tier sur mesure
- Remplacement d'Access ou SQLite pour plus de puissance
- Applications client/serveur moyennes entreprises
- Syst√®mes temps r√©el mod√©r√©s

## Installation de Firebird

### Installation sur Windows

#### M√©thode 1 : Installateur officiel

1. T√©l√©charger depuis https://firebirdsql.org/en/downloads/
2. Choisir la version (3.0 ou 4.0 recommand√©e)
3. Lancer l'installateur avec les options :
   ```
   Architecture : SuperServer (recommand√©) ou Classic
   Installation : Service Windows (recommand√©)
   Mot de passe SYSDBA : [d√©finir un mot de passe fort]
   Copier fbclient.dll dans system32 : Oui
   ```

4. Outils inclus :
   - **isql** : Outil ligne de commande
   - **gbak** : Sauvegarde/restauration
   - **gfix** : Maintenance des bases
   - **gsec** : Gestion des utilisateurs

#### M√©thode 2 : Version Embedded

```
1. T√©l√©charger Firebird Embedded
2. Extraire dans le dossier de l'application
3. Renommer fbembed.dll en fbclient.dll (ou gds32.dll)
4. Aucune installation requise !
```

### Installation sur Linux/Ubuntu

```bash
# Installation du serveur
sudo apt update
sudo apt install firebird3.0-server

# Ou version 4.0 si disponible
sudo add-apt-repository ppa:mapopa/firebird
sudo apt update
sudo apt install firebird4.0-server

# Installation des outils de d√©veloppement
sudo apt install firebird-dev

# D√©finir le mot de passe SYSDBA
sudo dpkg-reconfigure firebird3.0-server

# V√©rifier le statut
sudo systemctl status firebird3.0
```

### Installation de FlameRobin (interface graphique)

```bash
# Windows : T√©l√©charger depuis https://flamerobin.org

# Linux/Ubuntu
sudo apt install flamerobin

# Ou via Snap
sudo snap install flamerobin
```

### Configuration post-installation

```bash
# Cr√©er un utilisateur et une base
isql -user sysdba -password masterkey

SQL> CREATE USER monapp PASSWORD 'motdepasse';
SQL> CREATE DATABASE '/var/lib/firebird/3.0/data/mabase.fdb'
CON> USER 'monapp' PASSWORD 'motdepasse'
CON> PAGE_SIZE 8192
CON> DEFAULT CHARACTER SET UTF8;
SQL> EXIT;
```

## Configuration avec FreePascal/Lazarus

### Le composant TIBConnection

```pascal
uses
  IBConnection, sqldb;

var
  FBConnection: TIBConnection;
  Transaction: TSQLTransaction;
begin
  FBConnection := TIBConnection.Create(nil);
  Transaction := TSQLTransaction.Create(nil);
  try
    // Configuration pour serveur
    FBConnection.HostName := 'localhost';  // ou IP du serveur
    FBConnection.DatabaseName := 'C:\Data\mabase.fdb';  // Windows
    // ou '/var/lib/firebird/3.0/data/mabase.fdb' pour Linux

    FBConnection.UserName := 'sysdba';
    FBConnection.Password := 'masterkey';
    FBConnection.CharSet := 'UTF8';

    // Lier la transaction
    FBConnection.Transaction := Transaction;
    Transaction.Database := FBConnection;

    // Connexion
    FBConnection.Open;
    ShowMessage('Connect√© √† Firebird !');
  finally
    FBConnection.Free;
    Transaction.Free;
  end;
end;
```

### Configuration pour Embedded

```pascal
procedure ConnexionEmbedded;
begin
  // Pour Firebird Embedded, pas besoin de serveur
  FBConnection := TIBConnection.Create(nil);
  try
    // Chemin local seulement, pas de HostName
    FBConnection.DatabaseName := ExtractFilePath(ParamStr(0)) + 'data\mabase.fdb';
    FBConnection.UserName := 'sysdba';  // Ignor√© en embedded mais requis
    FBConnection.Password := 'masterkey';  // Idem
    FBConnection.CharSet := 'UTF8';

    // Cr√©er la base si elle n'existe pas
    if not FileExists(FBConnection.DatabaseName) then
    begin
      FBConnection.CreateDB;
      ShowMessage('Base de donn√©es cr√©√©e');
    end;

    FBConnection.Open;
  finally
    FBConnection.Free;
  end;
end;
```

### Param√®tres de connexion avanc√©s

```pascal
// Param√®tres suppl√©mentaires
FBConnection.Params.Add('sql_role_name=ADMIN');  // R√¥le SQL
FBConnection.Params.Add('lc_ctype=UTF8');         // Character set
FBConnection.Params.Add('page_size=8192');        // Taille de page (cr√©ation)

// Dialecte SQL (1 ou 3, utiliser 3 pour les nouvelles bases)
FBConnection.Params.Add('sql_dialect=3');

// Pour Firebird 3.0+ avec wire protocol encryption
FBConnection.Params.Add('WireCrypt=Enabled');

// Connection pooling
FBConnection.KeepConnection := True;
```

## Types de donn√©es Firebird

### Correspondance des types

| Firebird | Pascal/Lazarus | Notes |
|----------|---------------|-------|
| SMALLINT | SmallInt | 16 bits (-32768 √† 32767) |
| INTEGER | Integer | 32 bits |
| BIGINT | Int64 | 64 bits |
| FLOAT | Single | Pr√©cision simple |
| DOUBLE PRECISION | Double | Pr√©cision double |
| NUMERIC(p,s) | Currency/BCD | Pr√©cision exacte |
| DECIMAL(p,s) | Currency/BCD | Comme NUMERIC |
| CHAR(n) | String[n] | Longueur fixe |
| VARCHAR(n) | String | Longueur variable |
| BLOB SUB_TYPE TEXT | TBlobField/String | Texte illimit√© |
| BLOB SUB_TYPE 0 | TBlobField/TBytes | Binaire |
| DATE | TDate | Date seulement |
| TIME | TTime | Heure seulement |
| TIMESTAMP | TDateTime | Date et heure |
| BOOLEAN | Boolean | Firebird 3.0+ |
| CHAR(16) CHARACTER SET OCTETS | TGUID | Pour UUID |

### Gestion des g√©n√©rateurs (s√©quences)

```pascal
// Cr√©er un g√©n√©rateur (s√©quence)
procedure CreerGenerateur;
begin
  FBConnection.ExecuteDirect('CREATE GENERATOR GEN_CLIENT_ID');

  // Initialiser √† une valeur
  FBConnection.ExecuteDirect('SET GENERATOR GEN_CLIENT_ID TO 1000');

  // Cr√©er une table utilisant le g√©n√©rateur
  FBConnection.ExecuteDirect(
    'CREATE TABLE CLIENTS (' +
    '  ID INTEGER NOT NULL PRIMARY KEY,' +
    '  NOM VARCHAR(100) NOT NULL,' +
    '  EMAIL VARCHAR(255)' +
    ')'
  );

  // Trigger pour auto-incr√©ment
  FBConnection.ExecuteDirect(
    'CREATE TRIGGER CLIENTS_BI FOR CLIENTS ' +
    'ACTIVE BEFORE INSERT POSITION 0 ' +
    'AS ' +
    'BEGIN ' +
    '  IF (NEW.ID IS NULL) THEN ' +
    '    NEW.ID = GEN_ID(GEN_CLIENT_ID, 1); ' +
    'END'
  );
end;

// Utilisation du g√©n√©rateur
function ObtenirProchainID: Integer;
begin
  SQLQuery.SQL.Text := 'SELECT GEN_ID(GEN_CLIENT_ID, 1) FROM RDB$DATABASE';
  SQLQuery.Open;
  Result := SQLQuery.Fields[0].AsInteger;
  SQLQuery.Close;
end;

// Dans Firebird 3.0+, utiliser IDENTITY
procedure UtiliserIdentity;
begin
  FBConnection.ExecuteDirect(
    'CREATE TABLE PRODUITS (' +
    '  ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,' +
    '  NOM VARCHAR(100)' +
    ')'
  );
end;
```

### Domaines (types personnalis√©s)

```pascal
// Cr√©er des domaines r√©utilisables
procedure CreerDomaines;
begin
  // Domaine pour email
  FBConnection.ExecuteDirect(
    'CREATE DOMAIN D_EMAIL AS VARCHAR(255) ' +
    'CHECK (VALUE LIKE ''%@%.%'')'
  );

  // Domaine pour montant
  FBConnection.ExecuteDirect(
    'CREATE DOMAIN D_MONTANT AS NUMERIC(15,2) ' +
    'DEFAULT 0 ' +
    'CHECK (VALUE >= 0)'
  );

  // Domaine pour pourcentage
  FBConnection.ExecuteDirect(
    'CREATE DOMAIN D_POURCENTAGE AS NUMERIC(5,2) ' +
    'CHECK (VALUE BETWEEN 0 AND 100)'
  );

  // Utilisation dans une table
  FBConnection.ExecuteDirect(
    'CREATE TABLE FACTURES (' +
    '  ID INTEGER PRIMARY KEY,' +
    '  CLIENT_EMAIL D_EMAIL,' +
    '  MONTANT_HT D_MONTANT,' +
    '  TVA D_POURCENTAGE DEFAULT 20.00' +
    ')'
  );
end;
```

## Fonctionnalit√©s sp√©cifiques Firebird

### Proc√©dures stock√©es

```pascal
// Proc√©dure stock√©e simple
procedure CreerProcedureStockee;
begin
  FBConnection.ExecuteDirect(
    'CREATE PROCEDURE SP_CALCULER_TVA (' +
    '  MONTANT_HT NUMERIC(15,2)' +
    ') ' +
    'RETURNS (' +
    '  MONTANT_TTC NUMERIC(15,2)' +
    ') ' +
    'AS ' +
    'BEGIN ' +
    '  MONTANT_TTC = MONTANT_HT * 1.20; ' +
    'END'
  );

  // Appel de la proc√©dure
  SQLQuery.SQL.Text := 'SELECT * FROM SP_CALCULER_TVA(:montant)';
  SQLQuery.ParamByName('montant').AsFloat := 100.00;
  SQLQuery.Open;
  ShowMessage('Montant TTC : ' + SQLQuery.Fields[0].AsString);
end;

// Proc√©dure stock√©e s√©lectionnable
procedure CreerProcedureSelectionnable;
begin
  FBConnection.ExecuteDirect(
    'CREATE PROCEDURE SP_LISTE_COMMANDES (' +
    '  DATE_DEBUT DATE,' +
    '  DATE_FIN DATE' +
    ') ' +
    'RETURNS (' +
    '  ID INTEGER,' +
    '  DATE_COMMANDE DATE,' +
    '  CLIENT VARCHAR(100),' +
    '  TOTAL NUMERIC(15,2)' +
    ') ' +
    'AS ' +
    'BEGIN ' +
    '  FOR SELECT C.ID, C.DATE_COMMANDE, CL.NOM, ' +
    '       (SELECT SUM(QUANTITE * PRIX) FROM COMMANDE_ITEMS WHERE COMMANDE_ID = C.ID) ' +
    '  FROM COMMANDES C ' +
    '  JOIN CLIENTS CL ON C.CLIENT_ID = CL.ID ' +
    '  WHERE C.DATE_COMMANDE BETWEEN :DATE_DEBUT AND :DATE_FIN ' +
    '  INTO :ID, :DATE_COMMANDE, :CLIENT, :TOTAL ' +
    '  DO ' +
    '    SUSPEND; ' +
    'END'
  );

  // Utilisation comme une table
  SQLQuery.SQL.Text := 'SELECT * FROM SP_LISTE_COMMANDES(''2024-01-01'', ''2024-12-31'')';
  SQLQuery.Open;
end;
```

### Triggers avanc√©s

```pascal
// Trigger multi-√©v√©nements
procedure CreerTriggerAudit;
begin
  // Table d'audit
  FBConnection.ExecuteDirect(
    'CREATE TABLE AUDIT_LOG (' +
    '  ID INTEGER PRIMARY KEY,' +
    '  TABLE_NAME VARCHAR(31),' +
    '  OPERATION VARCHAR(10),' +
    '  USER_NAME VARCHAR(31),' +
    '  TIMESTAMP_OP TIMESTAMP,' +
    '  OLD_VALUE VARCHAR(1000),' +
    '  NEW_VALUE VARCHAR(1000)' +
    ')'
  );

  // Trigger universel
  FBConnection.ExecuteDirect(
    'CREATE TRIGGER TR_CLIENTS_AUDIT FOR CLIENTS ' +
    'ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0 ' +
    'AS ' +
    'DECLARE VARIABLE OPERATION VARCHAR(10); ' +
    'BEGIN ' +
    '  IF (INSERTING) THEN OPERATION = ''INSERT''; ' +
    '  ELSE IF (UPDATING) THEN OPERATION = ''UPDATE''; ' +
    '  ELSE IF (DELETING) THEN OPERATION = ''DELETE''; ' +
    '  ' +
    '  INSERT INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, TIMESTAMP_OP, OLD_VALUE, NEW_VALUE) ' +
    '  VALUES (''CLIENTS'', :OPERATION, CURRENT_USER, CURRENT_TIMESTAMP, ' +
    '    COALESCE(OLD.NOM, ''''), COALESCE(NEW.NOM, '''')); ' +
    'END'
  );
end;

// Trigger avec exceptions personnalis√©es
procedure CreerTriggerValidation;
begin
  // Cr√©er une exception
  FBConnection.ExecuteDirect(
    'CREATE EXCEPTION EX_STOCK_INSUFFISANT ''Stock insuffisant pour ce produit'''
  );

  // Trigger utilisant l'exception
  FBConnection.ExecuteDirect(
    'CREATE TRIGGER TR_CHECK_STOCK FOR COMMANDE_ITEMS ' +
    'ACTIVE BEFORE INSERT OR UPDATE POSITION 0 ' +
    'AS ' +
    'DECLARE VARIABLE STOCK_ACTUEL INTEGER; ' +
    'BEGIN ' +
    '  SELECT STOCK FROM PRODUITS WHERE ID = NEW.PRODUIT_ID INTO :STOCK_ACTUEL; ' +
    '  IF (STOCK_ACTUEL < NEW.QUANTITE) THEN ' +
    '    EXCEPTION EX_STOCK_INSUFFISANT; ' +
    'END'
  );
end;
```

### Vues avec triggers (vues modifiables)

```pascal
// Vue modifiable avec triggers
procedure CreerVueModifiable;
begin
  // Vue joignant plusieurs tables
  FBConnection.ExecuteDirect(
    'CREATE VIEW V_CLIENTS_COMMANDES AS ' +
    'SELECT C.ID, C.NOM, C.EMAIL, ' +
    '  COUNT(CO.ID) AS NB_COMMANDES, ' +
    '  SUM(CO.MONTANT_TOTAL) AS TOTAL_COMMANDES ' +
    'FROM CLIENTS C ' +
    'LEFT JOIN COMMANDES CO ON C.ID = CO.CLIENT_ID ' +
    'GROUP BY C.ID, C.NOM, C.EMAIL'
  );

  // Trigger pour INSERT sur la vue
  FBConnection.ExecuteDirect(
    'CREATE TRIGGER V_CLIENTS_COMMANDES_I FOR V_CLIENTS_COMMANDES ' +
    'ACTIVE INSTEAD OF INSERT POSITION 0 ' +
    'AS ' +
    'BEGIN ' +
    '  INSERT INTO CLIENTS (NOM, EMAIL) VALUES (NEW.NOM, NEW.EMAIL); ' +
    'END'
  );

  // Trigger pour UPDATE sur la vue
  FBConnection.ExecuteDirect(
    'CREATE TRIGGER V_CLIENTS_COMMANDES_U FOR V_CLIENTS_COMMANDES ' +
    'ACTIVE INSTEAD OF UPDATE POSITION 0 ' +
    'AS ' +
    'BEGIN ' +
    '  UPDATE CLIENTS SET NOM = NEW.NOM, EMAIL = NEW.EMAIL WHERE ID = OLD.ID; ' +
    'END'
  );
end;
```

### Computed Fields (champs calcul√©s)

```pascal
// Champs calcul√©s dans les tables
procedure CreerChampsCalcules;
begin
  FBConnection.ExecuteDirect(
    'CREATE TABLE EMPLOYES (' +
    '  ID INTEGER PRIMARY KEY,' +
    '  PRENOM VARCHAR(50),' +
    '  NOM VARCHAR(50),' +
    '  NOM_COMPLET COMPUTED BY (PRENOM || '' '' || NOM),' +
    '  DATE_NAISSANCE DATE,' +
    '  AGE COMPUTED BY (EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM DATE_NAISSANCE)),' +
    '  SALAIRE_BRUT NUMERIC(10,2),' +
    '  SALAIRE_NET COMPUTED BY (SALAIRE_BRUT * 0.77)' +
    ')'
  );

  // Les champs calcul√©s sont automatiquement mis √† jour
  SQLQuery.SQL.Text := 'SELECT NOM_COMPLET, AGE, SALAIRE_NET FROM EMPLOYES';
  SQLQuery.Open;
end;
```

## Transactions et isolation

### Niveaux d'isolation Firebird

```pascal
// Configuration des transactions
procedure ConfigurerTransaction;
begin
  // READ COMMITTED - Le plus courant
  Transaction.Params.Clear;
  Transaction.Params.Add('isc_tpb_read_committed');
  Transaction.Params.Add('isc_tpb_rec_version');  // Ou isc_tpb_no_rec_version
  Transaction.Params.Add('isc_tpb_write');        // Ou isc_tpb_read pour lecture seule
  Transaction.Params.Add('isc_tpb_wait');         // Ou isc_tpb_nowait

  // SNAPSHOT (REPEATABLE READ)
  Transaction.Params.Clear;
  Transaction.Params.Add('isc_tpb_concurrency');
  Transaction.Params.Add('isc_tpb_write');

  // SNAPSHOT TABLE STABILITY (SERIALIZABLE)
  Transaction.Params.Clear;
  Transaction.Params.Add('isc_tpb_consistency');
  Transaction.Params.Add('isc_tpb_write');
end;

// Transactions avec retry automatique
procedure TransactionAvecRetry;
var
  Retries: Integer;
  Success: Boolean;
begin
  Retries := 0;
  Success := False;

  while (Retries < 3) and not Success do
  begin
    Transaction.StartTransaction;
    try
      // Op√©rations
      SQLQuery.SQL.Text := 'UPDATE COMPTES SET SOLDE = SOLDE - :montant WHERE ID = :id';
      SQLQuery.ParamByName('montant').AsFloat := 100.00;
      SQLQuery.ParamByName('id').AsInteger := 1;
      SQLQuery.ExecSQL;

      // Validation
      Transaction.Commit;
      Success := True;
    except
      on E: Exception do
      begin
        Transaction.Rollback;

        // V√©rifier si c'est un deadlock
        if Pos('deadlock', LowerCase(E.Message)) > 0 then
        begin
          Inc(Retries);
          Sleep(Random(1000)); // Attente al√©atoire
        end
        else
          raise; // Autre erreur
      end;
    end;
  end;

  if not Success then
    raise Exception.Create('Transaction impossible apr√®s 3 tentatives');
end;
```

### Savepoints

```pascal
// Utilisation des savepoints pour rollback partiel
procedure TransactionAvecSavepoints;
begin
  Transaction.StartTransaction;
  try
    // Premi√®re op√©ration
    SQLQuery.SQL.Text := 'INSERT INTO LOG_OPERATIONS (MESSAGE) VALUES (:msg)';
    SQLQuery.ParamByName('msg').AsString := 'D√©but transaction';
    SQLQuery.ExecSQL;

    // Cr√©er un savepoint
    FBConnection.ExecuteDirect('SAVEPOINT SP1');

    try
      // Op√©ration risqu√©e
      SQLQuery.SQL.Text := 'UPDATE DONNEES_CRITIQUES SET VALEUR = :val WHERE ID = :id';
      SQLQuery.ParamByName('val').AsString := 'Nouvelle valeur';
      SQLQuery.ParamByName('id').AsInteger := 1;
      SQLQuery.ExecSQL;

      // Si erreur de validation m√©tier
      if not ValiderDonnees then
      begin
        FBConnection.ExecuteDirect('ROLLBACK TO SP1');
        // Continue la transaction sans cette modification
      end;
    except
      // Revenir au savepoint sans annuler toute la transaction
      FBConnection.ExecuteDirect('ROLLBACK TO SP1');
    end;

    // Derni√®re op√©ration
    SQLQuery.SQL.Text := 'INSERT INTO LOG_OPERATIONS (MESSAGE) VALUES (:msg)';
    SQLQuery.ParamByName('msg').AsString := 'Fin transaction';
    SQLQuery.ExecSQL;

    Transaction.Commit;
  except
    Transaction.Rollback;
    raise;
  end;
end;
```

## Optimisation et performance

### Index et statistiques

```pascal
// Cr√©ation d'index optimaux
procedure CreerIndex;
begin
  // Index simple
  FBConnection.ExecuteDirect(
    'CREATE INDEX IDX_CLIENTS_NOM ON CLIENTS (NOM)'
  );

  // Index unique
  FBConnection.ExecuteDirect(
    'CREATE UNIQUE INDEX IDX_CLIENTS_EMAIL ON CLIENTS (EMAIL)'
  );

  // Index compos√©
  FBConnection.ExecuteDirect(
    'CREATE INDEX IDX_COMMANDES_CLIENT_DATE ON COMMANDES (CLIENT_ID, DATE_COMMANDE)'
  );

  // Index descendant (utile pour ORDER BY DESC)
  FBConnection.ExecuteDirect(
    'CREATE DESCENDING INDEX IDX_COMMANDES_DATE_DESC ON COMMANDES (DATE_COMMANDE)'
  );

  // Index sur expression (Firebird 3.0+)
  FBConnection.ExecuteDirect(
    'CREATE INDEX IDX_CLIENTS_NOM_UPPER ON CLIENTS COMPUTED BY (UPPER(NOM))'
  );

  // Recalculer les statistiques
  FBConnection.ExecuteDirect('SET STATISTICS INDEX IDX_CLIENTS_NOM');

  // Reconstruire tous les index
  var Tables := TStringList.Create;
  try
    FBConnection.GetTableNames(Tables);
    for var TableName in Tables do
    begin
      SQLQuery.SQL.Text := 'SELECT RDB$INDEX_NAME FROM RDB$INDICES ' +
                          'WHERE RDB$RELATION_NAME = :table';
      SQLQuery.ParamByName('table').AsString := TableName;
      SQLQuery.Open;

      while not SQLQuery.EOF do
      begin
        FBConnection.ExecuteDirect('SET STATISTICS INDEX ' +
                                  SQLQuery.Fields[0].AsString);
        SQLQuery.Next;
      end;
      SQLQuery.Close;
    end;
  finally
    Tables.Free;
  end;
end;
```

### Plan d'ex√©cution et optimisation

```pascal
// Analyser le plan d'ex√©cution
procedure AnalyserPlan(const ASQL: string);
var
  Plan: string;
begin
  // Obtenir le plan sans ex√©cuter
  SQLQuery.SQL.Text := ASQL;
  SQLQuery.Prepare;
  Plan := SQLQuery.Plan;

  ShowMessage('Plan d''ex√©cution :' + LineEnding + Plan);

  // Analyser le plan
  if Pos('NATURAL', Plan) > 0 then
    ShowMessage('Attention : Scan complet d√©tect√© (NATURAL)');

  if Pos('SORT', Plan) > 0 then
    ShowMessage('Tri d√©tect√© - v√©rifier les index');
end;

// Optimisation des requ√™tes
procedure OptimiserRequetes;
begin
  // Forcer l'utilisation d'un index sp√©cifique
  SQLQuery.SQL.Text :=
    'SELECT * FROM CLIENTS ' +
    'PLAN (CLIENTS INDEX (IDX_CLIENTS_NOM)) ' +
    'WHERE NOM STARTING WITH ''A''';

  // Optimisation avec hints (commentaires)
  SQLQuery.SQL.Text :=
    'SELECT /*+ FIRST_ROWS */ * FROM COMMANDES ' +
    'WHERE DATE_COMMANDE >= ''2024-01-01''';
end;
```

### Cache et buffers

```pascal
// Configuration du cache
procedure ConfigurerCache;
begin
  // Taille du cache en pages (par d√©faut 2048)
  FBConnection.Params.Add('cache_pages=8192');

  // Pour Firebird 3.0+, cache par base de donn√©es
  FBConnection.ExecuteDirect(
    'ALTER DATABASE SET DEFAULT CACHE 10000 PAGES'
  );

  // Statistiques du cache
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  MON$PAGE_READS as lectures_disque,' +
    '  MON$PAGE_WRITES as ecritures_disque,' +
    '  MON$PAGE_FETCHES as pages_demandees,' +
    '  MON$PAGE_MARKS as pages_modifiees ' +
    'FROM MON$IO_STATS ' +
    'WHERE MON$STAT_GROUP = 0';  // Database level
  SQLQuery.Open;

  var HitRatio := (SQLQuery.FieldByName('pages_demandees').AsFloat -
                   SQLQuery.FieldByName('lectures_disque').AsFloat) /
                   SQLQuery.FieldByName('pages_demandees').AsFloat * 100;

  ShowMessage(Format('Cache hit ratio : %.2f%%', [HitRatio]));
end;
```

## Monitoring et administration

### Tables de monitoring (MON$)

```pascal
// Surveiller les connexions actives
procedure MonitorerConnexions;
begin
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  A.MON$USER as utilisateur,' +
    '  A.MON$REMOTE_ADDRESS as adresse_ip,' +
    '  A.MON$REMOTE_PROCESS as processus,' +
    '  A.MON$TIMESTAMP as connexion_depuis,' +
    '  S.MON$SQL_TEXT as requete_actuelle ' +
    'FROM MON$ATTACHMENTS A ' +
    'LEFT JOIN MON$STATEMENTS S ON A.MON$ATTACHMENT_ID = S.MON$ATTACHMENT_ID ' +
    'WHERE A.MON$ATTACHMENT_ID <> CURRENT_CONNECTION';
  SQLQuery.Open;

  // Afficher les r√©sultats
  while not SQLQuery.EOF do
  begin
    WriteLn(Format('User: %s, IP: %s, SQL: %s',
      [SQLQuery.FieldByName('utilisateur').AsString,
       SQLQuery.FieldByName('adresse_ip').AsString,
       SQLQuery.FieldByName('requete_actuelle').AsString]));
    SQLQuery.Next;
  end;
end;

// Tuer une connexion probl√©matique
procedure TuerConnexion(AAttachmentID: Integer);
begin
  FBConnection.ExecuteDirect(
    'DELETE FROM MON$ATTACHMENTS WHERE MON$ATTACHMENT_ID = ' + IntToStr(AAttachmentID)
  );
end;

// Surveiller les transactions longues
procedure MonitorerTransactions;
begin
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  T.MON$TRANSACTION_ID as trans_id,' +
    '  T.MON$TIMESTAMP as debut,' +
    '  DATEDIFF(SECOND, T.MON$TIMESTAMP, CURRENT_TIMESTAMP) as duree_sec,' +
    '  T.MON$STATE as etat,' +
    '  T.MON$ISOLATION_MODE as isolation,' +
    '  A.MON$USER as utilisateur ' +
    'FROM MON$TRANSACTIONS T ' +
    'JOIN MON$ATTACHMENTS A ON T.MON$ATTACHMENT_ID = A.MON$ATTACHMENT_ID ' +
    'WHERE DATEDIFF(SECOND, T.MON$TIMESTAMP, CURRENT_TIMESTAMP) > 60';  // Plus d'une minute

  SQLQuery.Open;

  while not SQLQuery.EOF do
  begin
    ShowMessage(Format('Transaction longue : ID=%d, User=%s, Dur√©e=%d sec',
      [SQLQuery.FieldByName('trans_id').AsInteger,
       SQLQuery.FieldByName('utilisateur').AsString,
       SQLQuery.FieldByName('duree_sec').AsInteger]));

    // Optionnel : tuer les transactions trop longues
    if SQLQuery.FieldByName('duree_sec').AsInteger > 300 then // 5 minutes
    begin
      FBConnection.ExecuteDirect(
        'DELETE FROM MON$TRANSACTIONS WHERE MON$TRANSACTION_ID = ' +
        SQLQuery.FieldByName('trans_id').AsString
      );
    end;

    SQLQuery.Next;
  end;
  SQLQuery.Close;
end;

// Analyser l'activit√© de la base
procedure AnalyserActivite;
var
  Stats: TStringList;
begin
  Stats := TStringList.Create;
  try
    // Statistiques globales
    SQLQuery.SQL.Text :=
      'SELECT ' +
      '  (SELECT COUNT(*) FROM MON$ATTACHMENTS WHERE MON$ATTACHMENT_ID <> CURRENT_CONNECTION) as connexions,' +
      '  (SELECT COUNT(*) FROM MON$TRANSACTIONS) as transactions,' +
      '  (SELECT COUNT(*) FROM MON$STATEMENTS WHERE MON$STATE = 1) as requetes_actives ' +
      'FROM RDB$DATABASE';
    SQLQuery.Open;

    Stats.Add('=== Activit√© actuelle ===');
    Stats.Add('Connexions : ' + SQLQuery.FieldByName('connexions').AsString);
    Stats.Add('Transactions : ' + SQLQuery.FieldByName('transactions').AsString);
    Stats.Add('Requ√™tes actives : ' + SQLQuery.FieldByName('requetes_actives').AsString);
    SQLQuery.Close;

    // Top des requ√™tes lentes
    SQLQuery.SQL.Text :=
      'SELECT FIRST 10 ' +
      '  S.MON$SQL_TEXT as requete,' +
      '  COUNT(*) as executions,' +
      '  SUM(R.MON$RECORD_SEQ_READS) as lectures_seq,' +
      '  SUM(R.MON$RECORD_IDX_READS) as lectures_idx ' +
      'FROM MON$STATEMENTS S ' +
      'JOIN MON$RECORD_STATS R ON S.MON$STATEMENT_ID = R.MON$STATEMENT_ID ' +
      'WHERE S.MON$SQL_TEXT IS NOT NULL ' +
      'GROUP BY S.MON$SQL_TEXT ' +
      'ORDER BY 3 DESC';
    SQLQuery.Open;

    Stats.Add('');
    Stats.Add('=== Top 10 requ√™tes consommatrices ===');
    while not SQLQuery.EOF do
    begin
      Stats.Add(Format('Lectures: %d (seq) + %d (idx) - %s',
        [SQLQuery.FieldByName('lectures_seq').AsInteger,
         SQLQuery.FieldByName('lectures_idx').AsInteger,
         Copy(SQLQuery.FieldByName('requete').AsString, 1, 50)]));
      SQLQuery.Next;
    end;

    ShowMessage(Stats.Text);
  finally
    Stats.Free;
    SQLQuery.Close;
  end;
end;
```

### Surveillance de la taille et croissance

```pascal
procedure AnalyserTailleBase;
var
  PageSize, PageCount: Integer;
  FileSize: Int64;
  TableStats: TStringList;
begin
  // Informations sur les pages
  SQLQuery.SQL.Text := 'SELECT MON$PAGE_SIZE FROM MON$DATABASE';
  SQLQuery.Open;
  PageSize := SQLQuery.Fields[0].AsInteger;
  SQLQuery.Close;

  SQLQuery.SQL.Text := 'SELECT COUNT(*) FROM RDB$PAGES';
  SQLQuery.Open;
  PageCount := SQLQuery.Fields[0].AsInteger;
  SQLQuery.Close;

  // Taille du fichier
  FileSize := GetFileSize(FBConnection.DatabaseName);

  ShowMessage(Format('Base de donn√©es : %.2f MB' + LineEnding +
    'Pages : %d x %d octets' + LineEnding +
    'Utilisation : %.1f%%',
    [FileSize / 1048576,
     PageCount, PageSize,
     (PageCount * PageSize) / FileSize * 100]));

  // Statistiques par table
  TableStats := TStringList.Create;
  try
    SQLQuery.SQL.Text :=
      'SELECT ' +
      '  R.RDB$RELATION_NAME as table_name,' +
      '  (SELECT COUNT(*) FROM RDB$PAGES P WHERE P.RDB$RELATION_ID = R.RDB$RELATION_ID) as pages ' +
      'FROM RDB$RELATIONS R ' +
      'WHERE R.RDB$SYSTEM_FLAG = 0 ' +
      'ORDER BY 2 DESC';
    SQLQuery.Open;

    TableStats.Add('=== Taille des tables ===');
    while not SQLQuery.EOF do
    begin
      TableStats.Add(Format('%s : %.2f MB',
        [Trim(SQLQuery.FieldByName('table_name').AsString),
         SQLQuery.FieldByName('pages').AsInteger * PageSize / 1048576]));
      SQLQuery.Next;
    end;

    ShowMessage(TableStats.Text);
  finally
    TableStats.Free;
    SQLQuery.Close;
  end;
end;
```

## Sauvegarde et restauration

### Sauvegarde avec GBAK

```pascal
procedure SauvegardeGBAK(const ABackupFile: string; AMetadata: Boolean = False);
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\Firebird\Firebird_3_0\gbak.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/gbak';
    {$ENDIF}

    // Param√®tres de base
    Process.Parameters.Add('-backup');  // ou -b
    Process.Parameters.Add('-verify');  // ou -v pour verbose
    Process.Parameters.Add('-user');
    Process.Parameters.Add(FBConnection.UserName);
    Process.Parameters.Add('-password');
    Process.Parameters.Add(FBConnection.Password);

    // Options de sauvegarde
    Process.Parameters.Add('-garbage');  // Collect garbage
    Process.Parameters.Add('-limbo');    // Inclure transactions en limbo
    Process.Parameters.Add('-zip');      // Compression (si support√©)

    if AMetadata then
      Process.Parameters.Add('-metadata_only')  // Structure seulement
    else
      Process.Parameters.Add('-statistics');     // Afficher statistiques

    // Source et destination
    if FBConnection.HostName <> '' then
      Process.Parameters.Add(FBConnection.HostName + ':' + FBConnection.DatabaseName)
    else
      Process.Parameters.Add(FBConnection.DatabaseName);

    Process.Parameters.Add(ABackupFile);

    Process.Options := Process.Options + [poWaitOnExit, poUsePipes];
    Process.Execute;

    if Process.ExitStatus = 0 then
      ShowMessage('Sauvegarde r√©ussie : ' + ABackupFile)
    else
      ShowMessage('Erreur lors de la sauvegarde');
  finally
    Process.Free;
  end;
end;

// Sauvegarde incr√©mentale (Firebird 2.5+)
procedure SauvegardeIncrementale(const ABackupFile: string; ALevel: Integer);
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\Firebird\Firebird_3_0\nbackup.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/nbackup';
    {$ENDIF}

    // Niveau 0 = sauvegarde compl√®te, 1+ = incr√©mental
    Process.Parameters.Add('-B');
    Process.Parameters.Add(IntToStr(ALevel));
    Process.Parameters.Add(FBConnection.DatabaseName);
    Process.Parameters.Add(ABackupFile);

    Process.Parameters.Add('-U');
    Process.Parameters.Add(FBConnection.UserName);
    Process.Parameters.Add('-P');
    Process.Parameters.Add(FBConnection.Password);

    Process.Options := Process.Options + [poWaitOnExit];
    Process.Execute;

    if Process.ExitStatus = 0 then
      ShowMessage(Format('Sauvegarde niveau %d cr√©√©e', [ALevel]))
    else
      ShowMessage('Erreur nbackup');
  finally
    Process.Free;
  end;
end;
```

### Restauration

```pascal
procedure RestaurerGBAK(const ABackupFile, ANewDatabase: string; ARemplacerExistant: Boolean);
var
  Process: TProcess;
begin
  // Fermer toutes les connexions
  FBConnection.Close;

  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\Firebird\Firebird_3_0\gbak.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/gbak';
    {$ENDIF}

    // Mode restauration
    if ARemplacerExistant then
      Process.Parameters.Add('-replace')  // Remplace la base existante
    else
      Process.Parameters.Add('-create');  // Cr√©e une nouvelle base

    Process.Parameters.Add('-verify');
    Process.Parameters.Add('-user');
    Process.Parameters.Add(FBConnection.UserName);
    Process.Parameters.Add('-password');
    Process.Parameters.Add(FBConnection.Password);

    // Options de restauration
    Process.Parameters.Add('-page_size');
    Process.Parameters.Add('8192');
    Process.Parameters.Add('-buffers');
    Process.Parameters.Add('1000');
    Process.Parameters.Add('-use_all_space');  // Pas de r√©serve pour croissance

    // Source et destination
    Process.Parameters.Add(ABackupFile);
    Process.Parameters.Add(ANewDatabase);

    Process.Options := Process.Options + [poWaitOnExit];
    Process.Execute;

    if Process.ExitStatus = 0 then
    begin
      ShowMessage('Restauration r√©ussie');
      FBConnection.DatabaseName := ANewDatabase;
      FBConnection.Open;
    end
    else
      ShowMessage('Erreur lors de la restauration');
  finally
    Process.Free;
  end;
end;
```

### Backup en ligne via Services API

```pascal
procedure BackupViaServices(const ABackupFile: string);
var
  BackupService: TIBBackupService;
begin
  BackupService := TIBBackupService.Create(nil);
  try
    // Configuration du service
    BackupService.ServerName := FBConnection.HostName;
    BackupService.DatabaseName := FBConnection.DatabaseName;
    BackupService.BackupFile.Add(ABackupFile);
    BackupService.LoginPrompt := False;
    BackupService.Params.Add('user_name=' + FBConnection.UserName);
    BackupService.Params.Add('password=' + FBConnection.Password);

    // Options
    BackupService.Options := [NonTransportable, IgnoreLimbo];
    BackupService.Verbose := True;

    // √âv√©nement pour suivre la progression
    BackupService.OnTextNotify := @BackupProgress;

    // Lancer le backup
    BackupService.Active := True;
    BackupService.ServiceStart;

    while not BackupService.Eof do
    begin
      Application.ProcessMessages;
      Sleep(100);
    end;

    ShowMessage('Backup via Services API termin√©');
  finally
    BackupService.Free;
  end;
end;

procedure BackupProgress(Sender: TObject; const AText: string);
begin
  WriteLn(AText);  // Ou afficher dans un TMemo
end;
```

## Maintenance de la base

### R√©paration et validation

```pascal
procedure ValiderBase;
var
  Process: TProcess;
  Output: TStringList;
begin
  Process := TProcess.Create(nil);
  Output := TStringList.Create;
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\Firebird\Firebird_3_0\gfix.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/gfix';
    {$ENDIF}

    // Validation compl√®te
    Process.Parameters.Add('-validate');
    Process.Parameters.Add('-full');
    Process.Parameters.Add('-no_update');  // Lecture seule
    Process.Parameters.Add('-user');
    Process.Parameters.Add(FBConnection.UserName);
    Process.Parameters.Add('-password');
    Process.Parameters.Add(FBConnection.Password);
    Process.Parameters.Add(FBConnection.DatabaseName);

    Process.Options := Process.Options + [poWaitOnExit, poUsePipes];
    Process.Execute;

    // Lire la sortie
    Output.LoadFromStream(Process.Output);

    if Process.ExitStatus = 0 then
      ShowMessage('Base valide')
    else
    begin
      ShowMessage('Probl√®mes d√©tect√©s :' + LineEnding + Output.Text);

      // Proposer r√©paration
      if MessageDlg('Voulez-vous tenter une r√©paration ?',
                    mtConfirmation, [mbYes, mbNo], 0) = mrYes then
        RepairerBase;
    end;
  finally
    Process.Free;
    Output.Free;
  end;
end;

procedure RepairerBase;
begin
  // Mettre la base en mode single-user
  ExecuteGFIX(['-shutdown', 'single', '-force', '0']);

  try
    // R√©parer
    ExecuteGFIX(['-mend', '-ignore']);

    // Valider apr√®s r√©paration
    ExecuteGFIX(['-validate', '-full']);

    // Reconstruire les index
    ExecuteGFIX(['-housekeeping', '0']);

    ShowMessage('R√©paration termin√©e');
  finally
    // Remettre en mode normal
    ExecuteGFIX(['-online']);
  end;
end;

procedure ExecuteGFIX(const AParams: array of string);
var
  Process: TProcess;
  i: Integer;
begin
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\Firebird\Firebird_3_0\gfix.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/gfix';
    {$ENDIF}

    Process.Parameters.Add('-user');
    Process.Parameters.Add(FBConnection.UserName);
    Process.Parameters.Add('-password');
    Process.Parameters.Add(FBConnection.Password);

    for i := 0 to High(AParams) do
      Process.Parameters.Add(AParams[i]);

    Process.Parameters.Add(FBConnection.DatabaseName);

    Process.Options := Process.Options + [poWaitOnExit];
    Process.Execute;
  finally
    Process.Free;
  end;
end;
```

### Sweep et garbage collection

```pascal
procedure MaintenanceRoutine;
begin
  // V√©rifier l'√©cart entre oldest transaction et next transaction
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  MON$OLDEST_TRANSACTION as oldest,' +
    '  MON$OLDEST_ACTIVE as oldest_active,' +
    '  MON$OLDEST_SNAPSHOT as oldest_snapshot,' +
    '  MON$NEXT_TRANSACTION as next_trans,' +
    '  MON$NEXT_TRANSACTION - MON$OLDEST_TRANSACTION as gap ' +
    'FROM MON$DATABASE';
  SQLQuery.Open;

  var Gap := SQLQuery.FieldByName('gap').AsInteger;
  ShowMessage(Format('Transaction gap : %d', [Gap]));
  SQLQuery.Close;

  // Si l'√©cart est trop grand, lancer un sweep
  if Gap > 20000 then
  begin
    ShowMessage('Sweep n√©cessaire');
    LancerSweep;
  end;

  // Statistiques de garbage collection
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  MON$RECORD_BACKOUTS as backouts,' +
    '  MON$RECORD_PURGES as purges,' +
    '  MON$RECORD_EXPUNGES as expunges ' +
    'FROM MON$RECORD_STATS ' +
    'WHERE MON$STAT_GROUP = 0';
  SQLQuery.Open;

  ShowMessage(Format('Garbage Collection Stats:' + LineEnding +
    'Backouts: %d, Purges: %d, Expunges: %d',
    [SQLQuery.FieldByName('backouts').AsInteger,
     SQLQuery.FieldByName('purges').AsInteger,
     SQLQuery.FieldByName('expunges').AsInteger]));
  SQLQuery.Close;
end;

procedure LancerSweep;
begin
  // M√©thode 1 : Via GFIX
  ExecuteGFIX(['-sweep']);

  // M√©thode 2 : Via SQL (Firebird 2.5+)
  // FBConnection.ExecuteDirect('SELECT RDB$SWEEP_INTERVAL FROM RDB$DATABASE WITH LOCK');

  ShowMessage('Sweep termin√©');
end;

// Configuration automatique du sweep
procedure ConfigurerSweepAuto;
begin
  // D√©finir l'intervalle de sweep (0 = d√©sactiv√©)
  ExecuteGFIX(['-sweep_interval', '20000']);

  // V√©rifier la configuration
  SQLQuery.SQL.Text := 'SELECT RDB$SWEEP_INTERVAL FROM RDB$DATABASE';
  SQLQuery.Open;
  ShowMessage('Sweep interval : ' + SQLQuery.Fields[0].AsString);
  SQLQuery.Close;
end;
```

## S√©curit√©

### Gestion des utilisateurs

```pascal
procedure GererUtilisateurs;
begin
  // Cr√©er un utilisateur (Firebird 3.0+ avec SQL)
  FBConnection.ExecuteDirect(
    'CREATE USER nouvel_user PASSWORD ''Pass123!'' ' +
    'FIRSTNAME ''Jean'' LASTNAME ''Dupont'''
  );

  // Modifier le mot de passe
  FBConnection.ExecuteDirect(
    'ALTER USER nouvel_user PASSWORD ''NouveauPass456!'''
  );

  // Activer/D√©sactiver un utilisateur (Firebird 3.0+)
  FBConnection.ExecuteDirect(
    'ALTER USER nouvel_user INACTIVE'  // ou ACTIVE
  );

  // Supprimer un utilisateur
  FBConnection.ExecuteDirect(
    'DROP USER nouvel_user'
  );

  // Lister les utilisateurs (Firebird 3.0+)
  SQLQuery.SQL.Text := 'SELECT * FROM SEC$USERS';
  SQLQuery.Open;
  while not SQLQuery.EOF do
  begin
    WriteLn(Format('User: %s, Active: %s',
      [SQLQuery.FieldByName('SEC$USER_NAME').AsString,
       SQLQuery.FieldByName('SEC$ACTIVE').AsString]));
    SQLQuery.Next;
  end;
  SQLQuery.Close;
end;

// Gestion via GSEC (ancien mais compatible)
procedure GererUtilisateursGSEC;
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\Firebird\Firebird_3_0\gsec.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/gsec';
    {$ENDIF}

    // Ajouter un utilisateur
    Process.Parameters.Add('-add');
    Process.Parameters.Add('new_user');
    Process.Parameters.Add('-pw');
    Process.Parameters.Add('password');
    Process.Parameters.Add('-fname');
    Process.Parameters.Add('Prenom');
    Process.Parameters.Add('-lname');
    Process.Parameters.Add('Nom');

    Process.Parameters.Add('-user');
    Process.Parameters.Add('sysdba');
    Process.Parameters.Add('-password');
    Process.Parameters.Add('masterkey');

    Process.Options := Process.Options + [poWaitOnExit];
    Process.Execute;
  finally
    Process.Free;
  end;
end;
```

### R√¥les et privil√®ges

```pascal
procedure GererRoles;
begin
  // Cr√©er un r√¥le
  FBConnection.ExecuteDirect('CREATE ROLE ROLE_LECTURE');
  FBConnection.ExecuteDirect('CREATE ROLE ROLE_ECRITURE');
  FBConnection.ExecuteDirect('CREATE ROLE ROLE_ADMIN');

  // Attribuer des privil√®ges au r√¥le
  FBConnection.ExecuteDirect(
    'GRANT SELECT ON ALL TABLES TO ROLE_LECTURE'
  );

  FBConnection.ExecuteDirect(
    'GRANT SELECT, INSERT, UPDATE, DELETE ON CLIENTS TO ROLE_ECRITURE'
  );

  FBConnection.ExecuteDirect(
    'GRANT ALL ON ALL TABLES TO ROLE_ADMIN WITH GRANT OPTION'
  );

  // Donner un r√¥le √† un utilisateur
  FBConnection.ExecuteDirect(
    'GRANT ROLE_LECTURE TO nouvel_user'
  );

  // Utiliser un r√¥le √† la connexion
  FBConnection.Params.Add('sql_role_name=ROLE_ADMIN');

  // V√©rifier les privil√®ges
  SQLQuery.SQL.Text :=
    'SELECT * FROM RDB$USER_PRIVILEGES ' +
    'WHERE RDB$USER = CURRENT_USER';
  SQLQuery.Open;
end;

// Privil√®ges sur objets sp√©cifiques
procedure GererPrivileges;
begin
  // Privil√®ges sur table
  FBConnection.ExecuteDirect(
    'GRANT SELECT, UPDATE (NOM, EMAIL) ON CLIENTS TO user1'
  );

  // Privil√®ges sur proc√©dure
  FBConnection.ExecuteDirect(
    'GRANT EXECUTE ON PROCEDURE SP_CALCULER_TVA TO PUBLIC'
  );

  // Privil√®ges sur g√©n√©rateur
  FBConnection.ExecuteDirect(
    'GRANT USAGE ON GENERATOR GEN_CLIENT_ID TO user1'
  );

  // R√©voquer des privil√®ges
  FBConnection.ExecuteDirect(
    'REVOKE UPDATE ON CLIENTS FROM user1'
  );
end;
```

### Chiffrement de la base (Firebird 3.0+)

```pascal
procedure ChiffrerBase;
begin
  // Installer le plugin de chiffrement (fait une fois)
  // Le plugin doit √™tre configur√© dans firebird.conf

  // Cr√©er une cl√© de chiffrement
  FBConnection.ExecuteDirect(
    'ALTER DATABASE ENCRYPT WITH DbCrypt KEY Red'  // Red est le nom de la cl√©
  );

  // V√©rifier l'√©tat du chiffrement
  SQLQuery.SQL.Text :=
    'SELECT MON$CRYPT_STATE FROM MON$DATABASE';
  SQLQuery.Open;
  case SQLQuery.Fields[0].AsInteger of
    0: ShowMessage('Non chiffr√©');
    1: ShowMessage('Chiffrement en cours');
    2: ShowMessage('Chiffr√©');
    3: ShowMessage('D√©chiffrement en cours');
  end;
  SQLQuery.Close;

  // Pour d√©chiffrer
  // FBConnection.ExecuteDirect('ALTER DATABASE DECRYPT');
end;
```

## R√©plication et haute disponibilit√©

### R√©plication asynchrone

```pascal
// Configuration de la r√©plication avec triggers
procedure ConfigurerReplication;
begin
  // Table de log pour la r√©plication
  FBConnection.ExecuteDirect(
    'CREATE TABLE REPLICATION_LOG (' +
    '  ID BIGINT PRIMARY KEY,' +
    '  TABLE_NAME VARCHAR(31),' +
    '  OPERATION VARCHAR(10),' +
    '  PRIMARY_KEY VARCHAR(100),' +
    '  DATA_JSON BLOB SUB_TYPE TEXT,' +
    '  TIMESTAMP_OP TIMESTAMP DEFAULT CURRENT_TIMESTAMP,' +
    '  REPLICATED BOOLEAN DEFAULT FALSE' +
    ')'
  );

  // Trigger g√©n√©rique pour capturer les changements
  FBConnection.ExecuteDirect(
    'CREATE TRIGGER TR_CLIENTS_REPL FOR CLIENTS ' +
    'AFTER INSERT OR UPDATE OR DELETE ' +
    'AS ' +
    'DECLARE VARIABLE JSON_DATA BLOB SUB_TYPE TEXT; ' +
    'BEGIN ' +
    '  IF (INSERTING OR UPDATING) THEN ' +
    '    JSON_DATA = ''{"id":'' || NEW.ID || '',"nom":"'' || NEW.NOM || ''"}''; ' +
    '  ELSE ' +
    '    JSON_DATA = ''{"id":'' || OLD.ID || ''}''; ' +
    '  ' +
    '  INSERT INTO REPLICATION_LOG (ID, TABLE_NAME, OPERATION, PRIMARY_KEY, DATA_JSON) ' +
    '  VALUES (GEN_ID(GEN_REPL_ID, 1), ''CLIENTS'', ' +
    '    IIF(INSERTING, ''INSERT'', IIF(UPDATING, ''UPDATE'', ''DELETE'')), ' +
    '    COALESCE(NEW.ID, OLD.ID), :JSON_DATA); ' +
    'END'
  );
end;

// Processus de r√©plication
procedure ProcessusReplication(ADestConnection: TIBConnection);
begin
  // Lire les changements non r√©pliqu√©s
  SQLQuery.SQL.Text :=
    'SELECT * FROM REPLICATION_LOG WHERE REPLICATED = FALSE ORDER BY ID';
  SQLQuery.Open;

  while not SQLQuery.EOF do
  begin
    try
      // Appliquer sur la base de destination
      AppliquerChangement(ADestConnection,
        SQLQuery.FieldByName('TABLE_NAME').AsString,
        SQLQuery.FieldByName('OPERATION').AsString,
        SQLQuery.FieldByName('DATA_JSON').AsString);

      // Marquer comme r√©pliqu√©
      FBConnection.ExecuteDirect(
        'UPDATE REPLICATION_LOG SET REPLICATED = TRUE WHERE ID = ' +
        SQLQuery.FieldByName('ID').AsString
      );
    except
      on E: Exception do
        WriteLn('Erreur r√©plication : ' + E.Message);
    end;

    SQLQuery.Next;
  end;
  SQLQuery.Close;
end;
```

## Fonctionnalit√©s Firebird 4.0

### Nouvelles fonctionnalit√©s

```pascal
// D√©clarations de fonctions SQL (Firebird 4.0)
procedure UtiliserFonctionsSQL;
begin
  // Cr√©er une fonction SQL
  FBConnection.ExecuteDirect(
    'CREATE FUNCTION FN_INITCAP(S VARCHAR(100)) ' +
    'RETURNS VARCHAR(100) ' +
    'AS ' +
    'BEGIN ' +
    '  RETURN UPPER(LEFT(S, 1)) || LOWER(SUBSTRING(S FROM 2)); ' +
    'END'
  );

  // Utilisation
  SQLQuery.SQL.Text := 'SELECT FN_INITCAP(''hello world'') FROM RDB$DATABASE';
  SQLQuery.Open;
  ShowMessage(SQLQuery.Fields[0].AsString);  // "Hello world"
end;

// Window functions am√©lior√©es
procedure WindowFunctions;
begin
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  NOM,' +
    '  SALAIRE,' +
    '  PERCENT_RANK() OVER (ORDER BY SALAIRE) as percentile,' +
    '  NTILE(4) OVER (ORDER BY SALAIRE) as quartile,' +
    '  LAG(SALAIRE, 1) OVER (ORDER BY SALAIRE) as salaire_precedent,' +
    '  LEAD(SALAIRE, 1) OVER (ORDER BY SALAIRE) as salaire_suivant ' +
    'FROM EMPLOYES';
  SQLQuery.Open;
end;

// Nouveaux types de donn√©es
procedure NouveauxTypes;
begin
  // DECFLOAT pour pr√©cision d√©cimale IEEE
  FBConnection.ExecuteDirect(
    'CREATE TABLE CALCULS (' +
    '  ID INTEGER PRIMARY KEY,' +
    '  VALEUR_PRECISE DECFLOAT(34),' +  // 34 chiffres de pr√©cision
    '  TIMESTAMP_TZ TIMESTAMP WITH TIME ZONE' +  // Avec timezone
    ')'
  );

  // INT128 pour tr√®s grands entiers
  FBConnection.ExecuteDirect(
    'ALTER TABLE CALCULS ADD GRAND_NOMBRE INT128'
  );
end;
```

## Conclusion et bonnes pratiques

### Points essentiels √† retenir

1. **Mode de d√©ploiement appropri√©**
   - **Embedded** pour applications mono-utilisateur sans installation
   - **SuperServer** pour nombreuses connexions avec cache partag√©
   - **Classic** pour serveurs multi-CPU avec peu de connexions

2. **Transactions**
   - Toujours utiliser le bon niveau d'isolation
   - √âviter les transactions longues (sweep automatique)
   - Utiliser READ ONLY pour les lectures seules

3. **Maintenance r√©guli√®re**
   - **Backup quotidien** avec GBAK
   - **Validation p√©riodique** avec GFIX
   - **Monitoring du gap** de transactions
   - **Sweep** si n√©cessaire

4. **Performance**
   - Index appropri√©s mais sans exc√®s
   - Utiliser les proc√©dures stock√©es pour logique complexe
   - Pr√©parer les requ√™tes r√©p√©titives
   - Ajuster le cache selon la RAM disponible

5. **S√©curit√©**
   - Changer le mot de passe SYSDBA par d√©faut
   - Utiliser des utilisateurs et r√¥les sp√©cifiques
   - Chiffrement pour donn√©es sensibles (Firebird 3.0+)
   - Sauvegardes r√©guli√®res et test√©es

### Comparaison avec les autres SGBD

| Aspect | Firebird | PostgreSQL | MySQL | SQLite |
|--------|----------|------------|-------|--------|
| **Installation** | Simple | Moyenne | Simple | Aucune |
| **Administration** | Minimale | Importante | Moyenne | Aucune |
| **Performances** | Excellentes | Excellentes | Tr√®s bonnes | Bonnes (local) |
| **Fonctionnalit√©s** | Compl√®tes | Tr√®s compl√®tes | Bonnes | Basiques |
| **Multi-utilisateur** | Excellent | Excellent | Tr√®s bon | Limit√© |
| **Embedded** | Oui | Non | Non | Oui (natif) |
| **Empreinte m√©moire** | Faible | Moyenne | Moyenne | Tr√®s faible |
| **Licence** | Tr√®s permissive | Permissive | GPL/Commercial | Domaine public |

### Quand choisir Firebird

#### Cas id√©aux
- Applications de gestion d'entreprise
- Logiciels commerciaux n√©cessitant une base embarqu√©e
- Migration depuis InterBase/Paradox/dBase
- Applications Delphi/FreePascal existantes
- Syst√®mes n√©cessitant peu de maintenance
- D√©ploiements sur machines limit√©es en ressources

#### Cas moins adapt√©s
- Applications web tr√®s haute charge (pr√©f√©rer PostgreSQL/MySQL)
- Big Data et analytics complexes (pr√©f√©rer PostgreSQL)
- Applications mobiles (pr√©f√©rer SQLite)
- Besoins NoSQL ou semi-structur√©s (consid√©rer MongoDB)

### Migration depuis/vers Firebird

```pascal
// Outils de migration
procedure MigrerDepuisAutreSGBD;
begin
  // Depuis MySQL/PostgreSQL
  // 1. Exporter en SQL standard
  // 2. Adapter les types de donn√©es
  // 3. Convertir les fonctions sp√©cifiques

  // Mapping des types courants
  // MySQL AUTO_INCREMENT -> Firebird GENERATOR + TRIGGER
  // PostgreSQL SERIAL -> Firebird IDENTITY (3.0+)
  // MySQL ENUM -> Firebird CHECK constraint
  // PostgreSQL ARRAY -> Firebird tables li√©es

  // Outils tiers utiles
  // - FBExport/FBCopy
  // - Database Workbench
  // - IBExpert
  // - FlameRobin pour import/export
end;

// Export vers d'autres formats
procedure ExporterDonnees;
begin
  // Export CSV
  SQLQuery.SQL.Text := 'SELECT * FROM CLIENTS';
  SQLQuery.Open;

  var CSV := TStringList.Create;
  try
    // En-t√™te
    var Header := '';
    for var i := 0 to SQLQuery.FieldCount - 1 do
    begin
      if i > 0 then Header := Header + ',';
      Header := Header + SQLQuery.Fields[i].FieldName;
    end;
    CSV.Add(Header);

    // Donn√©es
    while not SQLQuery.EOF do
    begin
      var Row := '';
      for var i := 0 to SQLQuery.FieldCount - 1 do
      begin
        if i > 0 then Row := Row + ',';
        Row := Row + '"' + SQLQuery.Fields[i].AsString + '"';
      end;
      CSV.Add(Row);
      SQLQuery.Next;
    end;

    CSV.SaveToFile('export.csv');
  finally
    CSV.Free;
    SQLQuery.Close;
  end;
end;
```

### Architecture multi-tiers avec Firebird

```pascal
type
  // Couche d'acc√®s aux donn√©es
  TDataAccessLayer = class
  private
    FConnection: TIBConnection;
    FTransaction: TSQLTransaction;
  public
    constructor Create(const AConnectionString: string);
    function ExecuteQuery(const ASQL: string): TDataSet;
    procedure ExecuteCommand(const ASQL: string);
  end;

  // Couche m√©tier
  TBusinessLayer = class
  private
    FDAL: TDataAccessLayer;
  public
    constructor Create(ADAL: TDataAccessLayer);
    function GetClientByID(AID: Integer): TClient;
    procedure SaveClient(AClient: TClient);
    function CalculateOrderTotal(AOrderID: Integer): Currency;
  end;

  // Utilisation
procedure ExempleArchitecture;
var
  DAL: TDataAccessLayer;
  BL: TBusinessLayer;
  Client: TClient;
begin
  DAL := TDataAccessLayer.Create('localhost:C:\Data\mabase.fdb');
  try
    BL := TBusinessLayer.Create(DAL);
    try
      Client := BL.GetClientByID(1);
      Client.Email := 'nouveau@email.com';
      BL.SaveClient(Client);
    finally
      BL.Free;
    end;
  finally
    DAL.Free;
  end;
end;
```

### Optimisations sp√©cifiques Firebird

```pascal
// Optimisations de connexion
procedure OptimiserConnexion;
begin
  // Buffer de cache personnalis√© par connexion
  FBConnection.Params.Add('cache_pages=4096');

  // D√©sactiver le garbage collection pour lectures intensives
  FBConnection.Params.Add('no_garbage_collect=1');

  // Forcer le protocole de connexion
  {$IFDEF WINDOWS}
  // XNET pour connexions locales (plus rapide)
  FBConnection.Params.Add('protocol=xnet');
  {$ENDIF}

  // TCP/IP pour r√©seau
  FBConnection.Params.Add('protocol=inet');

  // Dummy packet interval pour √©viter d√©connexions
  FBConnection.Params.Add('dummy_packet_interval=60');
end;

// Optimisations de requ√™tes
procedure OptimiserRequetes;
begin
  // Utiliser FIRST/SKIP au lieu de LIMIT/OFFSET
  SQLQuery.SQL.Text :=
    'SELECT FIRST 10 SKIP 20 * FROM CLIENTS ORDER BY NOM';

  // Utiliser EXISTS au lieu de COUNT pour v√©rifications
  SQLQuery.SQL.Text :=
    'SELECT 1 FROM RDB$DATABASE WHERE EXISTS ' +
    '(SELECT 1 FROM COMMANDES WHERE CLIENT_ID = :id)';

  // Utiliser WITH pour requ√™tes complexes
  SQLQuery.SQL.Text :=
    'WITH RECURSIVE TREE AS (' +
    '  SELECT * FROM CATEGORIES WHERE PARENT_ID IS NULL ' +
    '  UNION ALL ' +
    '  SELECT C.* FROM CATEGORIES C ' +
    '  JOIN TREE T ON C.PARENT_ID = T.ID' +
    ') SELECT * FROM TREE';
end;
```

### Ressources et communaut√©

#### Documentation officielle
- Site officiel : https://firebirdsql.org/
- Documentation : https://firebirdsql.org/en/documentation/
- Wiki : https://firebirdsql.org/wiki/
- Tracker de bugs : https://github.com/FirebirdSQL/firebird

#### Outils recommand√©s
- **FlameRobin** : Interface graphique l√©g√®re et gratuite
- **IBExpert** : IDE professionnel complet (version gratuite limit√©e)
- **Database Workbench** : Multi-SGBD incluant Firebird
- **DBeaver** : Outil universel supportant Firebird
- **Firebird Maestro** : Administration et d√©veloppement

#### Communaut√©
- Forum officiel : https://firebirdsql.org/en/support/
- Mailing lists actives
- Stack Overflow tag [firebird]
- Groupes Facebook et LinkedIn

### Exemple complet d'application

```pascal
program FirebirdDemo;

uses
  SysUtils, Classes, IBConnection, sqldb;

type
  TFirebirdApp = class
  private
    FConnection: TIBConnection;
    FTransaction: TSQLTransaction;
    FQuery: TSQLQuery;
    procedure InitDatabase;
    procedure CreateSchema;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Run;
  end;

constructor TFirebirdApp.Create;
begin
  FConnection := TIBConnection.Create(nil);
  FTransaction := TSQLTransaction.Create(nil);
  FQuery := TSQLQuery.Create(nil);

  // Configuration
  FConnection.DatabaseName := 'demo.fdb';
  FConnection.UserName := 'sysdba';
  FConnection.Password := 'masterkey';
  FConnection.CharSet := 'UTF8';
  FConnection.Transaction := FTransaction;

  FTransaction.Database := FConnection;

  FQuery.Database := FConnection;
  FQuery.Transaction := FTransaction;

  InitDatabase;
end;

procedure TFirebirdApp.InitDatabase;
begin
  // Cr√©er la base si n√©cessaire
  if not FileExists(FConnection.DatabaseName) then
  begin
    FConnection.CreateDB;
    CreateSchema;
  end;

  FConnection.Open;
end;

procedure TFirebirdApp.CreateSchema;
begin
  FConnection.Open;

  // Cr√©er les tables
  FConnection.ExecuteDirect(
    'CREATE TABLE CLIENTS (' +
    '  ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,' +
    '  NOM VARCHAR(100) NOT NULL,' +
    '  EMAIL VARCHAR(255) UNIQUE,' +
    '  DATE_CREATION TIMESTAMP DEFAULT CURRENT_TIMESTAMP' +
    ')'
  );

  FConnection.ExecuteDirect(
    'CREATE INDEX IDX_CLIENTS_NOM ON CLIENTS (NOM)'
  );

  // Proc√©dure stock√©e
  FConnection.ExecuteDirect(
    'CREATE PROCEDURE SP_GET_CLIENT_COUNT ' +
    'RETURNS (TOTAL INTEGER) ' +
    'AS ' +
    'BEGIN ' +
    '  SELECT COUNT(*) FROM CLIENTS INTO :TOTAL; ' +
    'END'
  );

  WriteLn('Sch√©ma cr√©√© avec succ√®s');
end;

procedure TFirebirdApp.Run;
begin
  try
    // Insertion
    FQuery.SQL.Text := 'INSERT INTO CLIENTS (NOM, EMAIL) VALUES (:nom, :email)';
    FQuery.ParamByName('nom').AsString := 'Test Client';
    FQuery.ParamByName('email').AsString := 'test@example.com';
    FQuery.ExecSQL;
    FTransaction.Commit;

    // Lecture
    FQuery.SQL.Text := 'SELECT * FROM CLIENTS';
    FQuery.Open;

    while not FQuery.EOF do
    begin
      WriteLn(Format('Client: %s - %s',
        [FQuery.FieldByName('NOM').AsString,
         FQuery.FieldByName('EMAIL').AsString]));
      FQuery.Next;
    end;

    FQuery.Close;

    // Appel proc√©dure
    FQuery.SQL.Text := 'SELECT * FROM SP_GET_CLIENT_COUNT';
    FQuery.Open;
    WriteLn('Nombre de clients : ' + FQuery.Fields[0].AsString);
    FQuery.Close;

  except
    on E: Exception do
    begin
      WriteLn('Erreur : ' + E.Message);
      if FTransaction.Active then
        FTransaction.Rollback;
    end;
  end;
end;

destructor TFirebirdApp.Destroy;
begin
  FQuery.Free;
  FTransaction.Free;
  FConnection.Free;
  inherited;
end;

// Programme principal
var
  App: TFirebirdApp;
begin
  App := TFirebirdApp.Create;
  try
    App.Run;
    WriteLn('Appuyez sur Entr√©e pour terminer...');
    ReadLn;
  finally
    App.Free;
  end;
end.
```

### Conclusion finale

Firebird est une base de donn√©es mature et robuste qui offre un excellent √©quilibre entre simplicit√© et puissance. Sa capacit√© √† fonctionner en mode embedded sans installation, combin√©e √† ses fonctionnalit√©s compl√®tes (proc√©dures stock√©es, triggers, transactions ACID), en fait un choix id√©al pour les applications FreePascal/Lazarus, particuli√®rement dans l'√©cosyst√®me Delphi/Pascal o√π elle b√©n√©ficie d'un support natif excellent.

Les points forts de Firebird - faible empreinte m√©moire, administration minimale, licence tr√®s permissive - en font une alternative s√©rieuse aux solutions commerciales pour les applications d'entreprise de taille moyenne. Avec FreePascal/Lazarus, vous disposez d'une stack compl√®tement open source, gratuite et multiplateforme pour d√©velopper des applications professionnelles robustes.

‚è≠Ô∏è [Configuration des connexions par OS](/08-bases-donnees-orm-multiplatefomes/03-configuration-connexions-par-os.md)
