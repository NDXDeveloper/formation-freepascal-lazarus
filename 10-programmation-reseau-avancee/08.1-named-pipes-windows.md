🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 10.8.1 Named Pipes (Windows)

## Introduction

Les Named Pipes (tubes nommés) sont un mécanisme IPC (Inter-Process Communication) de Windows permettant à des processus de communiquer entre eux. Ils sont appelés "nommés" car ils possèdent un nom unique dans le système, contrairement aux pipes anonymes qui n'existent que le temps d'une exécution.

Les Named Pipes Windows sont particulièrement puissants car ils supportent :
- La communication locale (sur la même machine)
- La communication réseau (entre machines différentes)
- La communication bidirectionnelle
- La sécurité intégrée (permissions Windows)

## Qu'est-ce qu'un Named Pipe ?

### Analogie

Imaginez un tuyau (pipe) qui relie deux processus :

```
Process Serveur          Named Pipe           Process Client
  ┌─────────┐           ┌────────┐             ┌─────────┐
  │         │◀──────────│  PIPE  │◀────────────│         │
  │ Lecture │           │  Nom:  │             │ Écriture│
  │         │──────────▶│ MyPipe │─────────────▶         │
  └─────────┘           └────────┘             └─────────┘
      ▲                                             │
      └─────── Les données circulent ───────────────┘
```

Le pipe possède un **nom** (par exemple : `\\.\pipe\MyPipe`) qui permet aux processus de s'y connecter.

### Caractéristiques

- **Bidirectionnel** : Communication dans les deux sens
- **Nommé** : Identifié par un nom unique
- **Local ou réseau** : `\\.\pipe\nom` (local) ou `\\serveur\pipe\nom` (réseau)
- **Orienté message ou flux** : Deux modes disponibles
- **Sécurité** : Permissions Windows (ACL)
- **Multi-instance** : Plusieurs clients peuvent se connecter au même pipe

### Syntaxe du nom

```
Format local :
\\.\pipe\NomDuPipe

Format réseau :
\\NomServeur\pipe\NomDuPipe

Exemples :
\\.\pipe\MyApp           → Local
\\.\pipe\ServiceDB       → Local
\\SERVEUR1\pipe\MyApp    → Réseau vers SERVEUR1
```

## Modes de fonctionnement

### Mode Message vs Mode Byte Stream

#### Mode Message (PIPE_TYPE_MESSAGE)

```
Serveur écrit :          Client reçoit :
  "Message 1"      →       "Message 1"
  "Message 2"      →       "Message 2"

Les messages sont préservés en tant qu'unités distinctes
```

**Utilisation :** Quand vous voulez envoyer des messages délimités

#### Mode Byte Stream (PIPE_TYPE_BYTE)

```
Serveur écrit :          Client reçoit :
  "Hello"          →       "HelloWorld"
  "World"          →       (flux continu)

Les données sont un flux continu, sans délimitation
```

**Utilisation :** Quand vous envoyez un flux de données continu

### Mode Bloquant vs Non-bloquant

#### Mode Bloquant (PIPE_WAIT)

```pascal
// L'appel attend qu'une connexion arrive
ConnectNamedPipe(Pipe, nil); // Bloque ici jusqu'à connexion
WriteLn('Client connecté !');
```

#### Mode Non-bloquant (PIPE_NOWAIT)

```pascal
// L'appel retourne immédiatement
if not ConnectNamedPipe(Pipe, nil) then
  WriteLn('Pas de client en attente');
```

## Création d'un Named Pipe (Serveur)

### Fonction CreateNamedPipe

Voici la fonction Windows pour créer un pipe :

```pascal
function CreateNamedPipe(
  lpName: LPCWSTR;                // Nom du pipe
  dwOpenMode: DWORD;              // Mode d'ouverture
  dwPipeMode: DWORD;              // Mode du pipe
  nMaxInstances: DWORD;           // Nombre max d'instances
  nOutBufferSize: DWORD;          // Taille buffer sortie
  nInBufferSize: DWORD;           // Taille buffer entrée
  nDefaultTimeOut: DWORD;         // Timeout par défaut
  lpSecurityAttributes: LPSECURITY_ATTRIBUTES // Sécurité
): THandle;
```

### Paramètres expliqués

**dwOpenMode** (Direction) :
- `PIPE_ACCESS_DUPLEX` : Bidirectionnel (lecture et écriture)
- `PIPE_ACCESS_INBOUND` : Serveur lit, client écrit
- `PIPE_ACCESS_OUTBOUND` : Serveur écrit, client lit

**dwPipeMode** (Mode) :
- `PIPE_TYPE_BYTE` : Mode flux d'octets
- `PIPE_TYPE_MESSAGE` : Mode message
- `PIPE_READMODE_BYTE` : Lecture par octets
- `PIPE_READMODE_MESSAGE` : Lecture par messages
- `PIPE_WAIT` : Mode bloquant
- `PIPE_NOWAIT` : Mode non-bloquant

**nMaxInstances** :
- Nombre de clients simultanés (1 à `PIPE_UNLIMITED_INSTANCES`)

**Buffers** :
- Taille des buffers en octets (généralement 4096 ou 8192)

## Serveur Named Pipe simple

Créons un serveur qui accepte des connexions :

```pascal
program NamedPipeServer;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils;

const
  PIPE_NAME = '\\.\pipe\MyTestPipe';
  BUFFER_SIZE = 4096;

var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Success: Boolean;

begin
  WriteLn('=== Serveur Named Pipe ===');
  WriteLn('Création du pipe : ', PIPE_NAME);

  // Création du pipe
  hPipe := CreateNamedPipe(
    PChar(PIPE_NAME),                    // Nom du pipe
    PIPE_ACCESS_DUPLEX,                  // Bidirectionnel
    PIPE_TYPE_MESSAGE or                 // Mode message
    PIPE_READMODE_MESSAGE or
    PIPE_WAIT,                           // Bloquant
    1,                                   // 1 instance (1 client à la fois)
    BUFFER_SIZE,                         // Buffer sortie
    BUFFER_SIZE,                         // Buffer entrée
    0,                                   // Timeout par défaut
    nil                                  // Sécurité par défaut
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur création pipe : ', GetLastError);
    Exit;
  end;

  WriteLn('Pipe créé avec succès');
  WriteLn('En attente de connexion client...');

  // Attente d'une connexion
  Success := ConnectNamedPipe(hPipe, nil);

  if not Success and (GetLastError <> ERROR_PIPE_CONNECTED) then
  begin
    WriteLn('Erreur connexion : ', GetLastError);
    CloseHandle(hPipe);
    Exit;
  end;

  WriteLn('Client connecté !');

  // Lecture d'un message du client
  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(
    hPipe,
    Buffer,
    SizeOf(Buffer),
    BytesRead,
    nil
  );

  if Success then
  begin
    WriteLn('Message reçu : ', Buffer);

    // Envoi d'une réponse
    Success := WriteFile(
      hPipe,
      PChar('Message reçu par le serveur'),
      Length('Message reçu par le serveur'),
      BytesWritten,
      nil
    );

    if Success then
      WriteLn('Réponse envoyée au client');
  end;

  // Déconnexion et fermeture
  DisconnectNamedPipe(hPipe);
  CloseHandle(hPipe);

  WriteLn('Pipe fermé');
  WriteLn('Appuyez sur Entrée pour quitter...');
  ReadLn;
end.
```

## Client Named Pipe simple

Créons maintenant un client qui se connecte au serveur :

```pascal
program NamedPipeClient;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils;

const
  PIPE_NAME = '\\.\pipe\MyTestPipe';
  BUFFER_SIZE = 4096;

var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Success: Boolean;
  Message: string;

begin
  WriteLn('=== Client Named Pipe ===');
  WriteLn('Connexion au pipe : ', PIPE_NAME);

  // Attente que le pipe soit disponible
  if not WaitNamedPipe(PChar(PIPE_NAME), 5000) then // 5 secondes max
  begin
    WriteLn('Le pipe n''est pas disponible');
    Exit;
  end;

  // Connexion au pipe
  hPipe := CreateFile(
    PChar(PIPE_NAME),              // Nom du pipe
    GENERIC_READ or GENERIC_WRITE, // Lecture et écriture
    0,                             // Pas de partage
    nil,                           // Sécurité par défaut
    OPEN_EXISTING,                 // Ouvrir existant
    0,                             // Attributs par défaut
    0                              // Pas de template
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur connexion : ', GetLastError);
    Exit;
  end;

  WriteLn('Connecté au serveur !');

  // Envoi d'un message
  Message := 'Bonjour depuis le client !';
  Success := WriteFile(
    hPipe,
    PChar(Message),
    Length(Message),
    BytesWritten,
    nil
  );

  if Success then
    WriteLn('Message envoyé : ', Message);

  // Lecture de la réponse
  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(
    hPipe,
    Buffer,
    SizeOf(Buffer),
    BytesRead,
    nil
  );

  if Success then
    WriteLn('Réponse reçue : ', Buffer);

  // Fermeture
  CloseHandle(hPipe);

  WriteLn('Connexion fermée');
  WriteLn('Appuyez sur Entrée pour quitter...');
  ReadLn;
end.
```

### Test des programmes

1. Compilez les deux programmes
2. Lancez d'abord le **serveur**
3. Lancez ensuite le **client**
4. Observez l'échange de messages

## Serveur multi-clients

Pour accepter plusieurs clients simultanément, créons plusieurs instances du pipe :

```pascal
program MultiClientServer;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils, Classes;

const
  PIPE_NAME = '\\.\pipe\MyMultiPipe';
  BUFFER_SIZE = 4096;
  MAX_CLIENTS = 5;

type
  TClientThread = class(TThread)
  private
    FPipeHandle: THandle;
    FClientID: Integer;
  protected
    procedure Execute; override;
  public
    constructor Create(APipeHandle: THandle; AClientID: Integer);
  end;

constructor TClientThread.Create(APipeHandle: THandle; AClientID: Integer);
begin
  inherited Create(False);
  FreeOnTerminate := True;
  FPipeHandle := APipeHandle;
  FClientID := AClientID;
end;

procedure TClientThread.Execute;
var
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Success: Boolean;
  Response: string;
begin
  WriteLn('[Client ', FClientID, '] Thread démarré');

  try
    // Lecture du message
    FillChar(Buffer, SizeOf(Buffer), 0);
    Success := ReadFile(FPipeHandle, Buffer, SizeOf(Buffer), BytesRead, nil);

    if Success then
    begin
      WriteLn('[Client ', FClientID, '] Message reçu : ', Buffer);

      // Réponse
      Response := Format('Réponse du serveur pour le client %d', [FClientID]);
      WriteFile(FPipeHandle, PChar(Response), Length(Response), BytesWritten, nil);

      WriteLn('[Client ', FClientID, '] Réponse envoyée');
    end;

  finally
    // Déconnexion et fermeture
    FlushFileBuffers(FPipeHandle);
    DisconnectNamedPipe(FPipeHandle);
    CloseHandle(FPipeHandle);
    WriteLn('[Client ', FClientID, '] Déconnecté');
  end;
end;

var
  ClientCount: Integer;
  hPipe: THandle;
  Success: Boolean;

begin
  WriteLn('=== Serveur Multi-Clients ===');
  WriteLn('En attente de connexions...');
  WriteLn('Appuyez sur Ctrl+C pour arrêter');
  WriteLn;

  ClientCount := 0;

  while True do
  begin
    // Création d'une nouvelle instance du pipe
    hPipe := CreateNamedPipe(
      PChar(PIPE_NAME),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES,  // Instances illimitées
      BUFFER_SIZE,
      BUFFER_SIZE,
      0,
      nil
    );

    if hPipe = INVALID_HANDLE_VALUE then
    begin
      WriteLn('Erreur création pipe');
      Break;
    end;

    // Attente d'une connexion
    Success := ConnectNamedPipe(hPipe, nil);

    if Success or (GetLastError = ERROR_PIPE_CONNECTED) then
    begin
      Inc(ClientCount);
      WriteLn('Nouveau client connecté (ID: ', ClientCount, ')');

      // Création d'un thread pour gérer ce client
      TClientThread.Create(hPipe, ClientCount);
    end
    else
    begin
      CloseHandle(hPipe);
    end;
  end;
end.
```

## Communication bidirectionnelle

Exemple avec échange de plusieurs messages :

```pascal
program BidirectionalPipe;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils;

const
  PIPE_NAME = '\\.\pipe\ChatPipe';
  BUFFER_SIZE = 4096;

procedure RunServer;
var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Message: string;
  Continue: Boolean;
begin
  WriteLn('=== Mode Serveur ===');

  hPipe := CreateNamedPipe(
    PChar(PIPE_NAME),
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
    1, BUFFER_SIZE, BUFFER_SIZE, 0, nil
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur création pipe');
    Exit;
  end;

  WriteLn('En attente de connexion...');
  ConnectNamedPipe(hPipe, nil);
  WriteLn('Client connecté !');
  WriteLn('Tapez vos messages (QUIT pour quitter)');
  WriteLn;

  Continue := True;

  while Continue do
  begin
    // Lecture du message client
    FillChar(Buffer, SizeOf(Buffer), 0);
    if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
    begin
      WriteLn('[Client] ', Buffer);

      if UpperCase(string(Buffer)) = 'QUIT' then
      begin
        Continue := False;
        Continue;
      end;
    end;

    // Envoi de notre message
    Write('[Vous] ');
    ReadLn(Message);

    WriteFile(hPipe, PChar(Message), Length(Message), BytesWritten, nil);

    if UpperCase(Message) = 'QUIT' then
      Continue := False;
  end;

  DisconnectNamedPipe(hPipe);
  CloseHandle(hPipe);
  WriteLn('Connexion fermée');
end;

procedure RunClient;
var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Message: string;
  Continue: Boolean;
begin
  WriteLn('=== Mode Client ===');

  if not WaitNamedPipe(PChar(PIPE_NAME), 5000) then
  begin
    WriteLn('Pipe non disponible');
    Exit;
  end;

  hPipe := CreateFile(
    PChar(PIPE_NAME),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur connexion');
    Exit;
  end;

  WriteLn('Connecté au serveur !');
  WriteLn('Tapez vos messages (QUIT pour quitter)');
  WriteLn;

  Continue := True;

  while Continue do
  begin
    // Envoi de notre message
    Write('[Vous] ');
    ReadLn(Message);

    WriteFile(hPipe, PChar(Message), Length(Message), BytesWritten, nil);

    if UpperCase(Message) = 'QUIT' then
    begin
      Continue := False;
      Continue;
    end;

    // Lecture de la réponse
    FillChar(Buffer, SizeOf(Buffer), 0);
    if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
    begin
      WriteLn('[Serveur] ', Buffer);

      if UpperCase(string(Buffer)) = 'QUIT' then
        Continue := False;
    end;
  end;

  CloseHandle(hPipe);
  WriteLn('Connexion fermée');
end;

var
  Choice: string;

begin
  WriteLn('=== Application Chat via Named Pipe ===');
  WriteLn('1. Serveur');
  WriteLn('2. Client');
  Write('Votre choix : ');
  ReadLn(Choice);
  WriteLn;

  if Choice = '1' then
    RunServer
  else if Choice = '2' then
    RunClient
  else
    WriteLn('Choix invalide');

  WriteLn;
  WriteLn('Appuyez sur Entrée pour quitter...');
  ReadLn;
end.
```

## Gestion des erreurs

### Codes d'erreur courants

```pascal
procedure CheckPipeError;
var
  ErrorCode: DWORD;
begin
  ErrorCode := GetLastError;

  case ErrorCode of
    ERROR_PIPE_BUSY:
      WriteLn('Le pipe est occupé, réessayez plus tard');

    ERROR_PIPE_NOT_CONNECTED:
      WriteLn('Le pipe n''est pas connecté');

    ERROR_BROKEN_PIPE:
      WriteLn('Le pipe est cassé (connexion fermée)');

    ERROR_NO_DATA:
      WriteLn('Le pipe est en cours de fermeture');

    ERROR_PIPE_LISTENING:
      WriteLn('Le pipe est en écoute (pas encore de client)');

    ERROR_FILE_NOT_FOUND:
      WriteLn('Le pipe n''existe pas');

    ERROR_ACCESS_DENIED:
      WriteLn('Accès refusé (permissions insuffisantes)');
  else
    WriteLn('Erreur : ', ErrorCode);
  end;
end;
```

### Gestion robuste

```pascal
function SafeReadFromPipe(hPipe: THandle; out Data: string): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Success: Boolean;
begin
  Result := False;
  Data := '';

  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil);

  if Success then
  begin
    if BytesRead > 0 then
    begin
      Data := Buffer;
      Result := True;
    end;
  end
  else
  begin
    case GetLastError of
      ERROR_BROKEN_PIPE:
        WriteLn('Le client s''est déconnecté');
      ERROR_NO_DATA:
        WriteLn('Pipe en cours de fermeture');
    else
      CheckPipeError;
    end;
  end;
end;

function SafeWriteToPipe(hPipe: THandle; const Data: string): Boolean;
var
  BytesWritten: DWORD;
begin
  Result := WriteFile(
    hPipe,
    PChar(Data),
    Length(Data),
    BytesWritten,
    nil
  );

  if not Result then
    CheckPipeError;
end;
```

## Timeouts

### Configuration du timeout

```pascal
procedure SetPipeTimeout(hPipe: THandle; TimeoutMS: DWORD);
var
  Mode: DWORD;
begin
  Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;

  SetNamedPipeHandleState(
    hPipe,
    @Mode,
    nil,        // Pas de changement de buffer
    @TimeoutMS  // Timeout en millisecondes
  );
end;

// Utilisation
SetPipeTimeout(hPipe, 5000); // 5 secondes
```

### Lecture avec timeout

```pascal
function ReadWithTimeout(hPipe: THandle; TimeoutMS: DWORD; out Data: string): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Mode: DWORD;
begin
  Result := False;
  Data := '';

  // Configuration du timeout
  Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;
  SetNamedPipeHandleState(hPipe, @Mode, nil, @TimeoutMS);

  // Lecture
  FillChar(Buffer, SizeOf(Buffer), 0);
  if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
  begin
    Data := Buffer;
    Result := True;
  end
  else
  begin
    if GetLastError = ERROR_TIMEOUT then
      WriteLn('Timeout lors de la lecture')
    else
      CheckPipeError;
  end;
end;
```

## Sécurité et permissions

### Création avec permissions personnalisées

```pascal
uses
  Windows, SysUtils, AccCtrl, AclAPI;

function CreateSecurePipe(const PipeName: string): THandle;
var
  SA: TSecurityAttributes;
  SD: PSECURITY_DESCRIPTOR;
  EA: EXPLICIT_ACCESS;
  ACL: PACL;
begin
  // Allocation du descripteur de sécurité
  SD := nil;
  ACL := nil;

  try
    // Initialisation
    InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION);

    // Création d'une ACL (Access Control List)
    // Ici : accès complet pour l'utilisateur courant
    FillChar(EA, SizeOf(EA), 0);
    EA.grfAccessPermissions := GENERIC_ALL;
    EA.grfAccessMode := SET_ACCESS;
    EA.grfInheritance := NO_INHERITANCE;
    EA.Trustee.TrusteeForm := TRUSTEE_IS_NAME;
    EA.Trustee.ptstrName := PChar('CURRENT_USER');

    // Définition des attributs de sécurité
    SA.nLength := SizeOf(TSecurityAttributes);
    SA.lpSecurityDescriptor := SD;
    SA.bInheritHandle := False;

    // Création du pipe avec sécurité
    Result := CreateNamedPipe(
      PChar(PipeName),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES,
      4096, 4096, 0,
      @SA  // Attributs de sécurité personnalisés
    );

  finally
    if ACL <> nil then
      LocalFree(HLOCAL(ACL));
  end;
end;
```

## Named Pipes réseau

### Connexion à un pipe distant

```pascal
const
  // Format : \\NomServeur\pipe\NomPipe
  REMOTE_PIPE = '\\SERVEUR1\pipe\MyPipe';

procedure ConnectToRemotePipe;
var
  hPipe: THandle;
begin
  WriteLn('Connexion au pipe distant : ', REMOTE_PIPE);

  if not WaitNamedPipe(PChar(REMOTE_PIPE), 10000) then
  begin
    WriteLn('Timeout ou pipe indisponible');
    Exit;
  end;

  hPipe := CreateFile(
    PChar(REMOTE_PIPE),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if hPipe <> INVALID_HANDLE_VALUE then
  begin
    WriteLn('Connecté au serveur distant !');
    // Utiliser le pipe...
    CloseHandle(hPipe);
  end
  else
    WriteLn('Erreur connexion : ', GetLastError);
end;
```

**Note :** Pour les pipes réseau, assurez-vous que :
1. Le partage de fichiers est activé
2. Le pare-feu autorise les connexions
3. Vous avez les permissions nécessaires

## Performance et optimisations

### Buffers optimisés

```pascal
const
  // Tailles recommandées selon l'usage
  SMALL_BUFFER = 1024;      // Messages courts
  MEDIUM_BUFFER = 4096;     // Usage général
  LARGE_BUFFER = 65536;     // Gros transferts

procedure CreateOptimizedPipe(BufferSize: DWORD);
var
  hPipe: THandle;
begin
  hPipe := CreateNamedPipe(
    '\\.\pipe\OptimizedPipe',
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
    PIPE_UNLIMITED_INSTANCES,
    BufferSize,  // Buffer sortie
    BufferSize,  // Buffer entrée
    0,
    nil
  );

  // Utiliser le pipe...
end;
```

### Mode non-bloquant pour performance

```pascal
procedure NonBlockingRead(hPipe: THandle);
var
  Buffer: array[0..4095] of Char;
  BytesRead, TotalBytes, BytesLeft: DWORD;
  Success: Boolean;
begin
  // Vérifier si des données sont disponibles
  Success := PeekNamedPipe(
    hPipe,
    nil,           // Pas de lecture
    0,
    nil,
    @TotalBytes,   // Octets disponibles
    @BytesLeft
  );

  if Success and (TotalBytes > 0) then
  begin
    // Des données sont disponibles, on peut lire
    ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil);
    WriteLn('Lu : ', BytesRead, ' octets');
  end
  else
    WriteLn('Pas de données disponibles');
end;
```

## Debugging et diagnostic

### Affichage des informations du pipe

```pascal
procedure ShowPipeInfo(hPipe: THandle);
var
  Flags, OutBufferSize, InBufferSize, MaxInstances: DWORD;
begin
  if GetNamedPipeInfo(hPipe, @Flags, @OutBufferSize, @InBufferSize, @MaxInstances) then
  begin
    WriteLn('=== Informations du Pipe ===');

    Write('Type : ');
    if (Flags and PIPE_TYPE_MESSAGE) <> 0 then
      WriteLn('Message')
    else
      WriteLn('Byte Stream');

    Write('Direction : ');
    if (Flags and PIPE_SERVER_END) <> 0 then
      WriteLn('Serveur')
    else
      WriteLn('Client');

    WriteLn('Buffer sortie : ', OutBufferSize, ' octets');
    WriteLn('Buffer entrée : ', InBufferSize, ' octets');
    WriteLn('Instances max : ', MaxInstances);
  end;
end;
```

### Liste des pipes disponibles

```pascal
uses
  Windows, SysUtils;

procedure ListAllPipes;
var
  FindData: TWin32FindData;
  hFind: THandle;
begin
  WriteLn('=== Pipes nommés disponibles ===');

  hFind := FindFirstFile('\\.\pipe\*', FindData);

  if hFind <> INVALID_HANDLE_VALUE then
  begin
    repeat
      WriteLn('  ', FindData.cFileName);
    until not FindNextFile(hFind, FindData);

    Windows.FindClose(hFind);
  end
  else
    WriteLn('Aucun pipe trouvé ou erreur');
end;
```

## Bonnes pratiques

### Checklist pour Named Pipes

✅ **Création**
- Choisir le bon mode (message vs byte stream)
- Définir des buffers adaptés à l'usage (4096 octets minimum)
- Utiliser `PIPE_UNLIMITED_INSTANCES` pour multi-clients
- Configurer un timeout raisonnable

✅ **Connexion**
- Toujours utiliser `WaitNamedPipe` côté client avant `CreateFile`
- Gérer le cas où le pipe n'existe pas encore
- Implémenter des mécanismes de retry avec backoff

✅ **Communication**
- Vérifier le retour de toutes les fonctions (`ReadFile`, `WriteFile`)
- Utiliser `FlushFileBuffers` avant de fermer pour assurer l'envoi
- Implémenter des timeouts pour éviter les blocages

✅ **Fermeture**
- Toujours appeler `DisconnectNamedPipe` (côté serveur)
- Toujours appeler `CloseHandle` pour libérer les ressources
- Gérer proprement les déconnexions brutales

✅ **Erreurs**
- Vérifier `GetLastError` en cas d'échec
- Gérer `ERROR_BROKEN_PIPE` (déconnexion)
- Gérer `ERROR_PIPE_BUSY` (trop de clients)

✅ **Sécurité**
- Définir des permissions appropriées
- Ne pas exécuter avec des privilèges élevés sans raison
- Valider toutes les données reçues

### Exemple de code robuste

```pascal
unit RobustNamedPipe;

{$mode objfpc}{$H+}

interface

uses
  Windows, SysUtils;

type
  TNamedPipeServer = class
  private
    FPipeName: string;
    FPipeHandle: THandle;
    FBufferSize: DWORD;
    FMaxClients: DWORD;
    FConnected: Boolean;
    function GetLastErrorMessage: string;
  public
    constructor Create(const APipeName: string; ABufferSize: DWORD = 4096;
                      AMaxClients: DWORD = PIPE_UNLIMITED_INSTANCES);
    destructor Destroy; override;
    function Start: Boolean;
    function WaitForClient(TimeoutMS: DWORD = INFINITE): Boolean;
    function ReadMessage(out Message: string; TimeoutMS: DWORD = INFINITE): Boolean;
    function WriteMessage(const Message: string): Boolean;
    procedure Disconnect;
    property Connected: Boolean read FConnected;
  end;

  TNamedPipeClient = class
  private
    FPipeName: string;
    FPipeHandle: THandle;
    FConnected: Boolean;
    function GetLastErrorMessage: string;
  public
    constructor Create(const APipeName: string);
    destructor Destroy; override;
    function Connect(TimeoutMS: DWORD = 5000): Boolean;
    function ReadMessage(out Message: string; TimeoutMS: DWORD = INFINITE): Boolean;
    function WriteMessage(const Message: string): Boolean;
    procedure Disconnect;
    property Connected: Boolean read FConnected;
  end;

implementation

{ TNamedPipeServer }

constructor TNamedPipeServer.Create(const APipeName: string; ABufferSize: DWORD;
                                    AMaxClients: DWORD);
begin
  FPipeName := APipeName;
  FBufferSize := ABufferSize;
  FMaxClients := AMaxClients;
  FPipeHandle := INVALID_HANDLE_VALUE;
  FConnected := False;
end;

destructor TNamedPipeServer.Destroy;
begin
  Disconnect;
  inherited;
end;

function TNamedPipeServer.GetLastErrorMessage: string;
var
  ErrorCode: DWORD;
begin
  ErrorCode := GetLastError;
  Result := Format('Erreur %d: %s', [ErrorCode, SysErrorMessage(ErrorCode)]);
end;

function TNamedPipeServer.Start: Boolean;
begin
  Result := False;

  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    WriteLn('Le pipe est déjà créé');
    Exit;
  end;

  FPipeHandle := CreateNamedPipe(
    PChar(FPipeName),
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
    FMaxClients,
    FBufferSize,
    FBufferSize,
    0,
    nil
  );

  if FPipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur création pipe: ', GetLastErrorMessage);
    Exit;
  end;

  Result := True;
end;

function TNamedPipeServer.WaitForClient(TimeoutMS: DWORD): Boolean;
var
  Success: Boolean;
  Overlapped: TOverlapped;
  WaitResult: DWORD;
begin
  Result := False;

  if FPipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Le pipe n''est pas créé');
    Exit;
  end;

  if TimeoutMS = INFINITE then
  begin
    // Mode bloquant simple
    Success := ConnectNamedPipe(FPipeHandle, nil);

    if Success or (GetLastError = ERROR_PIPE_CONNECTED) then
    begin
      FConnected := True;
      Result := True;
    end
    else
      WriteLn('Erreur connexion: ', GetLastErrorMessage);
  end
  else
  begin
    // Mode avec timeout (nécessite overlapped I/O)
    FillChar(Overlapped, SizeOf(Overlapped), 0);
    Overlapped.hEvent := CreateEvent(nil, True, False, nil);

    try
      Success := ConnectNamedPipe(FPipeHandle, @Overlapped);

      if not Success then
      begin
        case GetLastError of
          ERROR_IO_PENDING:
            begin
              WaitResult := WaitForSingleObject(Overlapped.hEvent, TimeoutMS);
              if WaitResult = WAIT_OBJECT_0 then
              begin
                FConnected := True;
                Result := True;
              end
              else
                WriteLn('Timeout en attente de client');
            end;
          ERROR_PIPE_CONNECTED:
            begin
              FConnected := True;
              Result := True;
            end;
        else
          WriteLn('Erreur connexion: ', GetLastErrorMessage);
        end;
      end
      else
      begin
        FConnected := True;
        Result := True;
      end;

    finally
      CloseHandle(Overlapped.hEvent);
    end;
  end;
end;

function TNamedPipeServer.ReadMessage(out Message: string; TimeoutMS: DWORD): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Success: Boolean;
  Mode: DWORD;
begin
  Result := False;
  Message := '';

  if not FConnected then
  begin
    WriteLn('Aucun client connecté');
    Exit;
  end;

  // Configuration du timeout si nécessaire
  if TimeoutMS <> INFINITE then
  begin
    Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;
    SetNamedPipeHandleState(FPipeHandle, @Mode, nil, @TimeoutMS);
  end;

  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(FPipeHandle, Buffer, SizeOf(Buffer), BytesRead, nil);

  if Success then
  begin
    if BytesRead > 0 then
    begin
      Message := Buffer;
      Result := True;
    end;
  end
  else
  begin
    case GetLastError of
      ERROR_BROKEN_PIPE:
        begin
          WriteLn('Le client s''est déconnecté');
          FConnected := False;
        end;
      ERROR_NO_DATA:
        begin
          WriteLn('Pipe en cours de fermeture');
          FConnected := False;
        end;
    else
      WriteLn('Erreur lecture: ', GetLastErrorMessage);
    end;
  end;
end;

function TNamedPipeServer.WriteMessage(const Message: string): Boolean;
var
  BytesWritten: DWORD;
begin
  Result := False;

  if not FConnected then
  begin
    WriteLn('Aucun client connecté');
    Exit;
  end;

  Result := WriteFile(
    FPipeHandle,
    PChar(Message),
    Length(Message),
    BytesWritten,
    nil
  );

  if not Result then
    WriteLn('Erreur écriture: ', GetLastErrorMessage)
  else
    FlushFileBuffers(FPipeHandle); // S'assurer que les données sont envoyées
end;

procedure TNamedPipeServer.Disconnect;
begin
  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    if FConnected then
    begin
      FlushFileBuffers(FPipeHandle);
      DisconnectNamedPipe(FPipeHandle);
      FConnected := False;
    end;

    CloseHandle(FPipeHandle);
    FPipeHandle := INVALID_HANDLE_VALUE;
  end;
end;

{ TNamedPipeClient }

constructor TNamedPipeClient.Create(const APipeName: string);
begin
  FPipeName := APipeName;
  FPipeHandle := INVALID_HANDLE_VALUE;
  FConnected := False;
end;

destructor TNamedPipeClient.Destroy;
begin
  Disconnect;
  inherited;
end;

function TNamedPipeClient.GetLastErrorMessage: string;
var
  ErrorCode: DWORD;
begin
  ErrorCode := GetLastError;
  Result := Format('Erreur %d: %s', [ErrorCode, SysErrorMessage(ErrorCode)]);
end;

function TNamedPipeClient.Connect(TimeoutMS: DWORD): Boolean;
begin
  Result := False;

  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    WriteLn('Déjà connecté');
    Exit(True);
  end;

  // Attente que le pipe soit disponible
  if not WaitNamedPipe(PChar(FPipeName), TimeoutMS) then
  begin
    WriteLn('Le pipe n''est pas disponible: ', GetLastErrorMessage);
    Exit;
  end;

  // Connexion au pipe
  FPipeHandle := CreateFile(
    PChar(FPipeName),
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if FPipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur connexion: ', GetLastErrorMessage);
    Exit;
  end;

  // Configuration en mode message
  var Mode: DWORD := PIPE_READMODE_MESSAGE or PIPE_WAIT;
  if not SetNamedPipeHandleState(FPipeHandle, @Mode, nil, nil) then
    WriteLn('Avertissement: Impossible de configurer le mode');

  FConnected := True;
  Result := True;
end;

function TNamedPipeClient.ReadMessage(out Message: string; TimeoutMS: DWORD): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Success: Boolean;
  Mode: DWORD;
begin
  Result := False;
  Message := '';

  if not FConnected then
  begin
    WriteLn('Non connecté');
    Exit;
  end;

  // Configuration du timeout
  if TimeoutMS <> INFINITE then
  begin
    Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;
    SetNamedPipeHandleState(FPipeHandle, @Mode, nil, @TimeoutMS);
  end;

  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(FPipeHandle, Buffer, SizeOf(Buffer), BytesRead, nil);

  if Success then
  begin
    if BytesRead > 0 then
    begin
      Message := Buffer;
      Result := True;
    end;
  end
  else
    WriteLn('Erreur lecture: ', GetLastErrorMessage);
end;

function TNamedPipeClient.WriteMessage(const Message: string): Boolean;
var
  BytesWritten: DWORD;
begin
  Result := False;

  if not FConnected then
  begin
    WriteLn('Non connecté');
    Exit;
  end;

  Result := WriteFile(
    FPipeHandle,
    PChar(Message),
    Length(Message),
    BytesWritten,
    nil
  );

  if not Result then
    WriteLn('Erreur écriture: ', GetLastErrorMessage)
  else
    FlushFileBuffers(FPipeHandle);
end;

procedure TNamedPipeClient.Disconnect;
begin
  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    if FConnected then
      FlushFileBuffers(FPipeHandle);

    CloseHandle(FPipeHandle);
    FPipeHandle := INVALID_HANDLE_VALUE;
    FConnected := False;
  end;
end;

end.
```

### Utilisation de la classe robuste

```pascal
program TestRobustPipe;

{$mode objfpc}{$H+}

uses
  SysUtils, RobustNamedPipe;

procedure TestServer;
var
  Server: TNamedPipeServer;
  Message: string;
begin
  WriteLn('=== Test Serveur ===');

  Server := TNamedPipeServer.Create('\\.\pipe\TestPipe');
  try
    if Server.Start then
    begin
      WriteLn('Serveur démarré, en attente de client...');

      if Server.WaitForClient(30000) then // 30 secondes max
      begin
        WriteLn('Client connecté !');

        // Lecture d'un message
        if Server.ReadMessage(Message, 5000) then
          WriteLn('Message reçu: ', Message);

        // Envoi d'une réponse
        Server.WriteMessage('Bonjour du serveur !');

        Sleep(1000);
        Server.Disconnect;
      end
      else
        WriteLn('Timeout: aucun client connecté');
    end;

  finally
    Server.Free;
  end;
end;

procedure TestClient;
var
  Client: TNamedPipeClient;
  Message: string;
begin
  WriteLn('=== Test Client ===');

  Client := TNamedPipeClient.Create('\\.\pipe\TestPipe');
  try
    if Client.Connect(5000) then
    begin
      WriteLn('Connecté au serveur !');

      // Envoi d'un message
      Client.WriteMessage('Bonjour du client !');

      // Lecture de la réponse
      if Client.ReadMessage(Message, 5000) then
        WriteLn('Réponse reçue: ', Message);

      Client.Disconnect;
    end
    else
      WriteLn('Impossible de se connecter');

  finally
    Client.Free;
  end;
end;

var
  Choice: string;

begin
  WriteLn('1. Serveur');
  WriteLn('2. Client');
  Write('Choix: ');
  ReadLn(Choice);

  if Choice = '1' then
    TestServer
  else if Choice = '2' then
    TestClient;

  WriteLn;
  WriteLn('Appuyez sur Entrée...');
  ReadLn;
end.
```

## Cas d'usage avancés

### 1. Service de monitoring

Un service qui collecte des métriques des applications :

```pascal
// Service (Serveur)
program MonitoringService;

type
  TMetric = record
    AppName: string;
    CPU: Double;
    Memory: Int64;
    Timestamp: TDateTime;
  end;

procedure HandleClient(hPipe: THandle);
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Metric: TMetric;
begin
  // Lecture des métriques
  if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
  begin
    // Parser les données JSON ou binaires
    WriteLn('Métriques reçues de: ', Metric.AppName);
    WriteLn('  CPU: ', Metric.CPU:0:2, '%');
    WriteLn('  Memory: ', Metric.Memory div (1024*1024), ' MB');

    // Stocker dans une base de données...
  end;
end;
```

### 2. Interface de contrôle d'application

Contrôler une application via un pipe :

```pascal
// Application contrôlable
program ControllableApp;

type
  TCommand = (cmdStart, cmdStop, cmdPause, cmdStatus, cmdQuit);

procedure ProcessCommand(const Cmd: string);
begin
  if Cmd = 'START' then
    StartProcess
  else if Cmd = 'STOP' then
    StopProcess
  else if Cmd = 'PAUSE' then
    PauseProcess
  else if Cmd = 'STATUS' then
    SendStatus
  else if Cmd = 'QUIT' then
    Application.Terminate;
end;

// Client de contrôle
program ControlClient;

var
  Client: TNamedPipeClient;

begin
  Client := TNamedPipeClient.Create('\\.\pipe\AppControl');
  try
    if Client.Connect then
    begin
      Client.WriteMessage('STATUS');

      var Status: string;
      if Client.ReadMessage(Status) then
        WriteLn('Status: ', Status);
    end;
  finally
    Client.Free;
  end;
end;
```

### 3. Logger centralisé

Centraliser les logs de plusieurs applications :

```pascal
program CentralLogger;

uses
  Classes, SysUtils;

type
  TLogEntry = record
    AppName: string;
    Level: string;    // INFO, WARNING, ERROR
    Message: string;
    Timestamp: TDateTime;
  end;

procedure LogToFile(const Entry: TLogEntry);
var
  F: TextFile;
begin
  AssignFile(F, 'central.log');
  try
    if FileExists('central.log') then
      Append(F)
    else
      Rewrite(F);

    WriteLn(F, Format('[%s] [%s] [%s] %s',
      [FormatDateTime('yyyy-mm-dd hh:nn:ss', Entry.Timestamp),
       Entry.AppName,
       Entry.Level,
       Entry.Message]));

  finally
    CloseFile(F);
  end;
end;

procedure HandleLogClient(hPipe: THandle);
var
  Message: string;
  Entry: TLogEntry;
begin
  // Lecture du message de log
  if ReadMessage(hPipe, Message) then
  begin
    // Parser le message (JSON, XML, ou format custom)
    ParseLogEntry(Message, Entry);
    LogToFile(Entry);
  end;
end;
```

## Débogage avancé

### Outil de monitoring de pipes

```pascal
program PipeMonitor;

uses
  Windows, SysUtils;

type
  TPipeInfo = record
    Name: string;
    Instances: DWORD;
    InBufferSize: DWORD;
    OutBufferSize: DWORD;
  end;

procedure MonitorPipe(const PipeName: string);
var
  hPipe: THandle;
  Flags, OutBufSize, InBufSize, MaxInstances: DWORD;
  ClientCount: DWORD;
begin
  WriteLn('=== Monitoring: ', PipeName, ' ===');

  // Tentative de connexion pour obtenir des infos
  hPipe := CreateFile(
    PChar(PipeName),
    GENERIC_READ,
    FILE_SHARE_READ or FILE_SHARE_WRITE,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if hPipe <> INVALID_HANDLE_VALUE then
  begin
    if GetNamedPipeInfo(hPipe, @Flags, @OutBufSize, @InBufSize, @MaxInstances) then
    begin
      WriteLn('Type: ', IfThen((Flags and PIPE_TYPE_MESSAGE) <> 0, 'Message', 'Byte'));
      WriteLn('Buffer sortie: ', OutBufSize, ' octets');
      WriteLn('Buffer entrée: ', InBufSize, ' octets');
      WriteLn('Instances max: ', MaxInstances);
    end;

    // Obtenir le nombre de clients
    if GetNamedPipeHandleState(hPipe, nil, @ClientCount, nil, nil, nil, 0) then
      WriteLn('Clients connectés: ', ClientCount);

    CloseHandle(hPipe);
  end
  else
    WriteLn('Impossible d''accéder au pipe');
end;

procedure ListAndMonitorAllPipes;
var
  FindData: TWin32FindData;
  hFind: THandle;
  PipeName: string;
begin
  WriteLn('=== Liste et monitoring de tous les pipes ===');
  WriteLn;

  hFind := FindFirstFile('\\.\pipe\*', FindData);

  if hFind <> INVALID_HANDLE_VALUE then
  begin
    repeat
      PipeName := '\\.\pipe\' + string(FindData.cFileName);
      MonitorPipe(PipeName);
      WriteLn;
    until not FindNextFile(hFind, FindData);

    Windows.FindClose(hFind);
  end;
end;

begin
  ListAndMonitorAllPipes;

  WriteLn('Appuyez sur Entrée pour quitter...');
  ReadLn;
end.
```

## Performance et benchmarks

### Test de performance

```pascal
program PipeBenchmark;

uses
  Windows, SysUtils, DateUtils;

procedure BenchmarkPipePerformance;
const
  MESSAGE_COUNT = 10000;
  MESSAGE_SIZE = 1024;
var
  Server: TNamedPipeServer;
  Client: TNamedPipeClient;
  i: Integer;
  StartTime, EndTime: TDateTime;
  Duration: Double;
  Message: string;
  Throughput: Double;
begin
  WriteLn('=== Benchmark Named Pipe ===');
  WriteLn('Messages: ', MESSAGE_COUNT);
  WriteLn('Taille message: ', MESSAGE_SIZE, ' octets');
  WriteLn;

  SetLength(Message, MESSAGE_SIZE);
  FillChar(Message[1], MESSAGE_SIZE, 'A');

  Server := TNamedPipeServer.Create('\\.\pipe\BenchPipe');
  Client := TNamedPipeClient.Create('\\.\pipe\BenchPipe');

  try
    // Démarrage du serveur dans un thread...
    // (Code simplifié pour l'exemple)

    if Server.Start and Server.WaitForClient then
    begin
      if Client.Connect then
      begin
        WriteLn('Démarrage du test...');
        StartTime := Now;

        for i := 1 to MESSAGE_COUNT do
        begin
          Client.WriteMessage(Message);

          var Received: string;
          Server.ReadMessage(Received);

          if (i mod 1000) = 0 then
            Write('.');
        end;

        EndTime := Now;
        Duration := MilliSecondsBetween(EndTime, StartTime) / 1000;

        WriteLn;
        WriteLn('Durée: ', Duration:0:3, ' secondes');
        WriteLn('Messages/sec: ', (MESSAGE_COUNT / Duration):0:0);

        Throughput := (MESSAGE_COUNT * MESSAGE_SIZE) / (Duration * 1024 * 1024);
        WriteLn('Débit: ', Throughput:0:2, ' MB/s');
      end;
    end;

  finally
    Client.Free;
    Server.Free;
  end;
end;

begin
  BenchmarkPipePerformance;

  WriteLn;
  WriteLn('Appuyez sur Entrée...');
  ReadLn;
end.
```

### Résultats typiques

Sur une machine Windows moderne :

```
Messages/sec: 50,000 - 100,000
Débit: 50 - 200 MB/s (selon taille des messages)
Latence: < 1 ms

Comparaison :
- Named Pipes (local): ⚡⚡⚡⚡ (très rapide)
- TCP Sockets (local): ⚡⚡⚡ (rapide)
- TCP Sockets (réseau): ⚡⚡ (dépend du réseau)
```

## Résumé

### Points clés à retenir

✅ **Named Pipes Windows** sont excellents pour l'IPC locale
✅ **Support réseau** via `\\serveur\pipe\nom`
✅ **Deux modes** : Message (recommandé) et Byte Stream
✅ **Sécurité intégrée** avec les ACL Windows
✅ **Multi-clients** avec `PIPE_UNLIMITED_INSTANCES`
✅ **Performance excellente** pour communication locale

### Quand utiliser les Named Pipes ?

**✅ Utilisez Named Pipes pour :**
- Communication locale entre processus Windows
- Architecture client-serveur locale
- Services Windows et leurs clients
- Applications nécessitant sécurité Windows
- Communication bidirectionnelle

**❌ Préférez d'autres solutions pour :**
- Communication cross-platform (utilisez TCP/UDP)
- Communication sur Internet (utilisez HTTP/REST)
- Très haute performance locale (utilisez Shared Memory)
- Communication Linux (utilisez Unix Domain Sockets)

### Comparaison rapide

| Besoin | Solution |
|--------|----------|
| IPC locale Windows | ✅ Named Pipes |
| IPC cross-platform | TCP Sockets, HTTP |
| Maximum performance | Shared Memory |
| Communication réseau | TCP/UDP Sockets |
| APIs web | HTTP/REST |

## Ressources complémentaires

### Documentation officielle Microsoft

- **Named Pipes** : https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes
- **CreateNamedPipe** : https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
- **IPC Overview** : https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications

### Outils utiles

- **Process Explorer** (Sysinternals) : Voir les handles de pipes
- **PipeList** (Sysinternals) : Lister tous les pipes
- **Handle** (Sysinternals) : Trouver qui utilise un pipe

### Exemples de Named Pipes dans Windows

De nombreux composants Windows utilisent des Named Pipes :

```
\\.\pipe\InitShutdown          → Shutdown system
\\.\pipe\lsass                 → Local Security Authority
\\.\pipe\ntsvcs                → Windows Services
\\.\pipe\sql\query             → SQL Server
\\.\pipe\MSSQL$INSTANCE\sql\query → SQL Server instance
```

Vous pouvez les voir avec :
```cmd
dir \\.\pipe\
```

---

Vous maîtrisez maintenant les Named Pipes Windows ! Passons aux Unix Domain Sockets pour Linux dans la section suivante.

⏭️ [Unix Domain Sockets (Linux)](/10-programmation-reseau-avancee/08.2-unix-domain-sockets-linux.md)
