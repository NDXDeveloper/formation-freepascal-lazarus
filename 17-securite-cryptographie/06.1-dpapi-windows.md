üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.6.1 DPAPI Windows

## Introduction

DPAPI (Data Protection API) est une API de chiffrement int√©gr√©e √† Windows qui permet de prot√©ger des donn√©es sensibles en utilisant automatiquement les informations d'identification de l'utilisateur Windows. C'est l'une des m√©thodes les plus s√ªres et les plus simples pour stocker des secrets sur Windows.

## Qu'est-ce que DPAPI ?

### D√©finition

DPAPI est une API Windows qui fournit des fonctions de chiffrement et d√©chiffrement de donn√©es sans que l'application ait besoin de g√©rer explicitement les cl√©s de chiffrement. Windows g√®re automatiquement les cl√©s en utilisant :

- Les informations d'identification de l'utilisateur Windows
- Le Security Support Provider (SSP)
- Le Master Key du syst√®me

### Avantages de DPAPI

**‚úÖ S√©curit√©** :
- Chiffrement automatique avec les cl√©s de l'utilisateur
- Protection mat√©rielle possible (TPM - Trusted Platform Module)
- Cl√©s inaccessibles m√™me √† l'administrateur syst√®me
- R√©sistant aux attaques par dump m√©moire

**‚úÖ Simplicit√©** :
- Pas besoin de g√©rer les cl√©s manuellement
- API simple avec deux fonctions principales
- Int√©gr√© nativement √† Windows

**‚úÖ Port√©e** :
- Peut √™tre limit√© √† l'utilisateur actuel
- Peut √™tre partag√© entre utilisateurs (machine)
- Compatible avec les comptes de service

### Limitations de DPAPI

**‚ö†Ô∏è Sp√©cifique √† Windows** :
- Ne fonctionne pas sur Linux/macOS
- N√©cessite une abstraction pour le multi-plateforme

**‚ö†Ô∏è Li√© √† l'utilisateur** :
- Les donn√©es chiffr√©es par un utilisateur ne peuvent √™tre d√©chiffr√©es que par lui
- Probl√©matique si le profil utilisateur est supprim√©
- N√©cessite une strat√©gie de sauvegarde

**‚ö†Ô∏è Pas de contr√¥le granulaire** :
- Impossible de d√©finir des politiques d'expiration
- Pas de rotation automatique des cl√©s

## Comment fonctionne DPAPI ?

### Architecture

```
Application
    ‚Üì appelle
CryptProtectData / CryptUnprotectData
    ‚Üì utilise
Security Support Provider (SSP)
    ‚Üì d√©rive cl√© depuis
Informations d'identification Windows + Master Key
    ‚Üì optionnel
TPM (Trusted Platform Module)
```

### Port√©es de protection

**1. User Scope (CRYPTPROTECT_UI_FORBIDDEN)** :
- Les donn√©es sont prot√©g√©es pour l'utilisateur actuel uniquement
- M√™me l'administrateur ne peut pas d√©chiffrer
- **Recommand√©** pour les donn√©es utilisateur (mots de passe, tokens)

**2. Machine Scope (CRYPTPROTECT_LOCAL_MACHINE)** :
- Les donn√©es peuvent √™tre d√©chiffr√©es par n'importe quel utilisateur de la machine
- Utile pour les services Windows
- **Moins s√©curis√©** que User Scope

### Flux de chiffrement

```
Donn√©es en clair
    ‚Üì
CryptProtectData
    ‚Üì
[G√©n√©ration cl√© d√©riv√©e de l'utilisateur]
    ‚Üì
[Chiffrement AES]
    ‚Üì
Donn√©es chiffr√©es (BLOB)
```

### Flux de d√©chiffrement

```
Donn√©es chiffr√©es (BLOB)
    ‚Üì
CryptUnprotectData
    ‚Üì
[V√©rification identit√© utilisateur]
    ‚Üì
[D√©chiffrement avec cl√© utilisateur]
    ‚Üì
Donn√©es en clair
```

## Impl√©mentation en FreePascal

### Structures et d√©clarations

```pascal
{$IFDEF WINDOWS}
uses
  Windows;

type
  DATA_BLOB = record
    cbData: DWORD;
    pbData: PByte;
  end;
  PDATA_BLOB = ^DATA_BLOB;

const
  CRYPTPROTECT_UI_FORBIDDEN = $1;
  CRYPTPROTECT_LOCAL_MACHINE = $4;
  CRYPTPROTECT_AUDIT = $10;

// Fonctions DPAPI
function CryptProtectData(
  pDataIn: PDATA_BLOB;
  szDataDescr: PWideChar;
  pOptionalEntropy: PDATA_BLOB;
  pvReserved: Pointer;
  pPromptStruct: Pointer;
  dwFlags: DWORD;
  pDataOut: PDATA_BLOB
): BOOL; stdcall; external 'Crypt32.dll';

function CryptUnprotectData(
  pDataIn: PDATA_BLOB;
  ppszDataDescr: PPWideChar;
  pOptionalEntropy: PDATA_BLOB;
  pvReserved: Pointer;
  pPromptStruct: Pointer;
  dwFlags: DWORD;
  pDataOut: PDATA_BLOB
): BOOL; stdcall; external 'Crypt32.dll';
{$ENDIF}
```

### Fonction de protection (chiffrement)

```pascal
{$IFDEF WINDOWS}
function ProtectDataDPAPI(const PlainText: string): string;
var
  DataIn, DataOut: DATA_BLOB;
  DataBytes: TBytes;
  ResultBytes: TBytes;
begin
  Result := '';

  // Convertir la cha√Æne en bytes
  DataBytes := TEncoding.UTF8.GetBytes(PlainText);

  // Pr√©parer le blob d'entr√©e
  DataIn.cbData := Length(DataBytes);
  DataIn.pbData := @DataBytes[0];

  // Initialiser le blob de sortie
  FillChar(DataOut, SizeOf(DataOut), 0);

  // Chiffrer avec DPAPI (User Scope)
  if CryptProtectData(
    @DataIn,
    nil,  // Description optionnelle
    nil,  // Entropy optionnelle
    nil,
    nil,
    CRYPTPROTECT_UI_FORBIDDEN,  // User scope, pas d'UI
    @DataOut
  ) then
  begin
    try
      // Convertir en bytes puis en Base64 pour stockage
      SetLength(ResultBytes, DataOut.cbData);
      Move(DataOut.pbData^, ResultBytes[0], DataOut.cbData);
      Result := EncodeBase64(ResultBytes);
    finally
      // Lib√©rer la m√©moire allou√©e par DPAPI
      LocalFree(HLOCAL(DataOut.pbData));
    end;
  end
  else
    raise Exception.CreateFmt('Erreur DPAPI: %d', [GetLastError]);
end;
{$ENDIF}
```

### Fonction de d√©protection (d√©chiffrement)

```pascal
{$IFDEF WINDOWS}
function UnprotectDataDPAPI(const EncryptedText: string): string;
var
  DataIn, DataOut: DATA_BLOB;
  EncryptedBytes: TBytes;
  ResultBytes: TBytes;
begin
  Result := '';

  // D√©coder le Base64
  EncryptedBytes := DecodeBase64(EncryptedText);

  // Pr√©parer le blob d'entr√©e
  DataIn.cbData := Length(EncryptedBytes);
  DataIn.pbData := @EncryptedBytes[0];

  // Initialiser le blob de sortie
  FillChar(DataOut, SizeOf(DataOut), 0);

  // D√©chiffrer avec DPAPI
  if CryptUnprotectData(
    @DataIn,
    nil,
    nil,
    nil,
    nil,
    CRYPTPROTECT_UI_FORBIDDEN,
    @DataOut
  ) then
  begin
    try
      // Convertir en cha√Æne UTF-8
      SetLength(ResultBytes, DataOut.cbData);
      Move(DataOut.pbData^, ResultBytes[0], DataOut.cbData);
      Result := TEncoding.UTF8.GetString(ResultBytes);
    finally
      // Lib√©rer la m√©moire
      LocalFree(HLOCAL(DataOut.pbData));
    end;
  end
  else
    raise Exception.CreateFmt('Erreur DPAPI d√©chiffrement: %d', [GetLastError]);
end;
{$ENDIF}
```

### Utilisation basique

```pascal
program DPAPIExample;

{$mode objfpc}{$H+}
{$IFDEF WINDOWS}

uses
  SysUtils, Windows;

var
  PlainText, Encrypted, Decrypted: string;
begin
  WriteLn('=== Exemple DPAPI ===');
  WriteLn;

  PlainText := 'Mon mot de passe secret 123!';
  WriteLn('Texte en clair: ', PlainText);
  WriteLn;

  // Chiffrer
  WriteLn('Chiffrement avec DPAPI...');
  Encrypted := ProtectDataDPAPI(PlainText);
  WriteLn('Texte chiffr√© (Base64): ');
  WriteLn(Copy(Encrypted, 1, 80), '...');
  WriteLn;

  // D√©chiffrer
  WriteLn('D√©chiffrement avec DPAPI...');
  Decrypted := UnprotectDataDPAPI(Encrypted);
  WriteLn('Texte d√©chiffr√©: ', Decrypted);
  WriteLn;

  if PlainText = Decrypted then
    WriteLn('‚úì Succ√®s !')
  else
    WriteLn('‚úó √âchec');

  ReadLn;
end.
{$ENDIF}
```

## Entropy additionnelle (s√©curit√© renforc√©e)

### Qu'est-ce que l'entropy ?

L'entropy est un "sel" suppl√©mentaire que vous pouvez fournir pour renforcer le chiffrement. M√™me si quelqu'un obtient les donn√©es chiffr√©es, il lui faudra aussi l'entropy pour d√©chiffrer.

**Cas d'usage** :
- Protection suppl√©mentaire contre les attaques
- Lier les donn√©es √† l'application sp√©cifique
- Diff√©rencier plusieurs stockages

### Impl√©mentation avec entropy

```pascal
{$IFDEF WINDOWS}
function ProtectDataWithEntropy(const PlainText: string;
                                const Entropy: string): string;
var
  DataIn, DataOut, EntropyBlob: DATA_BLOB;
  DataBytes, EntropyBytes: TBytes;
  ResultBytes: TBytes;
begin
  Result := '';

  DataBytes := TEncoding.UTF8.GetBytes(PlainText);
  EntropyBytes := TEncoding.UTF8.GetBytes(Entropy);

  DataIn.cbData := Length(DataBytes);
  DataIn.pbData := @DataBytes[0];

  EntropyBlob.cbData := Length(EntropyBytes);
  EntropyBlob.pbData := @EntropyBytes[0];

  FillChar(DataOut, SizeOf(DataOut), 0);

  if CryptProtectData(
    @DataIn,
    PWideChar('Protected by MyApp'),  // Description
    @EntropyBlob,  // Entropy additionnelle
    nil,
    nil,
    CRYPTPROTECT_UI_FORBIDDEN,
    @DataOut
  ) then
  begin
    try
      SetLength(ResultBytes, DataOut.cbData);
      Move(DataOut.pbData^, ResultBytes[0], DataOut.cbData);
      Result := EncodeBase64(ResultBytes);
    finally
      LocalFree(HLOCAL(DataOut.pbData));
    end;
  end
  else
    raise Exception.CreateFmt('Erreur DPAPI: %d', [GetLastError]);
end;

function UnprotectDataWithEntropy(const EncryptedText: string;
                                  const Entropy: string): string;
var
  DataIn, DataOut, EntropyBlob: DATA_BLOB;
  EncryptedBytes, EntropyBytes: TBytes;
  ResultBytes: TBytes;
begin
  Result := '';

  EncryptedBytes := DecodeBase64(EncryptedText);
  EntropyBytes := TEncoding.UTF8.GetBytes(Entropy);

  DataIn.cbData := Length(EncryptedBytes);
  DataIn.pbData := @EncryptedBytes[0];

  EntropyBlob.cbData := Length(EntropyBytes);
  EntropyBlob.pbData := @EntropyBytes[0];

  FillChar(DataOut, SizeOf(DataOut), 0);

  if CryptUnprotectData(
    @DataIn,
    nil,
    @EntropyBlob,  // M√™me entropy pour d√©chiffrer
    nil,
    nil,
    CRYPTPROTECT_UI_FORBIDDEN,
    @DataOut
  ) then
  begin
    try
      SetLength(ResultBytes, DataOut.cbData);
      Move(DataOut.pbData^, ResultBytes[0], DataOut.cbData);
      Result := TEncoding.UTF8.GetString(ResultBytes);
    finally
      LocalFree(HLOCAL(DataOut.pbData));
    end;
  end
  else
    raise Exception.CreateFmt('Erreur DPAPI d√©chiffrement: %d', [GetLastError]);
end;

// Utilisation
const
  APP_ENTROPY = 'MonApplication-V1.0-Entropy-Key';

var
  Encrypted: string;
begin
  // Chiffrer avec entropy
  Encrypted := ProtectDataWithEntropy('Secret', APP_ENTROPY);

  // D√©chiffrer avec la m√™me entropy
  Decrypted := UnprotectDataWithEntropy(Encrypted, APP_ENTROPY);
end;
{$ENDIF}
```

## Stockage de donn√©es dans des fichiers

### Classe de gestion de stockage s√©curis√©

```pascal
{$IFDEF WINDOWS}
type
  TDPAPIStorage = class
  private
    FFileName: string;
    FEntropy: string;
  public
    constructor Create(const FileName: string; const Entropy: string = '');
    function SaveData(const Key, Value: string): Boolean;
    function LoadData(const Key: string): string;
    function DeleteData(const Key: string): Boolean;
    function HasKey(const Key: string): Boolean;
    procedure Clear;
  end;

constructor TDPAPIStorage.Create(const FileName: string;
                                 const Entropy: string = '');
begin
  inherited Create;
  FFileName := FileName;
  FEntropy := Entropy;

  // Cr√©er le r√©pertoire si n√©cessaire
  ForceDirectories(ExtractFilePath(FFileName));
end;

function TDPAPIStorage.SaveData(const Key, Value: string): Boolean;
var
  Data: TStringList;
  EncryptedValue: string;
begin
  Result := False;

  try
    // Chiffrer la valeur
    if FEntropy <> '' then
      EncryptedValue := ProtectDataWithEntropy(Value, FEntropy)
    else
      EncryptedValue := ProtectDataDPAPI(Value);

    // Charger les donn√©es existantes
    Data := TStringList.Create;
    try
      if FileExists(FFileName) then
        Data.LoadFromFile(FFileName);

      // Ajouter ou mettre √† jour
      Data.Values[Key] := EncryptedValue;

      // Sauvegarder
      Data.SaveToFile(FFileName);

      Result := True;
    finally
      Data.Free;
    end;
  except
    on E: Exception do
      WriteLn('Erreur sauvegarde: ', E.Message);
  end;
end;

function TDPAPIStorage.LoadData(const Key: string): string;
var
  Data: TStringList;
  EncryptedValue: string;
begin
  Result := '';

  if not FileExists(FFileName) then
    Exit;

  try
    Data := TStringList.Create;
    try
      Data.LoadFromFile(FFileName);

      EncryptedValue := Data.Values[Key];
      if EncryptedValue <> '' then
      begin
        // D√©chiffrer
        if FEntropy <> '' then
          Result := UnprotectDataWithEntropy(EncryptedValue, FEntropy)
        else
          Result := UnprotectDataDPAPI(EncryptedValue);
      end;
    finally
      Data.Free;
    end;
  except
    on E: Exception do
      WriteLn('Erreur chargement: ', E.Message);
  end;
end;

function TDPAPIStorage.DeleteData(const Key: string): Boolean;
var
  Data: TStringList;
begin
  Result := False;

  if not FileExists(FFileName) then
    Exit;

  try
    Data := TStringList.Create;
    try
      Data.LoadFromFile(FFileName);

      if Data.IndexOfName(Key) >= 0 then
      begin
        Data.Delete(Data.IndexOfName(Key));
        Data.SaveToFile(FFileName);
        Result := True;
      end;
    finally
      Data.Free;
    end;
  except
    on E: Exception do
      WriteLn('Erreur suppression: ', E.Message);
  end;
end;

function TDPAPIStorage.HasKey(const Key: string): Boolean;
var
  Data: TStringList;
begin
  Result := False;

  if not FileExists(FFileName) then
    Exit;

  Data := TStringList.Create;
  try
    Data.LoadFromFile(FFileName);
    Result := Data.IndexOfName(Key) >= 0;
  finally
    Data.Free;
  end;
end;

procedure TDPAPIStorage.Clear;
begin
  if FileExists(FFileName) then
    DeleteFile(FFileName);
end;

// Utilisation
var
  Storage: TDPAPIStorage;
begin
  Storage := TDPAPIStorage.Create(
    GetAppConfigDir(False) + 'secure.dat',
    'MyApp-Entropy-v1.0'
  );
  try
    // Stocker
    Storage.SaveData('api_key', 'sk_live_abc123...');
    Storage.SaveData('db_password', 'MySecretPassword');

    // Charger
    APIKey := Storage.LoadData('api_key');
    DBPassword := Storage.LoadData('db_password');

    // V√©rifier existence
    if Storage.HasKey('api_key') then
      WriteLn('Cl√© API trouv√©e');

    // Supprimer
    Storage.DeleteData('old_token');
  finally
    Storage.Free;
  end;
end;
{$ENDIF}
```

## Protection de fichiers de configuration

### Chiffrer un fichier INI complet

```pascal
{$IFDEF WINDOWS}
type
  TSecureINI = class
  private
    FFileName: string;
    FEntropy: string;
    function EncryptFile(const SourceFile, DestFile: string): Boolean;
    function DecryptFile(const SourceFile, DestFile: string): Boolean;
  public
    constructor Create(const FileName: string; const Entropy: string = '');
    function ReadString(const Section, Key, Default: string): string;
    procedure WriteString(const Section, Key, Value: string);
    procedure Save;
  end;

constructor TSecureINI.Create(const FileName: string;
                              const Entropy: string = '');
begin
  inherited Create;
  FFileName := FileName;
  FEntropy := Entropy;
end;

function TSecureINI.EncryptFile(const SourceFile, DestFile: string): Boolean;
var
  Source: TFileStream;
  PlainText, Encrypted: string;
  Buffer: TBytes;
begin
  Result := False;

  Source := TFileStream.Create(SourceFile, fmOpenRead);
  try
    SetLength(Buffer, Source.Size);
    Source.Read(Buffer[0], Source.Size);
    PlainText := TEncoding.UTF8.GetString(Buffer);

    // Chiffrer tout le contenu
    if FEntropy <> '' then
      Encrypted := ProtectDataWithEntropy(PlainText, FEntropy)
    else
      Encrypted := ProtectDataDPAPI(PlainText);

    // Sauvegarder
    with TStringList.Create do
    try
      Text := Encrypted;
      SaveToFile(DestFile);
      Result := True;
    finally
      Free;
    end;
  finally
    Source.Free;
  end;
end;

function TSecureINI.DecryptFile(const SourceFile, DestFile: string): Boolean;
var
  Encrypted, Decrypted: string;
begin
  Result := False;

  with TStringList.Create do
  try
    LoadFromFile(SourceFile);
    Encrypted := Text;

    // D√©chiffrer
    if FEntropy <> '' then
      Decrypted := UnprotectDataWithEntropy(Encrypted, FEntropy)
    else
      Decrypted := UnprotectDataDPAPI(Encrypted);

    // Sauvegarder le fichier d√©chiffr√© temporaire
    Text := Decrypted;
    SaveToFile(DestFile);
    Result := True;
  finally
    Free;
  end;
end;

// Utilisation
var
  SecureINI: TSecureINI;
  Username, Password: string;
begin
  SecureINI := TSecureINI.Create('config.secure', 'MyApp-v1');
  try
    // √âcrire
    SecureINI.WriteString('Database', 'Username', 'admin');
    SecureINI.WriteString('Database', 'Password', 'MyPassword123');
    SecureINI.Save;

    // Lire
    Username := SecureINI.ReadString('Database', 'Username', '');
    Password := SecureINI.ReadString('Database', 'Password', '');
  finally
    SecureINI.Free;
  end;
end;
{$ENDIF}
```

## DPAPI avec Machine Scope

### Quand utiliser Machine Scope ?

**Cas d'usage** :
- Services Windows (s'ex√©cutant sous diff√©rents comptes)
- Donn√©es partag√©es entre utilisateurs
- Configuration syst√®me

**‚ö†Ô∏è Attention** : Moins s√©curis√© que User Scope car accessible √† tous les utilisateurs de la machine.

### Impl√©mentation

```pascal
{$IFDEF WINDOWS}
function ProtectDataMachineScope(const PlainText: string): string;
var
  DataIn, DataOut: DATA_BLOB;
  DataBytes: TBytes;
  ResultBytes: TBytes;
begin
  Result := '';

  DataBytes := TEncoding.UTF8.GetBytes(PlainText);

  DataIn.cbData := Length(DataBytes);
  DataIn.pbData := @DataBytes[0];

  FillChar(DataOut, SizeOf(DataOut), 0);

  // CRYPTPROTECT_LOCAL_MACHINE pour Machine Scope
  if CryptProtectData(
    @DataIn,
    nil,
    nil,
    nil,
    nil,
    CRYPTPROTECT_LOCAL_MACHINE,  // Machine scope
    @DataOut
  ) then
  begin
    try
      SetLength(ResultBytes, DataOut.cbData);
      Move(DataOut.pbData^, ResultBytes[0], DataOut.cbData);
      Result := EncodeBase64(ResultBytes);
    finally
      LocalFree(HLOCAL(DataOut.pbData));
    end;
  end
  else
    raise Exception.CreateFmt('Erreur DPAPI: %d', [GetLastError]);
end;

function UnprotectDataMachineScope(const EncryptedText: string): string;
var
  DataIn, DataOut: DATA_BLOB;
  EncryptedBytes: TBytes;
  ResultBytes: TBytes;
begin
  Result := '';

  EncryptedBytes := DecodeBase64(EncryptedText);

  DataIn.cbData := Length(EncryptedBytes);
  DataIn.pbData := @EncryptedBytes[0];

  FillChar(DataOut, SizeOf(DataOut), 0);

  if CryptUnprotectData(
    @DataIn,
    nil,
    nil,
    nil,
    nil,
    CRYPTPROTECT_LOCAL_MACHINE,  // Machine scope
    @DataOut
  ) then
  begin
    try
      SetLength(ResultBytes, DataOut.cbData);
      Move(DataOut.pbData^, ResultBytes[0], DataOut.cbData);
      Result := TEncoding.UTF8.GetString(ResultBytes);
    finally
      LocalFree(HLOCAL(DataOut.pbData));
    end;
  end
  else
    raise Exception.CreateFmt('Erreur DPAPI d√©chiffrement: %d', [GetLastError]);
end;
{$ENDIF}
```

## Windows Credential Manager

### Qu'est-ce que Credential Manager ?

Le Gestionnaire d'informations d'identification Windows est un stockage centralis√© pour les credentials (identifiants). Il utilise DPAPI en interne et offre une interface standardis√©e.

**Avantages** :
- Interface utilisateur int√©gr√©e (Panneau de configuration)
- Synchronisation possible avec les comptes Microsoft
- Gestion centralis√©e
- Support des diff√©rents types de credentials

### Types de credentials

- **Generic** : Credentials g√©n√©riques (le plus courant)
- **Domain Password** : Mots de passe de domaine
- **Domain Certificate** : Certificats de domaine
- **Domain Visible Password** : Mots de passe de domaine visibles

### Impl√©mentation

```pascal
{$IFDEF WINDOWS}
type
  PCREDENTIALW = ^TCREDENTIALW;
  TCREDENTIALW = record
    Flags: DWORD;
    Type_: DWORD;
    TargetName: PWideChar;
    Comment: PWideChar;
    LastWritten: TFileTime;
    CredentialBlobSize: DWORD;
    CredentialBlob: PByte;
    Persist: DWORD;
    AttributeCount: DWORD;
    Attributes: Pointer;
    TargetAlias: PWideChar;
    UserName: PWideChar;
  end;

const
  CRED_TYPE_GENERIC = 1;
  CRED_PERSIST_LOCAL_MACHINE = 2;
  CRED_PERSIST_ENTERPRISE = 3;

function CredWriteW(Credential: PCREDENTIALW; Flags: DWORD): BOOL; stdcall;
  external 'Advapi32.dll';

function CredReadW(TargetName: PWideChar; Type_: DWORD; Flags: DWORD;
  var Credential: PCREDENTIALW): BOOL; stdcall;
  external 'Advapi32.dll';

function CredDeleteW(TargetName: PWideChar; Type_: DWORD; Flags: DWORD): BOOL; stdcall;
  external 'Advapi32.dll';

procedure CredFree(Buffer: Pointer); stdcall;
  external 'Advapi32.dll';

function SaveToCredentialManager(const Target, Username, Password: string): Boolean;
var
  Cred: TCREDENTIALW;
  PasswordBytes: TBytes;
begin
  Result := False;

  FillChar(Cred, SizeOf(Cred), 0);

  // Convertir le mot de passe en bytes
  PasswordBytes := TEncoding.UTF8.GetBytes(Password);

  Cred.Type_ := CRED_TYPE_GENERIC;
  Cred.TargetName := PWideChar(WideString(Target));
  Cred.UserName := PWideChar(WideString(Username));
  Cred.CredentialBlob := @PasswordBytes[0];
  Cred.CredentialBlobSize := Length(PasswordBytes);
  Cred.Persist := CRED_PERSIST_LOCAL_MACHINE;

  Result := CredWriteW(@Cred, 0);
end;

function LoadFromCredentialManager(const Target: string;
                                    out Username, Password: string): Boolean;
var
  Cred: PCREDENTIALW;
  PasswordBytes: TBytes;
begin
  Result := False;

  if CredReadW(PWideChar(WideString(Target)), CRED_TYPE_GENERIC, 0, Cred) then
  begin
    try
      // Extraire le nom d'utilisateur
      Username := string(Cred.UserName);

      // Extraire le mot de passe
      SetLength(PasswordBytes, Cred.CredentialBlobSize);
      Move(Cred.CredentialBlob^, PasswordBytes[0], Cred.CredentialBlobSize);
      Password := TEncoding.UTF8.GetString(PasswordBytes);

      Result := True;
    finally
      CredFree(Cred);
    end;
  end;
end;

function DeleteFromCredentialManager(const Target: string): Boolean;
begin
  Result := CredDeleteW(PWideChar(WideString(Target)), CRED_TYPE_GENERIC, 0);
end;

// Utilisation
var
  Username, Password: string;
begin
  // Sauvegarder
  if SaveToCredentialManager('MyApp:DatabaseConnection', 'admin', 'MyPassword123') then
    WriteLn('‚úì Credentials sauvegard√©s');

  // Charger
  if LoadFromCredentialManager('MyApp:DatabaseConnection', Username, Password) then
  begin
    WriteLn('Username: ', Username);
    WriteLn('Password: ', Password);
  end;

  // Supprimer
  if DeleteFromCredentialManager('MyApp:DatabaseConnection') then
    WriteLn('‚úì Credentials supprim√©s');
end;
{$ENDIF}
```

## Gestion des erreurs

### Codes d'erreur courants

```pascal
{$IFDEF WINDOWS}
const
  ERROR_SUCCESS = 0;
  ERROR_INVALID_PARAMETER = 87;
  ERROR_NOT_FOUND = 1168;
  NTE_BAD_DATA = $80090005;
  NTE_BAD_KEY = $80090003;

function GetDPAPIErrorMessage(ErrorCode: DWORD): string;
begin
  case ErrorCode of
    ERROR_SUCCESS:
      Result := 'Succ√®s';
    ERROR_INVALID_PARAMETER:
      Result := 'Param√®tre invalide';
    ERROR_NOT_FOUND:
      Result := 'Credential non trouv√©';
    NTE_BAD_DATA:
      Result := 'Donn√©es corrompues ou entropy incorrecte';
    NTE_BAD_KEY:
      Result := 'Cl√© invalide ou corrompue';
    else
      Result := Format('Erreur DPAPI: 0x%x', [ErrorCode]);
  end;
end;

function SafeProtectData(const PlainText: string;
                         out Encrypted: string): Boolean;
begin
  Result := False;
  Encrypted := '';

  try
    Encrypted := ProtectDataDPAPI(PlainText);
    Result := True;
  except
    on E: Exception do
    begin
      WriteLn('Erreur de protection: ', E.Message);
      WriteLn('Code erreur: ', GetDPAPIErrorMessage(GetLastError));
    end;
  end;
end;

function SafeUnprotectData(const EncryptedText: string;
                           out PlainText: string): Boolean;
begin
  Result := False;
  PlainText := '';

  try
    PlainText := UnprotectDataDPAPI(EncryptedText);
    Result := True;
  except
    on E: Exception do
    begin
      WriteLn('Erreur de d√©protection: ', E.Message);
      WriteLn('Code erreur: ', GetDPAPIErrorMessage(GetLastError));

      // V√©rifier les causes courantes
      if GetLastError = NTE_BAD_DATA then
        WriteLn('Possible cause: Entropy incorrecte ou donn√©es corrompues');
    end;
  end;
end;
{$ENDIF}
```

## Bonnes pratiques DPAPI

### 1. Toujours utiliser l'entropy

```pascal
// ‚ùå Sans entropy - moins s√©curis√©
Encrypted := ProtectDataDPAPI(Secret);

// ‚úÖ Avec entropy - recommand√©
const APP_ENTROPY = 'MyApp-DPAPI-Salt-v1.0-2024';
Encrypted := ProtectDataWithEntropy(Secret, APP_ENTROPY);
```

### 2. G√©rer les changements de profil utilisateur

```pascal
type
  TDPAPIBackup = class
  public
    class procedure CreateBackup(const Key, Value: string);
    class function RestoreFromBackup(const Key: string): string;
  end;

class procedure TDPAPIBackup.CreateBackup(const Key, Value: string);
var
  BackupFile: string;
  Encrypted: string;
begin
  // Cr√©er une sauvegarde chiffr√©e avec un mot de passe ma√Ætre
  BackupFile := GetAppConfigDir(False) + 'backup_' + Key + '.bak';

  // Chiffrer avec un mot de passe s√©par√© (demand√© √† l'utilisateur)
  Encrypted := EncryptWithPassword(Value, GetMasterPassword);

  with TStringList.Create do
  try
    Text := Encrypted;
    SaveToFile(BackupFile);
  finally
    Free;
  end;
end;

class function TDPAPIBackup.RestoreFromBackup(const Key: string): string;
var
  BackupFile: string;
  Encrypted: string;
begin
  BackupFile := GetAppConfigDir(False) + 'backup_' + Key + '.bak';

  if FileExists(BackupFile) then
  begin
    with TStringList.Create do
    try
      LoadFromFile(BackupFile);
      Encrypted := Text;
      Result := DecryptWithPassword(Encrypted, GetMasterPassword);
    finally
      Free;
    end;
  end;
end;
```

### 3. Versionner le format de stockage

```pascal
type
  TDPAPIStorageFormat = (
    sfVersion1,  // DPAPI simple
    sfVersion2   // DPAPI + Entropy
  );

  TDPAPIVersionedStorage = class
  private
    FVersion: TDPAPIStorageFormat;
    function GetVersionByte: Byte;
  public
    function Protect(const PlainText: string): string;
    function Unprotect(const EncryptedText: string): string;
  end;

function TDPAPIVersionedStorage.Protect(const PlainText: string): string;
var
  Data: string;
begin
  // Ajouter le num√©ro de version en pr√©fixe
  case FVersion of
    sfVersion1:
    begin
      Data := ProtectDataDPAPI(PlainText);
      Result := 'V1:' + Data;
    end;

    sfVersion2:
    begin
      Data := ProtectDataWithEntropy(PlainText, APP_ENTROPY);
      Result := 'V2:' + Data;
    end;
  end;
end;

function TDPAPIVersionedStorage.Unprotect(const EncryptedText: string): string;
var
  Version: string;
  Data: string;
begin
  // Extraire la version
  if Pos(':', EncryptedText) > 0 then
  begin
    Version := Copy(EncryptedText, 1, Pos(':', EncryptedText) - 1);
    Data := Copy(EncryptedText, Pos(':', EncryptedText) + 1, MaxInt);

    // D√©chiffrer selon la version
    if Version = 'V1' then
      Result := UnprotectDataDPAPI(Data)
    else if Version = 'V2' then
      Result := UnprotectDataWithEntropy(Data, APP_ENTROPY)
    else
      raise Exception.Create('Version de format inconnue');
  end
  else
    raise Exception.Create('Format invalide');
end;
```

### 4. Nettoyer la m√©moire apr√®s utilisation

```pascal
procedure SecureProcessPassword(const EncryptedPassword: string);
var
  Password: string;
begin
  Password := UnprotectDataDPAPI(EncryptedPassword);
  try
    // Utiliser le mot de passe
    ConnectToDatabase(Password);
  finally
    // √âcraser en m√©moire avant de lib√©rer
    SecureWipeString(Password);
  end;
end;

procedure SecureWipeString(var S: string);
var
  i: Integer;
begin
  for i := 1 to Length(S) do
    S[i] := #0;
  S := '';
end;
```

### 5. Logger les acc√®s (sans exposer les valeurs)

```pascal
procedure LogSecureStorageAccess(const Operation, Key: string; Success: Boolean);
begin
  WriteToLog(Format(
    '[SECURE_STORAGE] %s - Operation: %s, Key: %s, Success: %s, User: %s',
    [DateTimeToStr(Now), Operation, Key, BoolToStr(Success),
     GetCurrentUserName]
  ));

  // Alerter si trop d'√©checs
  if not Success then
    IncrementFailedAttempts(Key);
end;

// Utilisation
function LoadSecureValue(const Key: string): string;
begin
  try
    Result := Storage.LoadData(Key);
    LogSecureStorageAccess('LOAD', Key, True);
  except
    on E: Exception do
    begin
      LogSecureStorageAccess('LOAD', Key, False);
      raise;
    end;
  end;
end;
```

## Exemple d'application compl√®te

### Gestionnaire de mots de passe simple

```pascal
program PasswordManager;

{$mode objfpc}{$H+}
{$IFDEF WINDOWS}

uses
  SysUtils, Classes, Windows;

type
  TPasswordEntry = record
    Title: string;
    Username: string;
    Password: string;
    URL: string;
    Notes: string;
    CreatedAt: TDateTime;
    ModifiedAt: TDateTime;
  end;

  TPasswordManager = class
  private
    FStorage: TDPAPIStorage;
    FEntries: TList<TPasswordEntry>;
    FMasterEntropy: string;
    procedure LoadEntries;
    procedure SaveEntries;
  public
    constructor Create(const MasterPassword: string);
    destructor Destroy; override;

    procedure AddEntry(const Entry: TPasswordEntry);
    procedure UpdateEntry(Index: Integer; const Entry: TPasswordEntry);
    procedure DeleteEntry(Index: Integer);
    function GetEntry(Index: Integer): TPasswordEntry;
    function GetEntryCount: Integer;
    function SearchEntries(const Query: string): TArray<Integer>;
  end;

constructor TPasswordManager.Create(const MasterPassword: string);
begin
  inherited Create;

  // Cr√©er une entropy unique bas√©e sur le mot de passe ma√Ætre
  FMasterEntropy := HashSHA256(MasterPassword + 'PasswordManager-v1.0');

  // Cr√©er le stockage DPAPI
  FStorage := TDPAPIStorage.Create(
    GetAppConfigDir(False) + 'passwords.db',
    FMasterEntropy
  );

  FEntries := TList<TPasswordEntry>.Create;
  LoadEntries;
end;

destructor TPasswordManager.Destroy;
begin
  SaveEntries;
  FEntries.Free;
  FStorage.Free;

  // Nettoyer la m√©moire
  SecureWipeString(FMasterEntropy);

  inherited Destroy;
end;

procedure TPasswordManager.LoadEntries;
var
  Data: string;
  Lines: TStringList;
  i: Integer;
  Entry: TPasswordEntry;
begin
  FEntries.Clear;

  Data := FStorage.LoadData('entries');
  if Data = '' then
    Exit;

  Lines := TStringList.Create;
  try
    Lines.Text := Data;

    i := 0;
    while i < Lines.Count do
    begin
      if Lines[i] = '[ENTRY]' then
      begin
        Inc(i);
        Entry.Title := Lines.Values['Title'];
        Entry.Username := Lines.Values['Username'];
        Entry.Password := Lines.Values['Password'];
        Entry.URL := Lines.Values['URL'];
        Entry.Notes := Lines.Values['Notes'];
        Entry.CreatedAt := StrToDateTime(Lines.Values['CreatedAt']);
        Entry.ModifiedAt := StrToDateTime(Lines.Values['ModifiedAt']);

        FEntries.Add(Entry);
      end;
      Inc(i);
    end;
  finally
    Lines.Free;
  end;
end;

procedure TPasswordManager.SaveEntries;
var
  Data: TStringList;
  i: Integer;
  Entry: TPasswordEntry;
begin
  Data := TStringList.Create;
  try
    for i := 0 to FEntries.Count - 1 do
    begin
      Entry := FEntries[i];

      Data.Add('[ENTRY]');
      Data.Add('Title=' + Entry.Title);
      Data.Add('Username=' + Entry.Username);
      Data.Add('Password=' + Entry.Password);
      Data.Add('URL=' + Entry.URL);
      Data.Add('Notes=' + Entry.Notes);
      Data.Add('CreatedAt=' + DateTimeToStr(Entry.CreatedAt));
      Data.Add('ModifiedAt=' + DateTimeToStr(Entry.ModifiedAt));
      Data.Add('');
    end;

    FStorage.SaveData('entries', Data.Text);
  finally
    Data.Free;
  end;
end;

procedure TPasswordManager.AddEntry(const Entry: TPasswordEntry);
var
  NewEntry: TPasswordEntry;
begin
  NewEntry := Entry;
  NewEntry.CreatedAt := Now;
  NewEntry.ModifiedAt := Now;

  FEntries.Add(NewEntry);
  SaveEntries;

  LogSecureStorageAccess('ADD_ENTRY', Entry.Title, True);
end;

procedure TPasswordManager.UpdateEntry(Index: Integer; const Entry: TPasswordEntry);
var
  UpdatedEntry: TPasswordEntry;
begin
  if (Index < 0) or (Index >= FEntries.Count) then
    raise Exception.Create('Index invalide');

  UpdatedEntry := Entry;
  UpdatedEntry.CreatedAt := FEntries[Index].CreatedAt;
  UpdatedEntry.ModifiedAt := Now;

  FEntries[Index] := UpdatedEntry;
  SaveEntries;

  LogSecureStorageAccess('UPDATE_ENTRY', Entry.Title, True);
end;

procedure TPasswordManager.DeleteEntry(Index: Integer);
var
  Title: string;
begin
  if (Index < 0) or (Index >= FEntries.Count) then
    raise Exception.Create('Index invalide');

  Title := FEntries[Index].Title;
  FEntries.Delete(Index);
  SaveEntries;

  LogSecureStorageAccess('DELETE_ENTRY', Title, True);
end;

function TPasswordManager.GetEntry(Index: Integer): TPasswordEntry;
begin
  if (Index < 0) or (Index >= FEntries.Count) then
    raise Exception.Create('Index invalide');

  Result := FEntries[Index];
end;

function TPasswordManager.GetEntryCount: Integer;
begin
  Result := FEntries.Count;
end;

function TPasswordManager.SearchEntries(const Query: string): TArray<Integer>;
var
  i: Integer;
  Results: TList<Integer>;
  LowerQuery: string;
begin
  Results := TList<Integer>.Create;
  try
    LowerQuery := LowerCase(Query);

    for i := 0 to FEntries.Count - 1 do
    begin
      if (Pos(LowerQuery, LowerCase(FEntries[i].Title)) > 0) or
         (Pos(LowerQuery, LowerCase(FEntries[i].Username)) > 0) or
         (Pos(LowerQuery, LowerCase(FEntries[i].URL)) > 0) then
        Results.Add(i);
    end;

    Result := Results.ToArray;
  finally
    Results.Free;
  end;
end;

// Programme principal
var
  PM: TPasswordManager;
  Entry: TPasswordEntry;
  Choice: Integer;
  MasterPassword: string;
begin
  WriteLn('=== Gestionnaire de Mots de Passe ===');
  WriteLn;

  Write('Mot de passe ma√Ætre: ');
  ReadLn(MasterPassword);

  PM := TPasswordManager.Create(MasterPassword);
  try
    repeat
      WriteLn;
      WriteLn('1. Ajouter une entr√©e');
      WriteLn('2. Afficher les entr√©es');
      WriteLn('3. Rechercher');
      WriteLn('0. Quitter');
      Write('Choix: ');
      ReadLn(Choice);
      WriteLn;

      case Choice of
        1: begin
          Write('Titre: ');
          ReadLn(Entry.Title);
          Write('Nom d''utilisateur: ');
          ReadLn(Entry.Username);
          Write('Mot de passe: ');
          ReadLn(Entry.Password);
          Write('URL: ');
          ReadLn(Entry.URL);
          Write('Notes: ');
          ReadLn(Entry.Notes);

          PM.AddEntry(Entry);
          WriteLn('‚úì Entr√©e ajout√©e et chiffr√©e avec DPAPI');
        end;

        2: begin
          WriteLn('Entr√©es sauvegard√©es:');
          for var i := 0 to PM.GetEntryCount - 1 do
          begin
            Entry := PM.GetEntry(i);
            WriteLn(Format('%d. %s (%s)', [i + 1, Entry.Title, Entry.Username]));
          end;
        end;

        3: begin
          Write('Rechercher: ');
          var Query: string;
          ReadLn(Query);

          var Results := PM.SearchEntries(Query);
          WriteLn(Format('%d r√©sultat(s) trouv√©(s):', [Length(Results)]));

          for var Idx in Results do
          begin
            Entry := PM.GetEntry(Idx);
            WriteLn(Format('  - %s (%s)', [Entry.Title, Entry.URL]));
          end;
        end;
      end;
    until Choice = 0;

    WriteLn('Au revoir !');
  finally
    PM.Free;
  end;
end.
{$ENDIF}
```

## Migration de donn√©es entre utilisateurs

### Export/Import avec mot de passe

```pascal
type
  TDPAPIExporter = class
  public
    class function ExportWithPassword(const SourceKey: string;
                                      const Password: string): string;
    class function ImportWithPassword(const EncryptedData: string;
                                      const Password: string;
                                      const DestKey: string): Boolean;
  end;

class function TDPAPIExporter.ExportWithPassword(const SourceKey: string;
                                                  const Password: string): string;
var
  PlainData: string;
  EncryptedWithPassword: string;
begin
  // 1. D√©chiffrer avec DPAPI
  PlainData := Storage.LoadData(SourceKey);

  // 2. Chiffrer avec un mot de passe (portable)
  EncryptedWithPassword := EncryptAES256WithPassword(PlainData, Password);

  // 3. Encoder en Base64 pour export
  Result := EncodeBase64(EncryptedWithPassword);
end;

class function TDPAPIExporter.ImportWithPassword(const EncryptedData: string;
                                                  const Password: string;
                                                  const DestKey: string): Boolean;
var
  DecodedData: string;
  PlainData: string;
begin
  Result := False;

  try
    // 1. D√©coder Base64
    DecodedData := DecodeBase64(EncryptedData);

    // 2. D√©chiffrer avec le mot de passe
    PlainData := DecryptAES256WithPassword(DecodedData, Password);

    // 3. Chiffrer avec DPAPI du nouvel utilisateur
    Storage.SaveData(DestKey, PlainData);

    Result := True;
  except
    on E: Exception do
      WriteLn('Erreur import: ', E.Message);
  end;
end;

// Utilisation
var
  ExportedData: string;
begin
  // Utilisateur 1 : Export
  ExportedData := TDPAPIExporter.ExportWithPassword('api_key', 'TransferPassword123');
  SaveToFile('export.dat', ExportedData);

  // Utilisateur 2 : Import
  ExportedData := LoadFromFile('export.dat');
  if TDPAPIExporter.ImportWithPassword(ExportedData, 'TransferPassword123', 'api_key') then
    WriteLn('‚úì Import r√©ussi');
end;
```

## Performance et optimisations

### Cache pour √©viter les appels r√©p√©t√©s

```pascal
type
  TDPAPICachedStorage = class(TDPAPIStorage)
  private
    FCache: TDictionary<string, string>;
    FCacheTime: TDictionary<string, TDateTime>;
    FCacheDuration: Integer; // Minutes
  public
    constructor Create(const FileName: string;
                      const Entropy: string = '';
                      CacheDurationMinutes: Integer = 5);
    destructor Destroy; override;
    function LoadData(const Key: string): string; override;
    procedure InvalidateCache(const Key: string);
    procedure ClearCache;
  end;

constructor TDPAPICachedStorage.Create(const FileName: string;
                                        const Entropy: string = '';
                                        CacheDurationMinutes: Integer = 5);
begin
  inherited Create(FileName, Entropy);
  FCache := TDictionary<string, string>.Create;
  FCacheTime := TDictionary<string, TDateTime>.Create;
  FCacheDuration := CacheDurationMinutes;
end;

destructor TDPAPICachedStorage.Destroy;
begin
  // Nettoyer les donn√©es en cache de mani√®re s√©curis√©e
  for var Value in FCache.Values do
    SecureWipeString(Value);

  FCache.Free;
  FCacheTime.Free;
  inherited Destroy;
end;

function TDPAPICachedStorage.LoadData(const Key: string): string;
var
  CachedTime: TDateTime;
begin
  // V√©rifier le cache
  if FCache.TryGetValue(Key, Result) then
  begin
    if FCacheTime.TryGetValue(Key, CachedTime) then
    begin
      // V√©rifier si le cache est encore valide
      if (Now - CachedTime) < (FCacheDuration / 1440) then
        Exit; // Cache valide
    end;
  end;

  // Cache expir√© ou inexistant, charger depuis DPAPI
  Result := inherited LoadData(Key);

  // Mettre en cache
  FCache.AddOrSetValue(Key, Result);
  FCacheTime.AddOrSetValue(Key, Now);
end;

procedure TDPAPICachedStorage.InvalidateCache(const Key: string);
begin
  if FCache.ContainsKey(Key) then
  begin
    SecureWipeString(FCache[Key]);
    FCache.Remove(Key);
    FCacheTime.Remove(Key);
  end;
end;

procedure TDPAPICachedStorage.ClearCache;
begin
  for var Value in FCache.Values do
    SecureWipeString(Value);

  FCache.Clear;
  FCacheTime.Clear;
end;
```

## S√©curit√© avanc√©e

### D√©tecter les tentatives de manipulation

```pascal
type
  TDPAPIIntegrityCheck = class
  private
    class function CalculateFileHash(const FileName: string): string;
  public
    class procedure SaveWithIntegrityCheck(const FileName: string;
                                            const Data: string);
    class function LoadWithIntegrityCheck(const FileName: string): string;
  end;

class function TDPAPIIntegrityCheck.CalculateFileHash(const FileName: string): string;
begin
  Result := CalculateFileSHA256(FileName);
end;

class procedure TDPAPIIntegrityCheck.SaveWithIntegrityCheck(const FileName: string;
                                                             const Data: string);
var
  ProtectedData: string;
  Hash: string;
  Output: TStringList;
begin
  // Chiffrer avec DPAPI
  ProtectedData := ProtectDataDPAPI(Data);

  // Calculer le hash de l'ensemble
  Hash := HashSHA256(ProtectedData);

  // Sauvegarder avec le hash
  Output := TStringList.Create;
  try
    Output.Add('HASH:' + Hash);
    Output.Add('DATA:' + ProtectedData);
    Output.SaveToFile(FileName);
  finally
    Output.Free;
  end;
end;

class function TDPAPIIntegrityCheck.LoadWithIntegrityCheck(const FileName: string): string;
var
  Input: TStringList;
  StoredHash, Data, CalculatedHash: string;
begin
  Result := '';

  Input := TStringList.Create;
  try
    Input.LoadFromFile(FileName);

    // Extraire hash et data
    StoredHash := Copy(Input[0], 6, MaxInt); // Enlever 'HASH:'
    Data := Copy(Input[1], 6, MaxInt);       // Enlever 'DATA:'

    // V√©rifier l'int√©grit√©
    CalculatedHash := HashSHA256(Data);

    if StoredHash <> CalculatedHash then
    begin
      LogSecurityEvent('INTEGRITY_VIOLATION',
        'Fichier manipul√©: ' + FileName);
      raise Exception.Create('‚ö†Ô∏è Int√©grit√© du fichier compromise !');
    end;

    // D√©chiffrer
    Result := UnprotectDataDPAPI(Data);
  finally
    Input.Free;
  end;
end;
```

## R√©sum√© et bonnes pratiques

### Checklist DPAPI

**‚úÖ √Ä faire** :
- [ ] Toujours utiliser une entropy unique par application
- [ ] Impl√©menter une gestion d'erreurs robuste
- [ ] Logger les acc√®s (sans les valeurs)
- [ ] Nettoyer la m√©moire apr√®s utilisation
- [ ] Cr√©er des sauvegardes avec mot de passe pour migration
- [ ] Versionner le format de stockage
- [ ] V√©rifier l'int√©grit√© des donn√©es
- [ ] Utiliser le cache pour les performances

**‚ùå √Ä √©viter** :
- [ ] Ne pas utiliser DPAPI sans entropy
- [ ] Ne pas stocker de donn√©es DPAPI dans le cloud directement
- [ ] Ne pas logger les valeurs d√©chiffr√©es
- [ ] Ne pas partager des donn√©es DPAPI entre machines
- [ ] Ne pas oublier la gestion des profils utilisateur supprim√©s

### Quand utiliser DPAPI ?

**‚úÖ Id√©al pour** :
- Mots de passe d'applications desktop Windows
- Tokens d'authentification locaux
- Cl√©s API personnelles
- Configuration sensible utilisateur
- Credentials de base de donn√©es locale

**‚ö†Ô∏è Moins adapt√© pour** :
- Applications web (serveurs)
- Donn√©es partag√©es entre machines
- Environnements non-Windows
- Donn√©es n√©cessitant une portabilit√© totale

## Ressources

### Documentation Microsoft

- **DPAPI Overview** : https://docs.microsoft.com/en-us/windows/win32/api/dpapi/
- **CryptProtectData** : https://docs.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata
- **Credential Manager** : https://docs.microsoft.com/en-us/windows/win32/api/wincred/

### Outils

- **DPAPIck** : Outil d'audit DPAPI
- **Mimikatz** : Pour tester la s√©curit√© (attention, outil de pentest)

## Conclusion

DPAPI est une solution puissante et native pour stocker des donn√©es sensibles sur Windows. Son int√©gration avec le syst√®me d'exploitation offre une s√©curit√© robuste sans la complexit√© de g√©rer manuellement les cl√©s de chiffrement.

**Points cl√©s** :
- üîí Chiffrement automatique bas√© sur l'identit√© de l'utilisateur
- üõ°Ô∏è Protection mat√©rielle possible via TPM
- üöÄ Simple √† utiliser avec seulement deux fonctions principales
- ‚öôÔ∏è Entropy additionnelle recommand√©e pour plus de s√©curit√©
- üíæ Credential Manager pour une gestion centralis√©e
- üîÑ N√©cessite une strat√©gie de sauvegarde/migration

Avec FreePascal, DPAPI peut √™tre facilement int√©gr√© dans vos applications Windows pour offrir un stockage s√©curis√© de niveau professionnel.

**Prochaine section** : 17.6.2 Keyring Linux/GNOME

‚è≠Ô∏è [Keyring Linux/GNOME](/17-securite-cryptographie/06.2-keyring-linux-gnome.md)
