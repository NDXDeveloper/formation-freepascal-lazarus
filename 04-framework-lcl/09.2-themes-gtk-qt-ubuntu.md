üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.9.2 Th√®mes GTK/Qt sur Ubuntu

## Introduction aux th√®mes Linux

Sur Ubuntu et les autres distributions Linux, le syst√®me de th√®mes est tr√®s diff√©rent de Windows. Au lieu d'un syst√®me unique, Linux offre plusieurs environnements de bureau (GNOME, KDE, XFCE, etc.), chacun avec son propre syst√®me de th√®mes. Les deux principaux frameworks d'interface graphique sont GTK (utilis√© par GNOME) et Qt (utilis√© par KDE), et votre application Lazarus peut utiliser l'un ou l'autre.

La beaut√© du syst√®me Linux est sa flexibilit√© : les utilisateurs peuvent compl√®tement transformer l'apparence de leur bureau, et votre application s'adaptera automatiquement si vous utilisez correctement les th√®mes.

## Comprendre GTK et Qt

### GTK (GIMP Toolkit)

GTK est le framework d'interface par d√©faut sur Ubuntu (avec GNOME). Il existe en plusieurs versions :
- **GTK2** : Stable, mature, largement support√©
- **GTK3** : Plus moderne, support CSS, animations
- **GTK4** : Le plus r√©cent, encore en √©volution

### Qt

Qt est principalement utilis√© sur KDE mais fonctionne partout. Il offre :
- Une apparence coh√©rente entre plateformes
- Un syst√®me de styles puissant (QSS)
- Une excellente int√©gration avec KDE

### Choisir entre GTK et Qt dans Lazarus

```pascal
// Dans les options du projet ou en ligne de commande
// Pour GTK2 :
// -ws=gtk2

// Pour GTK3 :
// -ws=gtk3

// Pour Qt5 :
// -ws=qt5

// Ou dans le code (moins recommand√©) :
{$IFDEF LINUX}
  {$DEFINE UseLCLGTK2}  // ou UseLCLGTK3, UseLCLQt5
{$ENDIF}
```

## Configuration des th√®mes GTK

### D√©tecter le th√®me GTK actuel

```pascal
uses
  glib2, gtk2, gdk2;

function GetCurrentGTKTheme: string;
var
  Settings: PGtkSettings;
  ThemeName: Pgchar;
begin
  Result := '';

  Settings := gtk_settings_get_default();
  if Assigned(Settings) then
  begin
    g_object_get(Settings, 'gtk-theme-name', @ThemeName, nil);
    if Assigned(ThemeName) then
    begin
      Result := StrPas(ThemeName);
      g_free(ThemeName);
    end;
  end;
end;

function GetGTKIconTheme: string;
var
  Settings: PGtkSettings;
  IconTheme: Pgchar;
begin
  Result := '';

  Settings := gtk_settings_get_default();
  if Assigned(Settings) then
  begin
    g_object_get(Settings, 'gtk-icon-theme-name', @IconTheme, nil);
    if Assigned(IconTheme) then
    begin
      Result := StrPas(IconTheme);
      g_free(IconTheme);
    end;
  end;
end;
```

### Appliquer un th√®me GTK sp√©cifique

```pascal
procedure SetGTKTheme(const ThemeName: string);
var
  Settings: PGtkSettings;
begin
  Settings := gtk_settings_get_default();
  if Assigned(Settings) then
  begin
    g_object_set(Settings, 'gtk-theme-name', PChar(ThemeName), nil);
  end;
end;

// Exemples de th√®mes populaires sur Ubuntu
procedure ApplyPopularTheme;
begin
  // Th√®me par d√©faut d'Ubuntu
  SetGTKTheme('Yaru');

  // Autres th√®mes populaires
  // SetGTKTheme('Adwaita');      // GNOME par d√©faut
  // SetGTKTheme('Arc');          // Th√®me moderne populaire
  // SetGTKTheme('Breeze');       // KDE/Qt style pour GTK
  // SetGTKTheme('Materia');      // Material Design
end;
```

### Configuration GTK2 avec gtkrc

Cr√©ez un fichier `~/.gtkrc-2.0` ou dans votre application :

```bash
# Fichier gtkrc-2.0 personnalis√©
gtk-theme-name = "Yaru"
gtk-icon-theme-name = "Yaru"
gtk-font-name = "Ubuntu 11"
gtk-cursor-theme-name = "Yaru"
gtk-toolbar-style = GTK_TOOLBAR_BOTH_HORIZ
gtk-toolbar-icon-size = GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images = 1
gtk-menu-images = 1
gtk-enable-event-sounds = 1
gtk-enable-input-feedback-sounds = 1
```

Charger depuis votre application :

```pascal
procedure LoadCustomGTKRC;
begin
  gtk_rc_parse(PChar(ExtractFilePath(ParamStr(0)) + 'custom.gtkrc'));
end;
```

### Configuration GTK3 avec CSS

GTK3 utilise CSS pour le style. Cr√©ez un fichier CSS personnalis√© :

```css
/* custom-theme.css */

/* Styles globaux */
window {
    background-color: #f5f5f5;
}

/* Boutons personnalis√©s */
button {
    background: linear-gradient(to bottom, #4a90e2, #357abd);
    color: white;
    border-radius: 4px;
    padding: 8px 16px;
    border: 1px solid #2968a3;
}

button:hover {
    background: linear-gradient(to bottom, #5ba0f2, #4080cd);
}

button:active {
    background: linear-gradient(to bottom, #357abd, #4a90e2);
}

/* Labels */
label {
    color: #333333;
    font-family: "Ubuntu", sans-serif;
    font-size: 14px;
}

/* Entries (zones de texte) */
entry {
    border: 1px solid #cccccc;
    border-radius: 3px;
    padding: 5px;
    background-color: white;
}

entry:focus {
    border-color: #4a90e2;
    box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
}

/* TreeView (listes) */
treeview {
    background-color: white;
    color: #333333;
}

treeview:selected {
    background-color: #4a90e2;
    color: white;
}
```

Appliquer le CSS dans votre application :

```pascal
uses
  gtk3;

procedure LoadGTK3CSS;
var
  Provider: PGtkCssProvider;
  Display: PGdkDisplay;
  Screen: PGdkScreen;
  Error: PGError;
  CSSFile: string;
begin
  Provider := gtk_css_provider_new();
  Display := gdk_display_get_default();
  Screen := gdk_display_get_default_screen(Display);

  CSSFile := ExtractFilePath(ParamStr(0)) + 'custom-theme.css';

  Error := nil;
  if gtk_css_provider_load_from_path(Provider, PChar(CSSFile), @Error) then
  begin
    gtk_style_context_add_provider_for_screen(
      Screen,
      PGtkStyleProvider(Provider),
      GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
    );
  end
  else
  begin
    if Assigned(Error) then
    begin
      WriteLn('Erreur CSS : ', Error^.message);
      g_error_free(Error);
    end;
  end;

  g_object_unref(Provider);
end;
```

## Configuration des th√®mes Qt

### D√©tecter et configurer le th√®me Qt

```pascal
uses
  Qt5;

function GetCurrentQtStyle: string;
begin
  Result := QApplication_style().className();
end;

procedure SetQtStyle(const StyleName: string);
begin
  QApplication_setStyle(QStyleFactory_create(PWideChar(StyleName)));
end;

procedure ListAvailableQtStyles;
var
  Styles: QStringList;
  i: Integer;
begin
  Styles := QStyleFactory_keys();

  WriteLn('Styles Qt disponibles :');
  for i := 0 to Styles.size - 1 do
    WriteLn('  - ', Styles.at(i));

  // Styles courants : Fusion, Windows, GTK+, Breeze
end;
```

### Qt Style Sheets (QSS)

Qt utilise un syst√®me similaire au CSS appel√© QSS :

```pascal
procedure ApplyQtStyleSheet;
const
  StyleSheet =
    'QMainWindow {' +
    '  background-color: #f5f5f5;' +
    '}' +
    'QPushButton {' +
    '  background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,' +
    '    stop: 0 #4a90e2, stop: 1 #357abd);' +
    '  border-style: solid;' +
    '  border-width: 1px;' +
    '  border-color: #2968a3;' +
    '  border-radius: 4px;' +
    '  padding: 8px 16px;' +
    '  color: white;' +
    '  font: bold 14px;' +
    '}' +
    'QPushButton:hover {' +
    '  background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,' +
    '    stop: 0 #5ba0f2, stop: 1 #4080cd);' +
    '}' +
    'QPushButton:pressed {' +
    '  background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,' +
    '    stop: 0 #357abd, stop: 1 #4a90e2);' +
    '}' +
    'QLineEdit {' +
    '  border: 1px solid #cccccc;' +
    '  border-radius: 3px;' +
    '  padding: 5px;' +
    '  background-color: white;' +
    '  selection-background-color: #4a90e2;' +
    '}' +
    'QLineEdit:focus {' +
    '  border: 1px solid #4a90e2;' +
    '}';
begin
  QApplication_setStyleSheet(PWideChar(StyleSheet));
end;
```

### Int√©gration avec KDE Plasma

```pascal
function IsKDEEnvironment: Boolean;
var
  Desktop: string;
begin
  Desktop := GetEnvironmentVariable('XDG_CURRENT_DESKTOP');
  Result := Pos('KDE', UpperCase(Desktop)) > 0;
end;

procedure ApplyKDEIntegration;
begin
  if IsKDEEnvironment then
  begin
    // Utiliser le style Breeze natif de KDE
    SetQtStyle('Breeze');

    // Ou suivre les pr√©f√©rences syst√®me
    QApplication_setDesktopSettingsAware(True);
  end;
end;
```

## D√©tection de l'environnement de bureau

```pascal
type
  TDesktopEnvironment = (
    deUnknown,
    deGNOME,
    deKDE,
    deXFCE,
    deLXDE,
    deLXQt,
    deMate,
    deCinnamon,
    deBudgie,
    deUnity
  );

function GetDesktopEnvironment: TDesktopEnvironment;
var
  Desktop: string;
begin
  Result := deUnknown;

  // M√©thode 1 : Variable XDG_CURRENT_DESKTOP
  Desktop := UpperCase(GetEnvironmentVariable('XDG_CURRENT_DESKTOP'));

  if Pos('GNOME', Desktop) > 0 then
    Result := deGNOME
  else if Pos('KDE', Desktop) > 0 then
    Result := deKDE
  else if Pos('XFCE', Desktop) > 0 then
    Result := deXFCE
  else if Pos('LXDE', Desktop) > 0 then
    Result := deLXDE
  else if Pos('LXQT', Desktop) > 0 then
    Result := deLXQt
  else if Pos('MATE', Desktop) > 0 then
    Result := deMate
  else if Pos('CINNAMON', Desktop) > 0 then
    Result := deCinnamon
  else if Pos('BUDGIE', Desktop) > 0 then
    Result := deBudgie
  else if Pos('UNITY', Desktop) > 0 then
    Result := deUnity
  else
  begin
    // M√©thode 2 : Variable DESKTOP_SESSION
    Desktop := UpperCase(GetEnvironmentVariable('DESKTOP_SESSION'));

    if Pos('GNOME', Desktop) > 0 then
      Result := deGNOME
    else if Pos('PLASMA', Desktop) > 0 then
      Result := deKDE
    // ... etc
  end;
end;

procedure AdaptToDesktopEnvironment;
begin
  case GetDesktopEnvironment of
    deGNOME:
      begin
        WriteLn('GNOME d√©tect√© - utilisation du th√®me Adwaita');
        // Configuration sp√©cifique GNOME
      end;
    deKDE:
      begin
        WriteLn('KDE d√©tect√© - utilisation du th√®me Breeze');
        // Configuration sp√©cifique KDE
      end;
    deXFCE:
      begin
        WriteLn('XFCE d√©tect√© - utilisation du th√®me Greybird');
        // Configuration sp√©cifique XFCE
      end;
  end;
end;
```

## Support du Dark Mode sur Ubuntu

### D√©tecter le th√®me sombre

```pascal
function IsGTKDarkTheme: Boolean;
var
  Settings: PGtkSettings;
  PreferDark: gboolean;
  ThemeName: Pgchar;
  ThemeStr: string;
begin
  Result := False;

  Settings := gtk_settings_get_default();
  if Assigned(Settings) then
  begin
    // GTK3+ : propri√©t√© prefer-dark-theme
    g_object_get(Settings, 'gtk-application-prefer-dark-theme', @PreferDark, nil);
    if PreferDark then
    begin
      Result := True;
      Exit;
    end;

    // V√©rifier le nom du th√®me
    g_object_get(Settings, 'gtk-theme-name', @ThemeName, nil);
    if Assigned(ThemeName) then
    begin
      ThemeStr := StrPas(ThemeName);
      g_free(ThemeName);

      // Les th√®mes sombres contiennent souvent "dark" dans leur nom
      Result := (Pos('dark', LowerCase(ThemeStr)) > 0) or
                (Pos('Dark', ThemeStr) > 0);
    end;
  end;
end;

function IsSystemDarkMode: Boolean;
begin
  // V√©rifier les settings GNOME
  Result := IsGTKDarkTheme;

  // Ou v√©rifier via gsettings
  // gsettings get org.gnome.desktop.interface gtk-theme
end;
```

### Appliquer un th√®me sombre

```pascal
procedure EnableDarkTheme(Enable: Boolean);
var
  Settings: PGtkSettings;
begin
  Settings := gtk_settings_get_default();
  if Assigned(Settings) then
  begin
    if Enable then
    begin
      // Activer le th√®me sombre
      g_object_set(Settings,
        'gtk-application-prefer-dark-theme', gboolean(1),
        'gtk-theme-name', PChar('Yaru-dark'),
        nil);
    end
    else
    begin
      // Revenir au th√®me clair
      g_object_set(Settings,
        'gtk-application-prefer-dark-theme', gboolean(0),
        'gtk-theme-name', PChar('Yaru'),
        nil);
    end;
  end;
end;
```

### Adaptation automatique au th√®me syst√®me

```pascal
type
  TThemeAdapter = class
  private
    FDarkMode: Boolean;
    FOnThemeChanged: TNotifyEvent;

    procedure CheckThemeChange;
  public
    constructor Create;

    procedure UpdateTheme;
    procedure ApplyToForm(Form: TForm);

    property DarkMode: Boolean read FDarkMode;
    property OnThemeChanged: TNotifyEvent read FOnThemeChanged write FOnThemeChanged;
  end;

procedure TThemeAdapter.UpdateTheme;
var
  NewDarkMode: Boolean;
begin
  NewDarkMode := IsGTKDarkTheme;

  if NewDarkMode <> FDarkMode then
  begin
    FDarkMode := NewDarkMode;

    if Assigned(FOnThemeChanged) then
      FOnThemeChanged(Self);
  end;
end;

procedure TThemeAdapter.ApplyToForm(Form: TForm);
begin
  if FDarkMode then
  begin
    // Couleurs sombres
    Form.Color := RGBToColor(40, 40, 40);
    Form.Font.Color := RGBToColor(240, 240, 240);
  end
  else
  begin
    // Couleurs claires
    Form.Color := clDefault;
    Form.Font.Color := clDefault;
  end;

  // Appliquer aux contr√¥les enfants
  ApplyThemeToControls(Form);
end;
```

## Gestion des ic√¥nes et th√®mes d'ic√¥nes

### Utiliser les ic√¥nes du th√®me syst√®me

```pascal
uses
  gtk2, gdk2pixbuf, glib2;

function LoadThemedIcon(const IconName: string; Size: Integer): TBitmap;
var
  IconTheme: PGtkIconTheme;
  Pixbuf: PGdkPixbuf;
  Error: PGError;
  Width, Height: Integer;
begin
  Result := TBitmap.Create;

  IconTheme := gtk_icon_theme_get_default();
  Error := nil;

  Pixbuf := gtk_icon_theme_load_icon(IconTheme, PChar(IconName),
                                     Size, GTK_ICON_LOOKUP_USE_BUILTIN, @Error);

  if Assigned(Pixbuf) then
  begin
    Width := gdk_pixbuf_get_width(Pixbuf);
    Height := gdk_pixbuf_get_height(Pixbuf);

    Result.SetSize(Width, Height);

    // Convertir le pixbuf en TBitmap
    ConvertPixbufToBitmap(Pixbuf, Result);

    g_object_unref(Pixbuf);
  end
  else
  begin
    if Assigned(Error) then
    begin
      WriteLn('Erreur chargement ic√¥ne : ', Error^.message);
      g_error_free(Error);
    end;
  end;
end;

// Exemples d'ic√¥nes standard
procedure LoadStandardIcons;
var
  OpenIcon, SaveIcon, CopyIcon: TBitmap;
begin
  OpenIcon := LoadThemedIcon('document-open', 24);
  SaveIcon := LoadThemedIcon('document-save', 24);
  CopyIcon := LoadThemedIcon('edit-copy', 24);

  // Utiliser les ic√¥nes...

  OpenIcon.Free;
  SaveIcon.Free;
  CopyIcon.Free;
end;
```

### Liste des ic√¥nes disponibles

```pascal
procedure ListAvailableIcons;
var
  IconTheme: PGtkIconTheme;
  Icons: PPgchar;
  i: Integer;
begin
  IconTheme := gtk_icon_theme_get_default();

  // Obtenir toutes les ic√¥nes
  Icons := gtk_icon_theme_list_icons(IconTheme, nil);

  i := 0;
  while Icons[i] <> nil do
  begin
    WriteLn(StrPas(Icons[i]));
    Inc(i);
  end;

  g_strfreev(Icons);
end;
```

## Personnalisation avanc√©e avec Cairo

Cairo est la biblioth√®que de dessin 2D utilis√©e par GTK. Elle permet des effets avanc√©s :

```pascal
uses
  Cairo;

procedure DrawCustomWidget(Canvas: TCanvas; Rect: TRect);
var
  cr: Pcairo_t;
  surface: Pcairo_surface_t;
begin
  // Cr√©er un contexte Cairo
  surface := cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
                                        Rect.Width, Rect.Height);
  cr := cairo_create(surface);

  // Dessiner un gradient
  var pattern := cairo_pattern_create_linear(0, 0, 0, Rect.Height);
  cairo_pattern_add_color_stop_rgba(pattern, 0, 0.2, 0.4, 0.8, 1);
  cairo_pattern_add_color_stop_rgba(pattern, 1, 0.1, 0.2, 0.6, 1);

  cairo_set_source(cr, pattern);
  cairo_rectangle(cr, 0, 0, Rect.Width, Rect.Height);
  cairo_fill(cr);

  // Dessiner du texte avec ombre
  cairo_select_font_face(cr, 'Ubuntu', CAIRO_FONT_SLANT_NORMAL,
                         CAIRO_FONT_WEIGHT_BOLD);
  cairo_set_font_size(cr, 18);

  // Ombre
  cairo_set_source_rgba(cr, 0, 0, 0, 0.5);
  cairo_move_to(cr, 11, 21);
  cairo_show_text(cr, 'Texte personnalis√©');

  // Texte
  cairo_set_source_rgba(cr, 1, 1, 1, 1);
  cairo_move_to(cr, 10, 20);
  cairo_show_text(cr, 'Texte personnalis√©');

  // Nettoyer
  cairo_pattern_destroy(pattern);
  cairo_destroy(cr);

  // Convertir en bitmap et dessiner
  ConvertCairoToCanvas(surface, Canvas, Rect);

  cairo_surface_destroy(surface);
end;
```

## Int√©gration avec les notifications Ubuntu

```pascal
uses
  Process;

procedure ShowUbuntuNotification(const Title, Message, Icon: string);
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    Process.Executable := 'notify-send';
    Process.Parameters.Add('-i');
    Process.Parameters.Add(Icon);  // Ex: 'dialog-information'
    Process.Parameters.Add(Title);
    Process.Parameters.Add(Message);
    Process.Execute;
  finally
    Process.Free;
  end;
end;

// Ou via libnotify
procedure ShowLibNotifyNotification(const Title, Message: string);
begin
  notify_init('MonApplication');

  var notification := notify_notification_new(PChar(Title),
                                              PChar(Message),
                                              'dialog-information');

  notify_notification_show(notification, nil);

  g_object_unref(notification);
  notify_uninit();
end;
```

## Gestion des polices syst√®me

```pascal
function GetSystemFonts: TStringList;
var
  FontMap: PPangoFontMap;
  Families: PPPangoFontFamily;
  nFamilies: gint;
  i: Integer;
begin
  Result := TStringList.Create;

  FontMap := pango_cairo_font_map_get_default();
  pango_font_map_list_families(FontMap, @Families, @nFamilies);

  for i := 0 to nFamilies - 1 do
  begin
    Result.Add(StrPas(pango_font_family_get_name(Families[i])));
  end;

  g_free(Families);
end;

function GetDefaultSystemFont: string;
var
  Settings: PGtkSettings;
  FontName: Pgchar;
begin
  Result := 'Ubuntu 11';  // D√©faut Ubuntu

  Settings := gtk_settings_get_default();
  if Assigned(Settings) then
  begin
    g_object_get(Settings, 'gtk-font-name', @FontName, nil);
    if Assigned(FontName) then
    begin
      Result := StrPas(FontName);
      g_free(FontName);
    end;
  end;
end;
```

## Adaptation aux diff√©rentes versions d'Ubuntu

```pascal
function GetUbuntuVersion: string;
var
  ReleaseFile: TStringList;
begin
  Result := 'Unknown';

  if FileExists('/etc/lsb-release') then
  begin
    ReleaseFile := TStringList.Create;
    try
      ReleaseFile.LoadFromFile('/etc/lsb-release');

      // Chercher DISTRIB_RELEASE=XX.XX
      for var Line in ReleaseFile do
      begin
        if Pos('DISTRIB_RELEASE=', Line) = 1 then
        begin
          Result := Copy(Line, Length('DISTRIB_RELEASE=') + 1, MaxInt);
          Break;
        end;
      end;
    finally
      ReleaseFile.Free;
    end;
  end;
end;

procedure AdaptToUbuntuVersion;
var
  Version: string;
begin
  Version := GetUbuntuVersion;

  if Version >= '20.04' then
  begin
    // Ubuntu 20.04+ utilise Yaru par d√©faut
    SetGTKTheme('Yaru');
  end
  else if Version >= '18.04' then
  begin
    // Ubuntu 18.04 utilise Ambiance
    SetGTKTheme('Ambiance');
  end
  else
  begin
    // Versions plus anciennes
    SetGTKTheme('Radiance');
  end;
end;
```

## Optimisation et performances

### Mise en cache des ressources th√©matiques

```pascal
type
  TThemeCache = class
  private
    FIconCache: TStringList;  // Nom -> TBitmap
    FColorCache: TStringList; // Nom -> TColor

  public
    constructor Create;
    destructor Destroy; override;

    function GetIcon(const Name: string; Size: Integer): TBitmap;
    function GetThemeColor(const Name: string): TColor;
    procedure Clear;
  end;

function TThemeCache.GetIcon(const Name: string; Size: Integer): TBitmap;
var
  Key: string;
  Index: Integer;
begin
  Key := Format('%s_%d', [Name, Size]);
  Index := FIconCache.IndexOf(Key);

  if Index >= 0 then
  begin
    Result := TBitmap(FIconCache.Objects[Index]);
  end
  else
  begin
    Result := LoadThemedIcon(Name, Size);
    FIconCache.AddObject(Key, Result);
  end;
end;
```

### R√©duction du scintillement

```pascal
procedure OptimizeGTKDrawing(Form: TForm);
begin
  // Double buffering
  Form.DoubleBuffered := True;

  // D√©sactiver les animations si n√©cessaire
  g_object_set(gtk_settings_get_default(),
    'gtk-enable-animations', gboolean(0),
    nil);
end;
```

## Bonnes pratiques pour les th√®mes GTK/Qt

### 1. Respecter les pr√©f√©rences utilisateur

```pascal
procedure RespectUserPreferences;
begin
  // Ne pas forcer un th√®me si l'utilisateur en a choisi un
  if not UserHasCustomTheme then
    ApplyDefaultTheme
  else
    UseSystemTheme;
end;
```

### 2. Tester sur diff√©rents environnements

```pascal
procedure TestOnEnvironments;
begin
  // Tester sur :
  // - Ubuntu avec GNOME
  // - Kubuntu avec KDE
  // - Xubuntu avec XFCE
  // - Lubuntu avec LXDE/LXQt
  // - Ubuntu MATE
  // - Linux Mint (Cinnamon)
end;
```

### 3. Fournir une option de th√®me

```pascal
type
  TThemeOption = (toSystem, toLight, toDark, toCustom);

procedure ApplyThemeOption(Option: TThemeOption);
begin
  case Option of
    toSystem: UseSystemTheme;
    toLight: SetGTKTheme('Yaru');
    toDark: SetGTKTheme('Yaru-dark');
    toCustom: LoadCustomTheme;
  end;
end;
```

## Points cl√©s √† retenir

1. **GTK vs Qt** : Choisissez selon votre environnement cible principal
2. **D√©tection automatique** : Identifiez l'environnement de bureau pour une meilleure int√©gration
3. **CSS/QSS** : Utilisez les feuilles de style pour une personnalisation fine
4. **Dark Mode** : De plus en plus important sur Linux aussi
5. **Ic√¥nes syst√®me** : Utilisez les ic√¥nes du th√®me pour la coh√©rence
6. **Cairo** : Pour des effets graphiques avanc√©s
7. **Performance** : Mettez en cache les ressources th√©matiques
8. **Flexibilit√©** : Offrez des options mais respectez les choix de l'utilisateur
9. **Tests** : Les environnements Linux sont tr√®s vari√©s, testez largement
10. **Documentation** : Les th√®mes Linux √©voluent rapidement, restez √† jour

Les th√®mes sur Ubuntu/Linux offrent une flexibilit√© incroyable. En ma√Ætrisant GTK et Qt, vous cr√©erez des applications qui s'int√®grent parfaitement dans n'importe quel environnement de bureau Linux tout en conservant leur identit√© visuelle unique !

‚è≠Ô∏è [Accessibilit√© et support des lecteurs d'√©cran](/04-framework-lcl/10-accessibilite-support-lecteurs-ecran.md)
