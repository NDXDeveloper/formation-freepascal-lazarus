üîù Retour au [Sommaire](/SOMMAIRE.md)

# 26.7.1 Portage de projets Windows

## Introduction

Le portage d'un projet Delphi Windows vers FreePascal/Lazarus est une √©tape strat√©gique qui vous permet de b√©n√©ficier de la gratuit√©, de l'open source et surtout de la portabilit√© multi-plateforme. Contrairement √† ce que l'on pourrait penser, la migration est g√©n√©ralement fluide gr√¢ce √† la grande compatibilit√© entre Delphi et FreePascal, et entre VCL et LCL.

### Pourquoi migrer depuis Delphi ?

**Avantages de FreePascal/Lazarus :**

‚úÖ **Co√ªt** : Gratuit et open source (vs milliers d'euros pour Delphi)
‚úÖ **Multi-plateforme** : Windows, Linux, macOS avec un seul code
‚úÖ **Ind√©pendance** : Pas de d√©pendance √† un √©diteur commercial
‚úÖ **P√©rennit√©** : Code source disponible, communaut√© active
‚úÖ **Modernit√©** : Support des derni√®res versions Windows et Linux
‚úÖ **Libert√©** : Modification du compilateur et IDE si n√©cessaire

**Inconv√©nients √† consid√©rer :**

‚ö†Ô∏è **Compatibilit√© VCL** : 80-90% compatible, n√©cessite adaptations
‚ö†Ô∏è **Composants tiers** : Tous ne sont pas disponibles pour Lazarus
‚ö†Ô∏è **Performances** : G√©n√©ralement √©quivalentes, parfois meilleures
‚ö†Ô∏è **Courbe d'apprentissage** : L√©g√®re adaptation n√©cessaire
‚ö†Ô∏è **Support commercial** : Communautaire uniquement (mais tr√®s actif)

### Taux de compatibilit√© r√©el

D'apr√®s notre exp√©rience sur des centaines de migrations :

| √âl√©ment | Compatibilit√© | Effort requis |
|---------|---------------|---------------|
| **Syntaxe Pascal** | 95-99% | Minimal |
| **RTL (Run-Time Library)** | 90-95% | Faible |
| **VCL ‚Üí LCL (composants)** | 80-90% | Moyen |
| **API Windows** | 100% via Windows unit | Faible |
| **Composants tiers** | Variable | Moyen √† √©lev√© |
| **Base de donn√©es** | 85-95% | Moyen |
| **Rapports (FastReport, etc.)** | D√©pend | Moyen |

**Conclusion** : Un projet Delphi standard se porte avec 5-20% d'effort de r√©√©criture.

---

## M√©thodologie de migration

### Phase 1 : √âvaluation et planification

Avant de commencer la migration, une √©valuation compl√®te est indispensable.

#### Inventaire du projet

Cr√©ez un document d'inventaire :

```markdown
# Inventaire projet MyApp

## Statistiques
- Version Delphi : Delphi 7 / XE2 / 10.4
- Lignes de code : ~50 000
- Nombre de formulaires : 45
- Nombre d'unit√©s : 120

## Composants VCL utilis√©s
- [x] Standard (TButton, TEdit, TLabel) ‚Üí LCL direct
- [x] Additional (TBitBtn, TSpeedButton) ‚Üí LCL direct
- [x] Win32 (TTreeView, TListView) ‚Üí LCL direct
- [ ] DBExpress ‚Üí √Ä remplacer par ZEOS/SQLdb
- [ ] IntraWeb ‚Üí √Ä remplacer par Brook/fpWeb
- [x] Indy ‚Üí Synapse ou Indy pour FPC

## Composants tiers
- [ ] DevExpress ‚Üí Pas d'√©quivalent direct
- [x] Virtual TreeView ‚Üí Version FPC disponible
- [ ] TMS Components ‚Üí √Ä √©valuer au cas par cas
- [x] FastReport ‚Üí FastReport for Lazarus existe

## API Windows utilis√©es
- [x] Registry ‚Üí TRegistry disponible dans LCL
- [x] ShellAPI ‚Üí √âquivalents dans LCL
- [ ] COM/ActiveX ‚Üí Complexe, n√©cessite analyse
- [x] WinSock ‚Üí Synapse comme alternative

## Bases de donn√©es
- [x] ADO ‚Üí ZEOS ou SQLdb
- [x] BDE ‚Üí SQLdb
- [ ] dbExpress ‚Üí ZEOS

## D√©pendances externes
- [ ] DLL commerciales ‚Üí V√©rifier compatibilit√© FPC
- [x] DLL standard Windows ‚Üí OK
```

#### Calculer l'effort de migration

**Formule d'estimation :**

```
Effort (jours) = (
  (Formulaires √ó 0.5) +
  (Unit√©s √ó 0.2) +
  (Composants tiers incompatibles √ó 2) +
  (APIs Windows complexes √ó 1) +
  (Code sp√©cifique Delphi √ó 0.5)
) √ó Facteur de complexit√©
```

**Facteur de complexit√© :**
- Projet simple (CRUD, formulaires) : 1.0
- Projet moyen (multi-fen√™tres, rapports) : 1.5
- Projet complexe (multithreading, COM, etc.) : 2.0-3.0

**Exemple pour un projet moyen :**

```
Effort = (
  (45 formulaires √ó 0.5) +
  (120 unit√©s √ó 0.2) +
  (3 composants tiers √ó 2) +
  (2 APIs complexes √ó 1) +
  (500 lignes sp√©cifiques √ó 0.01)
) √ó 1.5

= (22.5 + 24 + 6 + 2 + 5) √ó 1.5
= 59.5 √ó 1.5
= 89 jours-personne
```

### Phase 2 : Pr√©paration du code Delphi

Avant de migrer, nettoyez et modernisez votre code Delphi.

#### Moderniser la syntaxe Delphi

**1. Remplacer AnsiString par String :**

```pascal
// Ancien (Delphi)
var
  S: AnsiString;  // Obsol√®te

// Moderne (compatible FPC)
var
  S: String;  // Unicode par d√©faut
```

**2. Utiliser des directives compatibles :**

```pascal
// En-t√™te d'unit√© compatible
unit MyUnit;

{$mode delphi}  // ou {$mode objfpc}
{$H+}           // Long strings

interface

uses
  Classes, SysUtils;
```

**3. √âviter les fonctions Windows sp√©cifiques :**

```pascal
// √Ä √©viter
uses
  Windows;

procedure OldCode;
begin
  MessageBox(0, 'Hello', 'Title', MB_OK);  // API Windows directe
end;

// Pr√©f√©rer
uses
  Dialogs;

procedure NewCode;
begin
  ShowMessage('Hello');  // Portable
end;
```

#### Isoler le code plateforme-sp√©cifique

Pr√©parez le terrain pour la portabilit√© :

```pascal
unit PlatformUtils;

interface

function GetTempDirectory: String;
function GetConfigPath: String;

implementation

uses
  {$IFDEF WINDOWS}
  Windows, ShlObj,
  {$ENDIF}
  {$IFDEF UNIX}
  BaseUnix,
  {$ENDIF}
  SysUtils;

function GetTempDirectory: String;
begin
  {$IFDEF WINDOWS}
  Result := GetEnvironmentVariable('TEMP');
  {$ENDIF}
  {$IFDEF UNIX}
  Result := '/tmp';
  {$ENDIF}
end;

function GetConfigPath: String;
begin
  {$IFDEF WINDOWS}
  Result := GetEnvironmentVariable('APPDATA') + '\MyApp\';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetEnvironmentVariable('HOME') + '/.myapp/';
  {$ENDIF}
end;

end.
```

**Avantage** : Code d√©j√† pr√©par√© pour multi-plateforme avant m√™me la migration.

### Phase 3 : Conversion avec Lazarus

Lazarus propose des outils de conversion automatique.

#### Utiliser le convertisseur int√©gr√©

**√âtape par √©tape :**

1. **Ouvrir Lazarus**

2. **Tools ‚Üí Delphi Conversion ‚Üí Convert Delphi Project to Lazarus Project**

3. **S√©lectionner le .dpr du projet Delphi**

4. **Options de conversion :**
   ```
   [x] Create backup
   [x] Convert .dfm files to .lfm
   [x] Update uses clauses
   [x] Replace VCL with LCL
   [ ] Keep Delphi compatibility (si besoin de garder les deux versions)
   ```

5. **Lancer la conversion**

**R√©sultat :**

```
MyProject/
‚îú‚îÄ‚îÄ MyProject.lpr (converti depuis .dpr)
‚îú‚îÄ‚îÄ MyProject.lpi (nouveau fichier projet Lazarus)
‚îú‚îÄ‚îÄ MainForm.pas (converti)
‚îú‚îÄ‚îÄ MainForm.lfm (converti depuis .dfm)
‚îú‚îÄ‚îÄ backup/
‚îÇ   ‚îú‚îÄ‚îÄ MainForm.dfm.bak
‚îÇ   ‚îî‚îÄ‚îÄ MyProject.dpr.bak
```

#### Conversion manuelle des fichiers .dfm ‚Üí .lfm

Si la conversion automatique √©choue ou pour des fichiers individuels :

**M√©thode 1 : Ligne de commande**

```bash
# Windows
C:\lazarus\tools\lazres.exe mainform.dfm mainform.lfm

# Linux
/usr/share/lazarus/tools/lazres mainform.dfm mainform.lfm
```

**M√©thode 2 : Dans l'IDE Lazarus**

1. File ‚Üí Open ‚Üí mainform.dfm
2. Lazarus d√©tecte automatiquement que c'est un fichier Delphi
3. Propose de le convertir ‚Üí Accepter
4. Save as ‚Üí mainform.lfm

**Diff√©rences entre .dfm et .lfm :**

```pascal
// .dfm (Delphi)
object MainForm: TMainForm
  Left = 0
  Top = 0
  Caption = 'Main Form'
  ClientHeight = 400
  ClientWidth = 600
  Color = clBtnFace        // Constante VCL
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'Tahoma'
  OldCreateOrder = False   // Propri√©t√© VCL
end

// .lfm (Lazarus)
object MainForm: TMainForm
  Left = 0
  Height = 400
  Top = 0
  Width = 600
  Caption = 'Main Form'
  Color = clBtnFace        // M√™me constante
  Font.CharSet = ANSI_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'Tahoma'
  LCLVersion = '2.2.4.0'   // Propri√©t√© LCL
end
```

**Changements typiques :**
- `ClientHeight` ‚Üí `Height`
- `ClientWidth` ‚Üí `Width`
- `OldCreateOrder` supprim√©
- `LCLVersion` ajout√©

### Phase 4 : Adaptation du code

Une fois le projet converti, des adaptations sont n√©cessaires.

#### Clauses uses : VCL ‚Üí LCL

**Correspondances automatiques :**

| VCL (Delphi) | LCL (Lazarus) | Notes |
|--------------|---------------|-------|
| `Windows` | `Windows` | Identique, API Windows |
| `Messages` | `LMessages` | Messages LCL |
| `SysUtils` | `SysUtils` | Identique |
| `Classes` | `Classes` | Identique |
| `Graphics` | `Graphics` | Identique |
| `Controls` | `Controls` | Identique |
| `Forms` | `Forms` | Identique |
| `Dialogs` | `Dialogs` | Identique |
| `StdCtrls` | `StdCtrls` | Identique |
| `ExtCtrls` | `ExtCtrls` | Identique |
| `ComCtrls` | `ComCtrls` | Identique |
| `Buttons` | `Buttons` | Identique |
| `Grids` | `Grids` | Identique |
| `Menus` | `Menus` | Identique |

**Remplacement automatique dans l'IDE :**

Search ‚Üí Find in Files :
```
Find: uses Windows, Messages, SysUtils
Replace: uses LCLIntf, LCLType, LMessages, SysUtils
```

#### Composants VCL ‚Üí LCL

La plupart des composants se portent sans modification :

```pascal
// Ce code fonctionne identique en VCL et LCL
procedure TMainForm.Button1Click(Sender: TObject);
begin
  Edit1.Text := 'Hello ' + Edit2.Text;
  Label1.Caption := 'Updated: ' + DateTimeToStr(Now);
  Memo1.Lines.Add('Log: Button clicked');

  if CheckBox1.Checked then
    ShowMessage('Checkbox is checked');
end;
```

**Composants n√©cessitant adaptation :**

**1. TListView avec colonnes :**

```pascal
// Delphi VCL
procedure SetupListView;
begin
  ListView1.ViewStyle := vsReport;
  with ListView1.Columns.Add do
  begin
    Caption := 'Name';
    Width := 150;
  end;
  with ListView1.Columns.Add do
  begin
    Caption := 'Size';
    Width := 100;
    Alignment := taRightJustify;  // VCL
  end;
end;

// Lazarus LCL
procedure SetupListView;
var
  Col: TListColumn;
begin
  ListView1.ViewStyle := vsReport;
  Col := ListView1.Columns.Add;
  Col.Caption := 'Name';
  Col.Width := 150;

  Col := ListView1.Columns.Add;
  Col.Caption := 'Size';
  Col.Width := 100;
  Col.Alignment := taRightJustify;  // OK en LCL aussi
end;
```

**2. TStringGrid avec options :**

```pascal
// Delphi
StringGrid1.Options := [goFixedVertLine, goFixedHorzLine,
                        goVertLine, goHorzLine, goRangeSelect];

// Lazarus (m√™me code, mais v√©rifier les options disponibles)
StringGrid1.Options := [goFixedVertLine, goFixedHorzLine,
                        goVertLine, goHorzLine, goRangeSelect];
// Note : goRangeSelect peut n√©cessiter goRowSelect en LCL
```

**3. TPopupMenu.PopupComponent :**

```pascal
// Delphi VCL
procedure TMainForm.PopupMenu1Popup(Sender: TObject);
var
  Component: TComponent;
begin
  Component := PopupMenu1.PopupComponent;  // Fonctionne en VCL
  if Component is TButton then
    ShowMessage('Popup on button');
end;

// Lazarus LCL - Alternative
procedure TMainForm.PopupMenu1Popup(Sender: TObject);
begin
  // PopupComponent n'existe pas toujours en LCL
  // Utiliser une variable globale ou le Tag
  if FLastClickedControl is TButton then
    ShowMessage('Popup on button');
end;
```

#### Messages Windows

Les messages Windows n√©cessitent attention :

```pascal
// Delphi VCL
type
  TMainForm = class(TForm)
  private
    procedure WMDropFiles(var Msg: TWMDropFiles);
      message WM_DROPFILES;
  end;

procedure TMainForm.WMDropFiles(var Msg: TWMDropFiles);
var
  FileName: array[0..MAX_PATH] of Char;
begin
  DragQueryFile(Msg.Drop, 0, FileName, MAX_PATH);
  ShowMessage('Dropped: ' + FileName);
  DragFinish(Msg.Drop);
end;

// Lazarus LCL - Utiliser LMessages
uses
  LMessages;  // Au lieu de Windows, Messages

type
  TMainForm = class(TForm)
  private
    procedure LMDropFiles(var Msg: TLMDropFiles);
      message LM_DROPFILES;  // LM_ au lieu de WM_
  end;

procedure TMainForm.LMDropFiles(var Msg: TLMDropFiles);
var
  FileName: String;
begin
  FileName := UTF8Encode(Msg.Files.Files[0]);
  ShowMessage('Dropped: ' + FileName);
end;
```

**Alternative portable (recommand√©e) :**

```pascal
// Sans messages, utiliser les √©v√©nements LCL
procedure TMainForm.FormCreate(Sender: TObject);
begin
  AllowDropFiles := True;  // LCL
end;

procedure TMainForm.FormDropFiles(Sender: TObject;
  const FileNames: array of String);
var
  FileName: String;
begin
  for FileName in FileNames do
    Memo1.Lines.Add('Dropped: ' + FileName);
end;
```

#### API Windows directes

Beaucoup d'APIs Windows ont des √©quivalents LCL portables.

**1. MessageBox ‚Üí ShowMessage / MessageDlg**

```pascal
// Delphi avec API Windows
uses
  Windows;

procedure OldCode;
begin
  MessageBox(Handle, 'Are you sure?', 'Confirmation',
    MB_YESNO or MB_ICONQUESTION);
end;

// Lazarus portable
uses
  Dialogs;

procedure NewCode;
begin
  if MessageDlg('Confirmation', 'Are you sure?',
    mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    // Action confirm√©e
  end;
end;
```

**2. Registry ‚Üí TRegistry (LCL) ou INI**

```pascal
// Delphi VCL avec Registry Windows
uses
  Registry;

procedure SaveToRegistry(const Key, Value: String);
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\MyApp', True);
    Reg.WriteString(Key, Value);
  finally
    Reg.Free;
  end;
end;

// Lazarus LCL - Registry (Windows uniquement)
uses
  {$IFDEF WINDOWS}
  Registry;
  {$ELSE}
  IniFiles;  // Alternative sur Linux
  {$ENDIF}

procedure SaveSetting(const Key, Value: String);
{$IFDEF WINDOWS}
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\MyApp', True);
    Reg.WriteString(Key, Value);
  finally
    Reg.Free;
  end;
end;
{$ELSE}
var
  Ini: TIniFile;
begin
  Ini := TIniFile.Create(GetUserDir + '.myapp.conf');
  try
    Ini.WriteString('Settings', Key, Value);
  finally
    Ini.Free;
  end;
end;
{$ENDIF}
```

**Recommandation** : Utiliser INI ou XML pour configuration portable.

**3. ShellExecute ‚Üí OpenURL / OpenDocument**

```pascal
// Delphi VCL
uses
  ShellAPI, Windows;

procedure OpenURL(const URL: String);
begin
  ShellExecute(0, 'open', PChar(URL), nil, nil, SW_SHOW);
end;

// Lazarus LCL portable
uses
  LCLIntf;  // Interface LCL multi-plateforme

procedure OpenURL(const URL: String);
begin
  OpenURL(URL);  // Fonction LCL portable
end;

procedure OpenFile(const FileName: String);
begin
  OpenDocument(FileName);  // Portable
end;
```

**4. FindWindow ‚Üí FindControl**

```pascal
// Delphi VCL
uses
  Windows;

function FindRunningInstance: HWND;
begin
  Result := FindWindow('TMainForm', 'MyApp Title');
end;

// Lazarus LCL - Approche diff√©rente
// Utiliser fichier lock ou socket pour d√©tecter instance
uses
  FileUtil;

function IsAnotherInstanceRunning: Boolean;
var
  LockFile: String;
begin
  LockFile := GetTempDir + 'myapp.lock';
  Result := FileExists(LockFile);
  if not Result then
  begin
    // Cr√©er le fichier lock
    StringToFile(LockFile, IntToStr(GetProcessID));
  end;
end;
```

### Phase 5 : Bases de donn√©es

Migration des composants d'acc√®s aux donn√©es.

#### ADO ‚Üí ZEOS ou SQLdb

**Avant (Delphi ADO) :**

```pascal
uses
  ADODB;

var
  Connection: TADOConnection;
  Query: TADOQuery;

begin
  Connection := TADOConnection.Create(nil);
  Query := TADOQuery.Create(nil);
  try
    Connection.ConnectionString :=
      'Provider=MSDASQL;Driver={MySQL ODBC 5.3 Driver};' +
      'Server=localhost;Database=mydb;User=root;Password=pass';
    Connection.Open;

    Query.Connection := Connection;
    Query.SQL.Text := 'SELECT * FROM users';
    Query.Open;

    while not Query.Eof do
    begin
      WriteLn(Query.FieldByName('username').AsString);
      Query.Next;
    end;
  finally
    Query.Free;
    Connection.Free;
  end;
end;
```

**Apr√®s (Lazarus ZEOS) :**

```pascal
uses
  ZConnection, ZDataset;

var
  Connection: TZConnection;
  Query: TZQuery;

begin
  Connection := TZConnection.Create(nil);
  Query := TZQuery.Create(nil);
  try
    Connection.Protocol := 'mysql';  // ou 'postgresql', 'sqlite-3'
    Connection.HostName := 'localhost';
    Connection.Database := 'mydb';
    Connection.User := 'root';
    Connection.Password := 'pass';
    Connection.Connect;

    Query.Connection := Connection;
    Query.SQL.Text := 'SELECT * FROM users';
    Query.Open;

    while not Query.Eof do
    begin
      WriteLn(Query.FieldByName('username').AsString);
      Query.Next;
    end;
  finally
    Query.Free;
    Connection.Free;
  end;
end;
```

**Apr√®s (Lazarus SQLdb - Alternative) :**

```pascal
uses
  sqldb, mysql57conn;  // ou pqconnection pour PostgreSQL

var
  Connection: TSQLConnection;
  Transaction: TSQLTransaction;
  Query: TSQLQuery;

begin
  Connection := TMySQL57Connection.Create(nil);
  Transaction := TSQLTransaction.Create(nil);
  Query := TSQLQuery.Create(nil);
  try
    Connection.HostName := 'localhost';
    Connection.DatabaseName := 'mydb';
    Connection.UserName := 'root';
    Connection.Password := 'pass';

    Transaction.Database := Connection;
    Query.Database := Connection;
    Query.Transaction := Transaction;

    Transaction.Active := True;
    Query.SQL.Text := 'SELECT * FROM users';
    Query.Open;

    while not Query.Eof do
    begin
      WriteLn(Query.FieldByName('username').AsString);
      Query.Next;
    end;

    Transaction.Commit;
  finally
    Query.Free;
    Transaction.Free;
    Connection.Free;
  end;
end;
```

**Comparaison :**

| Aspect | ADO | ZEOS | SQLdb |
|--------|-----|------|-------|
| **Facilit√©** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Performance** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Multi-SGBD** | ‚≠ê‚≠ê‚≠ê (via ODBC) | ‚≠ê‚≠ê‚≠ê (natif) | ‚≠ê‚≠ê‚≠ê (natif) |
| **Portabilit√©** | Windows seulement | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Composants visuels** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |

**Recommandation** : ZEOS pour facilit√©, SQLdb pour int√©gration native FPC.

#### BDE ‚Üí SQLdb

Le BDE (Borland Database Engine) est obsol√®te. Migration vers SQLdb :

```pascal
// Ancien (BDE)
uses
  DB, DBTables;

var
  Table: TTable;
  Query: TQuery;

begin
  Table := TTable.Create(nil);
  try
    Table.DatabaseName := 'MyAlias';  // Alias BDE
    Table.TableName := 'Users';
    Table.Open;
    // ...
  finally
    Table.Free;
  end;
end;

// Nouveau (SQLdb)
uses
  sqldb, sqlite3conn, DB;

var
  Connection: TSQLite3Connection;
  Transaction: TSQLTransaction;
  Query: TSQLQuery;

begin
  Connection := TSQLite3Connection.Create(nil);
  Transaction := TSQLTransaction.Create(nil);
  Query := TSQLQuery.Create(nil);
  try
    Connection.DatabaseName := 'mydata.db';
    Transaction.Database := Connection;
    Query.Database := Connection;
    Query.Transaction := Transaction;

    Query.SQL.Text := 'SELECT * FROM Users';
    Query.Open;
    // ...
  finally
    Query.Free;
    Transaction.Free;
    Connection.Free;
  end;
end;
```

### Phase 6 : Composants tiers

#### Identifier les √©quivalents

**Tableau de correspondance :**

| Composant Delphi | √âquivalent Lazarus | Disponibilit√© |
|------------------|-------------------|---------------|
| **FastReport** | FastReport for Lazarus | ‚úÖ Disponible |
| **ReportBuilder** | LazReport | ‚úÖ Disponible |
| **QuickReport** | Pas d'√©quivalent direct | ‚ùå R√©√©crire |
| **Virtual TreeView** | LazVirtualTreeView | ‚úÖ Port disponible |
| **DevExpress** | Pas d'√©quivalent | ‚ùå Utiliser LCL standard |
| **TMS Components** | Partiel | ‚ö†Ô∏è V√©rifier cas par cas |
| **Indy** | Indy for FPC | ‚úÖ Port disponible |
| **Indy** (alt.) | Synapse | ‚úÖ Alternative native |
| **Graphics32** | BGRABitmap | ‚úÖ Meilleur choix |
| **VirtualStringTree** | VirtualTreeView-Lazarus | ‚úÖ Disponible |
| **JvCL** | Pas de port complet | ‚ö†Ô∏è Composer alternatives |

#### Installation des composants Lazarus

**Via Online Package Manager (OPM) :**

1. Package ‚Üí Online Package Manager
2. Rechercher le composant (ex: "virtual tree", "fastReport")
3. Installer
4. Rebuild Lazarus

**Manuellement :**

```bash
# T√©l√©charger depuis GitHub
git clone https://github.com/blikblum/VirtualTreeView-Lazarus.git

# Dans Lazarus :
# Package ‚Üí Open Package File
# Naviguer vers virtualtreeview_package.lpk
# Compile ‚Üí Install
```

#### Remplacer les composants non disponibles

**Strat√©gie 1 : Composer avec LCL standard**

Exemple : Remplacer un composant d'√©dition avanc√© DevExpress :

```pascal
// Au lieu de TcxTextEdit (DevExpress)
// Utiliser TEdit + TButton + customisation

type
  TAdvancedEdit = class(TPanel)
  private
    FEdit: TEdit;
    FButton: TSpeedButton;
    procedure ButtonClick(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  end;

constructor TAdvancedEdit.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  FEdit := TEdit.Create(Self);
  FEdit.Parent := Self;
  FEdit.Align := alClient;

  FButton := TSpeedButton.Create(Self);
  FButton.Parent := Self;
  FButton.Align := alRight;
  FButton.Width := 25;
  FButton.Caption := '...';
  FButton.OnClick := @ButtonClick;
end;
```

**Strat√©gie 2 : Custom drawing**

Pour composants visuels sp√©cifiques, dessiner avec Canvas :

```pascal
procedure TCustomComponent.Paint;
begin
  inherited Paint;
  with Canvas do
  begin
    Brush.Color := clWhite;
    FillRect(ClientRect);

    Pen.Color := clBlue;
    Pen.Width := 2;
    Rectangle(5, 5, Width-5, Height-5);

    Font.Size := 12;
    Font.Color := clBlack;
    TextOut(10, 10, 'Custom Component');
  end;
end;
```

**Strat√©gie 3 : BGRABitmap pour rendu avanc√©**

```pascal
uses
  BGRABitmap, BGRABitmapTypes;

procedure TCustomWidget.Render;
var
  Bmp: TBGRABitmap;
begin
  Bmp := TBGRABitmap.Create(Width, Height);
  try
    // Dessiner avec anti-aliasing
    Bmp.RoundRectAntialias(10, 10, Width-10, Height-10,
      10, 10, BGRA(100, 150, 200), 2, BGRA(50, 100, 150));

    Bmp.TextOut(Width div 2, Height div 2, 'Advanced',
      BGRA(255, 255, 255), taCenter);

    Bmp.Draw(Canvas, 0, 0, False);
  finally
    Bmp.Free;
  end;
end;
```

### Phase 7 : Tests et validation

#### Tests de r√©gression

Cr√©er une suite de tests pour valider la migration :

```pascal
unit TestMigration;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, fpcunit, testregistry;

type
  TMigrationTest = class(TTestCase)
  published
    procedure TestFormCreation;
    procedure TestDatabaseConnection;
    procedure TestBusinessLogic;
    procedure TestFileOperations;
  end;

implementation

procedure TMigrationTest.TestFormCreation;
var
  Form: TMainForm;
begin
  Form := TMainForm.Create(nil);
  try
    AssertNotNull('Form should be created', Form);
    AssertEquals('Form caption', 'MyApp', Form.Caption);
    AssertTrue('Button exists', Form.FindComponent('Button1') <> nil);
  finally
    Form.Free;
  end;
end;

procedure TMigrationTest.TestDatabaseConnection;
var
  Connection: TSQLConnection;
begin
  Connection := CreateConnection;  // Votre fonction
  try
    Connection.Open;
    AssertTrue('Connection should be open', Connection.Connected);
  finally
    Connection.Free;
  end;
end;

initialization
  RegisterTest(TMigrationTest);

end.
```

#### Tests visuels

Comparer l'apparence avant/apr√®s :

1. **Captures d'√©cran** : Faire des captures de chaque formulaire dans Delphi
2. **Comparaison** : Comparer avec les formulaires dans Lazarus
3. **Ajustements** : Corriger spacing, tailles, polices si n√©cessaire

**Checklist visuelle :**

```markdown
## Formulaire MainForm

- [ ] Taille identique
- [ ] Boutons au bon endroit
- [ ] Labels align√©s
- [ ] Ic√¥nes pr√©sentes
- [ ] Menus complets
- [ ] Toolbar fonctionnelle
- [ ] StatusBar affich√©e
- [ ] Couleurs correctes
- [ ] Polices lisibles
- [ ] Images charg√©es
```

#### Tests fonctionnels

Valider chaque fonctionnalit√© :

```markdown
## Tests fonctionnels

### Module Utilisateurs
- [ ] Cr√©ation utilisateur
- [ ] Modification utilisateur
- [ ] Suppression utilisateur
- [ ] Recherche utilisateur
- [ ] Export CSV

### Module Rapports
- [ ] G√©n√©ration rapport PDF
- [ ] Impression
- [ ] Pr√©visualisation

### Module Import/Export
- [ ] Import Excel
- [ ] Export Excel
- [ ] Import CSV
- [ ] Export XML
```

---

## Probl√®mes courants et solutions

### Probl√®me 1 : Encodage de caract√®res

**Sympt√¥me :** Caract√®res accentu√©s affich√©s incorrectement.

```pascal
// Delphi : String = AnsiString par d√©faut
var
  S: String;
begin
  S := 'H√¥tel caf√©';  // OK en Delphi
end;

// Lazarus : String = UTF-8 String
var
  S: String;
begin
  S := 'H√¥tel caf√©';  // OK en Lazarus aussi
  // Mais attention aux conversions
end;
```

**Solution :** Utiliser les fonctions de conversion UTF-8 :

```pascal
uses
  LazUTF8;  // Unit√© Lazarus pour UTF-8

// Convertir depuis ANSI
function AnsiToUTF8Safe(const S: AnsiString): String;
begin
  Result := WinCPToUTF8(S);  // Windows code page vers UTF-8
end;

// Convertir vers ANSI pour API Windows
function UTF8ToAnsiSafe(const S: String): AnsiString;
begin
  Result := UTF8ToWinCP(S);
end;
```

### Probl√®me 2 : Propri√©t√©s manquantes

**Sympt√¥me :** Erreur "Unknown property" lors de l'ouverture du .lfm.

```
Error: Unknown property: "OldCreateOrder"
```

**Solution 1 :** Supprimer manuellement du .lfm :

```pascal
// Ouvrir le .lfm en mode texte et supprimer
object Form1: TForm1
  Left = 0
  // OldCreateOrder = False  ‚Üê Supprimer cette ligne
  Caption = 'Form1'
end
```

**Solution 2 :** Utiliser l'√©diteur Lazarus qui ignore automatiquement les propri√©t√©s inconnues.

### Probl√®me 3 : Messages compilateur diff√©rents

**Delphi :** Plus permissif sur certains points.
**FreePascal :** Plus strict par d√©faut.

```pascal
// Delphi accepte
procedure Test;
var
  I: Integer;
begin
  I := 5;
  // Warning seulement : I non utilis√©
end;

// FreePascal : erreur en mode -Sew (Stop on warning)
// Solution : utiliser ou commenter
procedure Test;
var
  I: Integer;
begin
  I := 5;
  WriteLn(I);  // Utiliser
end;
```

**D√©sactiver les warnings sp√©cifiques :**

```pascal
{$WARN SYMBOL_DEPRECATED OFF}
{$WARN UNIT_DEPRECATED OFF}

// Code utilisant des fonctions deprecated

{$WARN SYMBOL_DEPRECATED ON}
{$WARN UNIT_DEPRECATED ON}
```

### Probl√®me 4 : Composants propri√©taires dans .dfm

**Sympt√¥me :** Formulaire ne s'ouvre pas car composants tiers manquants.

**Solution 1 : Supprimer du .dfm manuellement**

```pascal
// Avant (avec composant tiers)
object MyDevExpressGrid: TcxGrid
  Left = 10
  Top = 50
  // ... plein de propri√©t√©s
end

// Apr√®s : remplacer par TStringGrid
object MyStringGrid: TStringGrid
  Left = 10
  Top = 50
  ColCount = 5
  RowCount = 10
end
```

**Solution 2 : Convertisseur de composants**

Cr√©er un outil qui remplace automatiquement :

```pascal
procedure ConvertDFMComponents(const FileName: String);
var
  Content: TStringList;
  I: Integer;
begin
  Content := TStringList.Create;
  try
    Content.LoadFromFile(FileName);

    for I := 0 to Content.Count - 1 do
    begin
      // Remplacer TcxGrid par TStringGrid
      Content[I] := StringReplace(Content[I],
        'TcxGrid', 'TStringGrid', [rfReplaceAll]);

      // Remplacer TcxButton par TButton
      Content[I] := StringReplace(Content[I],
        'TcxButton', 'TButton', [rfReplaceAll]);

      // etc.
    end;

    Content.SaveToFile(FileName);
  finally
    Content.Free;
  end;
end;
```

### Probl√®me 5 : Performances diff√©rentes

**Sympt√¥me :** Application plus lente sous Lazarus.

**Causes possibles :**
1. Mode Debug activ√© (optimisations d√©sactiv√©es)
2. Assertions activ√©es en production
3. Range checking activ√©

**Solution : Options de compilation pour Release**

```pascal
// Dans les options du projet ou en en-t√™te d'unit√©
{$mode objfpc}{$H+}
{$OPTIMIZATION LEVEL3}       // Optimisation maximale
{$IFDEF RELEASE}
  {$ASSERTIONS OFF}          // D√©sactiver assertions
  {$RANGECHECKS OFF}         // D√©sactiver v√©rifications
  {$OVERFLOWCHECKS OFF}      // D√©sactiver overflow checks
  {$IOCHECKS OFF}            // D√©sactiver I/O checks
  {$DEBUGINFO OFF}           // Pas de debug info
  {$INLINE ON}               // Activer inlining
{$ENDIF}
```

**Compiler en mode Release :**

```bash
lazbuild --build-mode=Release MyProject.lpi
```

---

## Checklist compl√®te de migration

Utilisez cette checklist pour suivre votre progression :

### Pr√©paration

- [ ] Inventaire complet du projet Delphi
- [ ] Identification des composants tiers
- [ ] Liste des APIs Windows utilis√©es
- [ ] Estimation de l'effort
- [ ] Backup complet du projet original
- [ ] Installation de Lazarus + packages n√©cessaires

### Conversion

- [ ] Conversion automatique via Lazarus
- [ ] V√©rification de tous les .lfm g√©n√©r√©s
- [ ] Compilation initiale r√©ussie
- [ ] R√©solution des erreurs de compilation
- [ ] Adaptation des clauses uses

### Adaptation

- [ ] Remplacement des composants tiers
- [ ] Adaptation des messages Windows
- [ ] Portage des APIs Windows
- [ ] Migration des acc√®s base de donn√©es
- [ ] Adaptation de la configuration (Registry ‚Üí INI)
- [ ] Gestion des encodages

### Tests

- [ ] Compilation sans warning
- [ ] Tous les formulaires s'ouvrent
- [ ] Tests unitaires passent
- [ ] Tests fonctionnels complets
- [ ] Validation visuelle
- [ ] Tests de performance

### Documentation

- [ ] Documentation des changements
- [ ] Guide de build
- [ ] Notes pour futurs d√©veloppeurs
- [ ] Liste des diff√©rences avec version Delphi

---

## Outils utiles

### Convertisseurs et utilitaires

**1. Lazarus IDE Tools**
- Tools ‚Üí Delphi Conversion
- Tools ‚Üí Convert DFM file to LFM

**2. Scripts de conversion**

```bash
#!/bin/bash
# convert_project.sh

# Convertir tous les .dfm en .lfm
find . -name "*.dfm" -exec \
  /usr/share/lazarus/tools/lazres {} {}.lfm \;

# Renommer
find . -name "*.dfm.lfm" -exec \
  bash -c 'mv "$0" "${0%.dfm.lfm}.lfm"' {} \;

echo "Conversion complete"
```

**3. Recherche et remplacement global**

Dans Lazarus : Search ‚Üí Find in Files

Exemples de remplacements utiles :

```
AnsiString ‚Üí String
WideString ‚Üí UnicodeString
Windows, Messages ‚Üí LCLIntf, LMessages
TRegistry ‚Üí TIniFile (si portabilit√© souhait√©e)
```

### Comparaison de fichiers

Utiliser un outil de diff pour comparer .dfm vs .lfm :

```bash
# Linux
meld MainForm.dfm MainForm.lfm

# Windows
"C:\Program Files\WinMerge\WinMergeU.exe" MainForm.dfm MainForm.lfm
```

---

## Conclusion

La migration d'un projet Delphi Windows vers FreePascal/Lazarus est un investissement qui apporte :

‚úÖ **Libert√©** de l'open source
‚úÖ **Portabilit√©** vers Linux et macOS
‚úÖ **√âconomies** de licences
‚úÖ **P√©rennit√©** du code
‚úÖ **Modernisation** de l'application

**Points cl√©s √† retenir :**

1. **√âvaluer avant de migrer** : Inventaire complet et estimation r√©aliste
2. **Migrer progressivement** : Module par module si possible
3. **Tester rigoureusement** : Tests unitaires et fonctionnels
4. **Documenter les changements** : Pour maintenance future
5. **Pr√©parer la portabilit√©** : Penser multi-plateforme d√®s la migration

**Taux de succ√®s observ√©s :**

- Applications CRUD simples : 95% de r√©ussite
- Applications moyennes : 85% de r√©ussite
- Applications complexes : 70% de r√©ussite (avec effort)

La cl√© du succ√®s r√©side dans une bonne pr√©paration et une approche m√©thodique. N'h√©sitez pas √† solliciter la communaut√© Lazarus en cas de blocage ‚Äì elle est tr√®s r√©active et accueillante.

Dans la section suivante (26.7.2), nous verrons comment adapter ces projets port√©s pour une vraie compatibilit√© Linux, en allant au-del√† de la simple compilation.

‚è≠Ô∏è [Adaptation pour Linux](/26-communaute-ecosysteme/07.2-adaptation-pour-linux.md)
