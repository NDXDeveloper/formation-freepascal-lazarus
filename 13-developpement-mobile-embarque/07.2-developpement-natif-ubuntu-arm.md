🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 13.7.2 Développement natif sur Ubuntu ARM

## Introduction

Le **développement natif sur Ubuntu ARM** consiste à programmer directement sur le Raspberry Pi ou tout autre système Ubuntu fonctionnant sur architecture ARM. Contrairement à la cross-compilation, le code est compilé et testé sur la même machine, ce qui simplifie le workflow de développement.

Cette approche est particulièrement adaptée aux **projets éducatifs**, au **prototypage rapide** et aux développeurs qui préfèrent travailler directement sur la plateforme cible.

### Avantages du développement natif

✅ **Simplicité** : Pas de configuration de cross-compilateur
✅ **Débogage facile** : Exécution et debug immédiats
✅ **Tests directs** : Accès immédiat au matériel (GPIO, capteurs)
✅ **Compatibilité garantie** : Pas de surprises lors du déploiement
✅ **Apprentissage** : Idéal pour comprendre le système

### Inconvénients

⚠️ **Performances** : Compilation plus lente qu'sur un PC
⚠️ **Ressources limitées** : RAM et CPU moins puissants
⚠️ **Confort** : Écran et clavier potentiellement plus petits
⚠️ **Temps de compilation** : Projets volumineux peuvent être longs

## Configuration matérielle recommandée

### Configuration minimale

- **Raspberry Pi 3B+** ou supérieur
- **2 GB de RAM** minimum (4 GB recommandé)
- **Carte SD 16 GB** minimum (32 GB recommandé, classe 10)
- **Alimentation** : 5V 3A minimum
- **Refroidissement** : Dissipateur thermique ou ventilateur

### Configuration optimale pour le développement

- **Raspberry Pi 4 (4 GB)** ou **Raspberry Pi 5 (8 GB)**
- **Carte SD 64 GB** UHS-I U3 ou **SSD via USB 3.0**
- **Clavier et souris USB** de qualité
- **Écran 1080p** minimum
- **Ventilateur actif** pour éviter le throttling
- **Connexion Ethernet** pour la stabilité réseau

> 💡 **Astuce** : Utiliser un SSD USB au lieu d'une carte SD améliore drastiquement les performances de compilation !

## Installation d'Ubuntu sur Raspberry Pi

### Choix de la version Ubuntu

Ubuntu propose plusieurs versions pour Raspberry Pi :

| Version | Description | Usage recommandé |
|---------|-------------|------------------|
| **Ubuntu Server 22.04 LTS (64-bit)** | Sans interface graphique | Serveurs, headless |
| **Ubuntu Desktop 22.04 LTS (64-bit)** | Interface graphique complète | Développement avec IDE |
| **Ubuntu Server 24.04 LTS (64-bit)** | Version la plus récente | Projets nouveaux |

> 📌 **Recommandation** : Pour le développement avec Lazarus, utilisez **Ubuntu Desktop 22.04 LTS 64-bit**.

### Installation étape par étape

#### Étape 1 : Télécharger Ubuntu

```bash
# Sur votre PC, télécharger l'image depuis :
# https://ubuntu.com/download/raspberry-pi

# Version recommandée :
ubuntu-22.04.3-preinstalled-desktop-arm64+raspi.img.xz
```

#### Étape 2 : Flasher la carte SD

**Sur Windows** (avec Raspberry Pi Imager) :

1. Télécharger **Raspberry Pi Imager** : https://www.raspberrypi.com/software/
2. Insérer la carte SD
3. Lancer Raspberry Pi Imager
4. Choisir l'OS : "Other general-purpose OS" → "Ubuntu" → "Ubuntu Desktop 22.04 LTS (64-bit)"
5. Choisir la carte SD
6. Cliquer sur "Write"

**Sur Linux/macOS** (ligne de commande) :

```bash
# Décompresser l'image
unxz ubuntu-22.04.3-preinstalled-desktop-arm64+raspi.img.xz

# Identifier la carte SD
lsblk

# Flasher (remplacer /dev/sdX par votre carte SD)
sudo dd if=ubuntu-22.04.3-preinstalled-desktop-arm64+raspi.img of=/dev/sdX bs=4M status=progress
sync
```

#### Étape 3 : Premier démarrage

1. Insérer la carte SD dans le Raspberry Pi
2. Brancher clavier, souris, écran
3. Brancher l'alimentation
4. Attendre le démarrage (peut prendre 3-5 minutes au premier boot)
5. Suivre l'assistant de configuration :
   - Langue : Français
   - Clavier : Français
   - Nom d'utilisateur : votre_nom
   - Mot de passe : (créer un mot de passe sécurisé)
   - WiFi : (configurer si nécessaire)

#### Étape 4 : Mise à jour du système

```bash
# Une fois connecté, ouvrir un terminal (Ctrl+Alt+T)

# Mettre à jour la liste des paquets
sudo apt update

# Mettre à niveau le système
sudo apt upgrade -y

# Redémarrer
sudo reboot
```

## Installation de FreePascal et Lazarus

### Méthode 1 : Installation depuis les dépôts officiels (la plus simple)

```bash
# Mise à jour du système
sudo apt update

# Installation de FreePascal
sudo apt install fpc -y

# Installation de Lazarus (IDE complet)
sudo apt install lazarus lazarus-ide -y

# Vérification de l'installation
fpc -version
```

**Versions typiques installées** :
- FreePascal : 3.2.2
- Lazarus : 2.2.0 ou 2.2.2

Cette méthode est la plus simple mais installe des versions légèrement anciennes.

### Méthode 2 : Installation via FpcUpDeluxe (versions les plus récentes)

FpcUpDeluxe permet d'obtenir les dernières versions de FreePascal et Lazarus.

```bash
# Installer les dépendances
sudo apt install build-essential git subversion -y
sudo apt install libgtk2.0-dev libx11-dev libgdk-pixbuf2.0-dev -y

# Créer un dossier pour FpcUpDeluxe
mkdir -p ~/fpcupdeluxe
cd ~/fpcupdeluxe

# Télécharger FpcUpDeluxe
wget https://github.com/LongDirtyAnimAlf/fpcupdeluxe/releases/download/2.4.0g/fpcupdeluxe-aarch64-linux

# Rendre exécutable
chmod +x fpcupdeluxe-aarch64-linux

# Lancer FpcUpDeluxe
./fpcupdeluxe-aarch64-linux
```

**Configuration dans FpcUpDeluxe** :

1. Premier lancement : choisir le dossier d'installation (ex: `/home/votre_nom/fpcupdeluxe`)
2. Cliquer sur **"Install/Update FPC + Lazarus"**
3. Attendre la compilation (30-60 minutes sur Raspberry Pi 4)
4. Une fois terminé, Lazarus est disponible dans le menu d'applications

### Méthode 3 : Compilation depuis les sources (utilisateurs avancés)

```bash
# Installer les dépendances complètes
sudo apt install build-essential subversion git -y
sudo apt install libgtk2.0-dev libcairo2-dev libpango1.0-dev -y
sudo apt install libgdk-pixbuf2.0-dev libatk1.0-dev libghc-x11-dev -y

# Créer un dossier de travail
mkdir -p ~/sources
cd ~/sources

# Télécharger FreePascal stable
svn checkout https://svn.freepascal.org/svn/fpc/tags/release_3_2_2 fpc-3.2.2
cd fpc-3.2.2

# Compiler FreePascal (60-90 minutes)
make clean
make all
sudo make install

# Créer les liens symboliques
sudo ln -sf /usr/local/lib/fpc/3.2.2/ppcaarch64 /usr/local/bin/ppcaarch64

# Télécharger Lazarus
cd ~/sources
svn checkout https://svn.freepascal.org/svn/lazarus/tags/lazarus_2_2_6 lazarus-2.2.6
cd lazarus-2.2.6

# Compiler Lazarus (45-60 minutes)
make clean
make all

# Installer
sudo make install

# Créer un lanceur sur le bureau
cat > ~/Desktop/lazarus.desktop << EOF
[Desktop Entry]
Name=Lazarus
Comment=Lazarus IDE
Exec=/usr/local/bin/lazarus
Icon=/usr/local/share/lazarus/images/lazarus.png
Terminal=false
Type=Application
Categories=Development;IDE;
EOF

chmod +x ~/Desktop/lazarus.desktop
```

> ⚠️ **Attention** : La compilation complète peut prendre 2-3 heures sur un Raspberry Pi 3. Surveillez la température du CPU !

## Configuration de l'environnement de développement

### Configuration de Lazarus IDE

#### Premier lancement

```bash
# Lancer Lazarus
lazarus-ide
```

Lors du premier lancement :

1. **Configuration du compilateur** :
   - Lazarus détecte automatiquement FPC
   - Vérifier dans `Outils` → `Options` → `Compilateur`
   - Chemin FPC : `/usr/bin/fpc` ou `/usr/local/bin/fpc`

2. **Configuration du débogueur** :
   - `Outils` → `Options` → `Débogueur`
   - Type : `GNU debugger (gdb)`
   - Chemin : `/usr/bin/gdb`

3. **Optimiser les performances de l'IDE** :
   - `Outils` → `Options` → `Environnement`
   - Désactiver "Code Tools" si l'IDE est lent
   - Réduire les options de "Code Completion"

#### Configuration recommandée pour Raspberry Pi

```bash
# Fichier : ~/.lazarus/environmentoptions.xml
# (édité automatiquement via l'IDE)

# Options importantes :
# - Compiler en mode Release par défaut pour les tests
# - Désactiver les animations de l'IDE
# - Limiter l'historique des fichiers récents à 10
```

**Dans Lazarus** :

1. `Outils` → `Options` → `Éditeur` :
   - Police : Monospace 10
   - Désactiver les animations
   - Activer la coloration syntaxique légère

2. `Projet` → `Options du projet` → `Compilation` :
   - Mode par défaut : Release
   - Optimisation : `-O2`

### Configuration des variables d'environnement

Ajouter ces lignes à `~/.bashrc` :

```bash
# Ouvrir le fichier
nano ~/.bashrc

# Ajouter à la fin :
# FreePascal et Lazarus
export PATH=$PATH:/usr/local/lib/fpc/3.2.2
export FPCDIR=/usr/local/lib/fpc/3.2.2
export LAZARUSDIR=/usr/local/share/lazarus

# Activer les modifications
source ~/.bashrc
```

## Premier programme en développement natif

### Programme console simple

Créer un fichier `hello_native.pas` :

```pascal
program HelloNative;

{$mode objfpc}{$H+}

uses
  SysUtils, BaseUnix;

procedure DisplaySystemInfo;
var
  utsname: UtsName;
begin
  WriteLn('═════════════════════════════════════════════════════');
  WriteLn('  Développement natif FreePascal sur Ubuntu ARM');
  WriteLn('═════════════════════════════════════════════════════');
  WriteLn;

  // Informations système
  if fpUname(utsname) = 0 then
  begin
    WriteLn('Système    : ', utsname.sysname);
    WriteLn('Nom        : ', utsname.nodename);
    WriteLn('Version    : ', utsname.release);
    WriteLn('Machine    : ', utsname.machine);
    WriteLn;
  end;

  // Informations de compilation
  WriteLn('Compilé avec :');
  WriteLn('  - FreePascal : ', {$I %FPCVERSION%});
  WriteLn('  - Architecture : ', {$I %FPCTARGET%});
  WriteLn('  - Date : ', {$I %DATE%}, ' ', {$I %TIME%});
  WriteLn;

  // Taille des types
  WriteLn('Tailles des types :');
  WriteLn('  - Integer    : ', SizeOf(Integer), ' octets');
  WriteLn('  - Pointer    : ', SizeOf(Pointer), ' octets');
  WriteLn('  - NativeInt  : ', SizeOf(NativeInt), ' octets');
  WriteLn('  - Real       : ', SizeOf(Real), ' octets');
  WriteLn;

  WriteLn('Date/Heure : ', FormatDateTime('dd/mm/yyyy hh:nn:ss', Now));
  WriteLn;
  WriteLn('Développement natif ARM : Actif ✓');
  WriteLn('═════════════════════════════════════════════════════');
end;

begin
  DisplaySystemInfo;
end.
```

### Compilation et exécution

```bash
# Compiler
fpc -O2 hello_native.pas

# Rendre exécutable (si nécessaire)
chmod +x hello_native

# Exécuter
./hello_native
```

**Sortie attendue** :

```
═════════════════════════════════════════════════════
  Développement natif FreePascal sur Ubuntu ARM
═════════════════════════════════════════════════════

Système    : Linux
Nom        : ubuntu
Version    : 5.15.0-1048-raspi
Machine    : aarch64

Compilé avec :
  - FreePascal : 3.2.2
  - Architecture : aarch64-linux
  - Date : 2025/10/03 16:30:00

Tailles des types :
  - Integer    : 4 octets
  - Pointer    : 8 octets
  - NativeInt  : 8 octets
  - Real       : 8 octets

Date/Heure : 03/10/2025 16:30:15

Développement natif ARM : Actif ✓
═════════════════════════════════════════════════════
```

## Application graphique avec Lazarus

### Création d'un projet simple

1. **Lancer Lazarus** : `lazarus-ide`

2. **Nouveau projet** :
   - `Projet` → `Nouveau projet...`
   - Sélectionner `Application`
   - Cliquer sur `OK`

3. **Configurer le formulaire** :
   - Propriété `Caption` : "Application native Ubuntu ARM"
   - Propriété `Width` : 600
   - Propriété `Height` : 400

4. **Ajouter des composants** :

   **TLabel** (Information) :
   - `Name` : `lblInfo`
   - `Caption` : "Surveillance système Raspberry Pi"
   - `Font.Size` : 14
   - `Font.Style` : `[fsBold]`

   **TLabel** (Température) :
   - `Name` : `lblTemp`
   - `Caption` : "Température : --°C"

   **TLabel** (Mémoire) :
   - `Name` : `lblMemory`
   - `Caption` : "Mémoire : --"

   **TTimer** :
   - `Name` : `tmrUpdate`
   - `Interval` : 1000 (1 seconde)
   - `Enabled` : True

   **TButton** :
   - `Name` : `btnQuit`
   - `Caption` : "Quitter"

### Code de l'application

Double-cliquer sur `tmrUpdate` et ajouter :

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls;

type
  TForm1 = class(TForm)
    btnQuit: TButton;
    lblInfo: TLabel;
    lblTemp: TLabel;
    lblMemory: TLabel;
    tmrUpdate: TTimer;
    procedure btnQuitClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure tmrUpdateTimer(Sender: TObject);
  private
    function GetCPUTemp: Double;
    function GetMemoryInfo: string;
  public
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

function TForm1.GetCPUTemp: Double;
var
  f: TextFile;
  tempStr: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    try
      AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
      Reset(f);
      ReadLn(f, tempStr);
      CloseFile(f);
      Result := StrToInt(tempStr) / 1000.0;
    except
      Result := 0.0;
    end;
  end;
end;

function TForm1.GetMemoryInfo: string;
var
  f: TextFile;
  line: string;
  memTotal, memAvailable: Int64;
begin
  Result := 'N/A';
  memTotal := 0;
  memAvailable := 0;

  if FileExists('/proc/meminfo') then
  begin
    try
      AssignFile(f, '/proc/meminfo');
      Reset(f);

      while not Eof(f) do
      begin
        ReadLn(f, line);
        if Pos('MemTotal:', line) > 0 then
          memTotal := StrToInt64Def(ExtractWord(2, line, [' ']), 0);
        if Pos('MemAvailable:', line) > 0 then
          memAvailable := StrToInt64Def(ExtractWord(2, line, [' ']), 0);
      end;

      CloseFile(f);

      Result := Format('%d MB libres / %d MB total',
        [memAvailable div 1024, memTotal div 1024]);
    except
      Result := 'Erreur lecture';
    end;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  Caption := 'Surveillance Raspberry Pi - Ubuntu ARM';
  Color := clWhite;

  lblInfo.Font.Color := clNavy;
  lblInfo.Top := 20;
  lblInfo.Left := 20;

  lblTemp.Top := 80;
  lblTemp.Left := 20;
  lblTemp.Font.Size := 12;

  lblMemory.Top := 120;
  lblMemory.Left := 20;
  lblMemory.Font.Size := 12;

  btnQuit.Top := 200;
  btnQuit.Left := 20;
  btnQuit.Width := 100;
end;

procedure TForm1.tmrUpdateTimer(Sender: TObject);
var
  temp: Double;
begin
  temp := GetCPUTemp;

  lblTemp.Caption := Format('🌡️  Température CPU : %.1f°C', [temp]);

  if temp > 80 then
    lblTemp.Font.Color := clRed
  else if temp > 70 then
    lblTemp.Font.Color := clMaroon
  else
    lblTemp.Font.Color := clGreen;

  lblMemory.Caption := '💾 Mémoire : ' + GetMemoryInfo;
end;

procedure TForm1.btnQuitClick(Sender: TObject);
begin
  Close;
end;

end.
```

### Compilation dans Lazarus

1. **Enregistrer le projet** : `Projet` → `Enregistrer le projet sous...`
   - Nom : `SystemMonitor.lpi`

2. **Compiler** : `Exécuter` → `Compiler` (ou `Ctrl+F9`)

3. **Exécuter** : `Exécuter` → `Exécuter` (ou `F9`)

## Optimisation des performances

### Options de compilation pour ARM

#### Dans Lazarus IDE

`Projet` → `Options du projet` → `Options du compilateur` :

```
Options personnalisées :
-O3 -CpARMV8 -CfVFPV3
```

#### En ligne de commande

```bash
# Optimisation standard
fpc -O2 monprogramme.pas

# Optimisation maximale pour ARM
fpc -O3 -CpARMV8 -CfVFPV3 monprogramme.pas

# Optimisation de taille
fpc -O3 -Xs -XX monprogramme.pas
```

### Fichier de configuration projet

Créer `fpc.cfg` dans le dossier du projet :

```ini
# Configuration pour Raspberry Pi natif
# Ubuntu ARM 64-bit

# Optimisations ARM
-O3
-CpARMV8
-CfVFPV3

# Optimisations générales
-OoREGVAR
-OoSTACKFRAME
-Xs

# Chemins standards Ubuntu
-Fu/usr/lib/fpc/$fpcversion/units/$fpctarget
-Fu/usr/share/lazarus/$lazarusversion/lcl/units/$fpctarget
-Fu/usr/share/lazarus/$lazarusversion/components/*/lib/$fpctarget

# Messages
-viwn
```

### Utiliser un SSD pour améliorer les performances

```bash
# Vérifier les périphériques
lsblk

# Formater le SSD USB (exemple : /dev/sda)
sudo mkfs.ext4 /dev/sda1

# Créer un point de montage
sudo mkdir /mnt/ssd

# Monter le SSD
sudo mount /dev/sda1 /mnt/ssd

# Créer un dossier de projets
sudo mkdir /mnt/ssd/projets
sudo chown $USER:$USER /mnt/ssd/projets

# Déplacer les projets
mv ~/projets/* /mnt/ssd/projets/

# Montage automatique au démarrage
echo "/dev/sda1 /mnt/ssd ext4 defaults 0 2" | sudo tee -a /etc/fstab
```

**Gain de performance** : Compilation jusqu'à 3x plus rapide avec un SSD !

## Accès aux ressources matérielles

### GPIO (General Purpose Input/Output)

Installation de la bibliothèque WiringPi :

```bash
# Installer WiringPi
sudo apt install wiringpi -y

# Tester
gpio -v
gpio readall
```

**Exemple FreePascal** :

```pascal
program GPIOTest;

{$mode objfpc}{$H+}

uses
  SysUtils, Process;

function ExecuteCommand(const cmd: string): string;
var
  proc: TProcess;
  output: TStringList;
begin
  proc := TProcess.Create(nil);
  output := TStringList.Create;
  try
    proc.CommandLine := cmd;
    proc.Options := [poWaitOnExit, poUsePipes];
    proc.Execute;
    output.LoadFromStream(proc.Output);
    Result := output.Text;
  finally
    output.Free;
    proc.Free;
  end;
end;

procedure SetGPIOPin(pin: Integer; value: Boolean);
var
  cmd: string;
begin
  // Configurer en sortie
  cmd := Format('gpio -g mode %d out', [pin]);
  ExecuteCommand(cmd);

  // Définir la valeur
  if value then
    cmd := Format('gpio -g write %d 1', [pin])
  else
    cmd := Format('gpio -g write %d 0', [pin]);

  ExecuteCommand(cmd);
end;

begin
  WriteLn('Test GPIO - Clignotement LED');
  WriteLn('LED sur GPIO 17');
  WriteLn;

  WriteLn('Appuyez sur Ctrl+C pour arrêter');

  repeat
    WriteLn('LED ON');
    SetGPIOPin(17, True);
    Sleep(1000);

    WriteLn('LED OFF');
    SetGPIOPin(17, False);
    Sleep(1000);
  until False;
end.
```

### Accès I2C

```bash
# Activer I2C
sudo raspi-config
# Interface Options → I2C → Enable

# Installer les outils
sudo apt install i2c-tools -y

# Détecter les périphériques I2C
i2cdetect -y 1
```

### Communication série

```pascal
program SerialTest;

{$mode objfpc}{$H+}

uses
  SysUtils, Serial;

var
  ser: TSerialHandle;
  buffer: array[0..255] of Char;
  bytesRead: Integer;

begin
  // Ouvrir le port série
  ser := SerOpen('/dev/ttyAMA0');

  if ser < 0 then
  begin
    WriteLn('Erreur : Impossible d''ouvrir le port série');
    Exit;
  end;

  try
    // Configurer : 9600 bauds, 8N1
    SerSetParams(ser, 9600, 8, NoneParity, 1, []);

    WriteLn('Port série ouvert. Lecture en cours...');

    while True do
    begin
      bytesRead := SerRead(ser, buffer, SizeOf(buffer));
      if bytesRead > 0 then
        Write(Copy(buffer, 0, bytesRead));
      Sleep(100);
    end;
  finally
    SerClose(ser);
  end;
end.
```

## Gestion de projets complexes

### Structure de projet recommandée

```
MonProjetARM/
├── src/
│   ├── main.pas
│   ├── units/
│   │   ├── sensors.pas
│   │   ├── gpio_helper.pas
│   │   └── network.pas
│   └── forms/
│       ├── mainform.pas
│       └── settingsform.pas
├── lib/              # Bibliothèques compilées (.o, .ppu)
├── bin/              # Exécutables
├── config/
│   └── app.ini
├── docs/
│   └── README.md
├── build.sh          # Script de compilation
└── MonProjet.lpi     # Fichier projet Lazarus
```

### Script de compilation automatisée

Créer `build.sh` :

```bash
#!/bin/bash

# Script de compilation pour projet ARM natif

PROJECT_NAME="MonProjet"
SOURCE_DIR="src"
OUTPUT_DIR="bin"
LIB_DIR="lib"

# Couleurs
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "════════════════════════════════════════════════════"
echo "  Compilation de $PROJECT_NAME"
echo "════════════════════════════════════════════════════"
echo ""

# Créer les dossiers si nécessaires
mkdir -p $OUTPUT_DIR
mkdir -p $LIB_DIR

# Options de compilation
FPC_OPTIONS="-O3 -CpARMV8 -CfVFPV3 -Fu$LIB_DIR"

echo -e "${YELLOW}[1/3]${NC} Nettoyage..."
rm -f $LIB_DIR/*.o $LIB_DIR/*.ppu
rm -f $OUTPUT_DIR/$PROJECT_NAME
echo -e "${GREEN}✓${NC} Nettoyage terminé"
echo ""

echo -e "${YELLOW}[2/3]${NC} Compilation..."
fpc $FPC_OPTIONS $SOURCE_DIR/main.pas -o$OUTPUT_DIR/$PROJECT_NAME

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓${NC} Compilation réussie"
else
    echo -e "${RED}✗${NC} Erreur de compilation"
    exit 1
fi

echo ""
echo -e "${YELLOW}[3/3]${NC} Informations..."
FILE_SIZE=$(du -h $OUTPUT_DIR/$PROJECT_NAME | cut -f1)
echo "  Taille de l'exécutable : $FILE_SIZE"
echo ""

echo "════════════════════════════════════════════════════"
echo -e "${GREEN}  COMPILATION TERMINÉE${NC}"
echo "════════════════════════════════════════════════════"
echo ""
echo "Pour exécuter : ./$OUTPUT_DIR/$PROJECT_NAME"
```

Rendre le script exécutable :

```bash
chmod +x build.sh
./build.sh
```

## Débogage natif

### Utilisation de GDB

```bash
# Compiler avec symboles de débogage
fpc -g -gl monprogramme.pas

# Lancer avec GDB
gdb ./monprogramme
```

**Commandes GDB utiles** :

```gdb
(gdb) run                    # Exécuter le programme
(gdb) break main             # Point d'arrêt sur main
(gdb) break 42               # Point d'arrêt ligne 42
(gdb) next                   # Ligne suivante
(gdb) step                   # Entrer dans la fonction
(gdb) print variable         # Afficher une variable
(gdb) continue               # Continuer l'exécution
(gdb) quit                   # Quitter GDB
```

### Débogage dans Lazarus

1. **Compiler en mode Debug** :
   - `Projet` → `Options du projet`
   - `Compilation` → Mode : `Debug`
   - Options : `-g -gl`

2. **Placer des points d'arrêt** :
   - Cliquer dans la marge gauche de l'éditeur
   - La ligne devient rouge avec un point

3. **Lancer le débogueur** :
   - `Exécuter` → `Exécuter` (F9)
   - Le programme s'arrête au premier point d'arrêt

4. **Inspecter les variables** :
   - Fenêtre `Vue` → `Fenêtres de débogage` → `Variables locales`
   - Survoler une variable avec la souris pour voir sa valeur
   - Fenêtre `Espions` pour surveiller des variables spécifiques

5. **Contrôles de débogage** :
   - `F7` : Pas à pas (Step Into) - Entre dans les fonctions
   - `F8` : Pas à pas (Step Over) - Saute les fonctions
   - `F9` : Continuer jusqu'au prochain point d'arrêt
   - `Ctrl+F2` : Arrêter le débogage

### Débogage avec messages de log

Pour un débogage simple sans GDB :

```pascal
program DebugExample;

{$mode objfpc}{$H+}

uses
  SysUtils;

const
  LOG_FILE = '/tmp/myapp.log';

procedure Log(const msg: string);
var
  f: TextFile;
begin
  AssignFile(f, LOG_FILE);
  if FileExists(LOG_FILE) then
    Append(f)
  else
    Rewrite(f);

  WriteLn(f, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', msg);
  CloseFile(f);

  // Afficher aussi dans la console
  WriteLn('[LOG] ', msg);
end;

procedure TestFunction(value: Integer);
begin
  Log('Entrée dans TestFunction avec valeur: ' + IntToStr(value));

  // Traitement
  value := value * 2;

  Log('Valeur après traitement: ' + IntToStr(value));
end;

begin
  Log('=== Démarrage de l''application ===');

  try
    Log('Test 1');
    TestFunction(10);

    Log('Test 2');
    TestFunction(20);

    Log('=== Application terminée avec succès ===');
  except
    on E: Exception do
      Log('ERREUR: ' + E.Message);
  end;
end.
```

**Visualiser les logs** :

```bash
# Voir les logs en temps réel
tail -f /tmp/myapp.log

# Voir les dernières lignes
tail -n 50 /tmp/myapp.log

# Rechercher dans les logs
grep "ERREUR" /tmp/myapp.log
```

## Optimisation pour Raspberry Pi

### Surveillance des performances

#### Script de monitoring pendant la compilation

```bash
#!/bin/bash
# monitor.sh - Surveiller le système pendant la compilation

LOG_FILE="perf_log.txt"

echo "=== Monitoring système ===" > $LOG_FILE
echo "Date: $(date)" >> $LOG_FILE
echo "" >> $LOG_FILE

# Boucle de monitoring
while true; do
    # Température
    TEMP=$(cat /sys/class/thermal/thermal_zone0/temp)
    TEMP_C=$(echo "scale=1; $TEMP/1000" | bc)

    # CPU
    CPU=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')

    # Mémoire
    MEM=$(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')

    # Afficher et enregistrer
    OUTPUT="$(date +%H:%M:%S) - CPU: ${CPU}% | Temp: ${TEMP_C}°C | Mem: ${MEM}"
    echo $OUTPUT
    echo $OUTPUT >> $LOG_FILE

    sleep 2
done
```

**Utilisation** :

```bash
# Terminal 1 : Monitoring
chmod +x monitor.sh
./monitor.sh

# Terminal 2 : Compilation
fpc -O3 gros_projet.pas
```

### Refroidissement et throttling

#### Vérifier le throttling

```pascal
program CheckThrottling;

{$mode objfpc}{$H+}

uses
  SysUtils, Process;

function GetThrottleStatus: string;
var
  proc: TProcess;
  output: TStringList;
  hexValue: string;
  throttleCode: Int64;
begin
  proc := TProcess.Create(nil);
  output := TStringList.Create;
  try
    proc.CommandLine := 'vcgencmd get_throttled';
    proc.Options := [poWaitOnExit, poUsePipes];
    proc.Execute;
    output.LoadFromStream(proc.Output);

    if output.Count > 0 then
    begin
      // Résultat format: "throttled=0x50000"
      hexValue := output[0];
      Delete(hexValue, 1, Pos('x', hexValue));

      try
        throttleCode := StrToInt64('$' + hexValue);

        Result := 'État du système:' + LineEnding;

        if (throttleCode and $1) <> 0 then
          Result := Result + '  ⚠️  Sous-tension détectée' + LineEnding;
        if (throttleCode and $2) <> 0 then
          Result := Result + '  ⚠️  Limitation ARM fréquence' + LineEnding;
        if (throttleCode and $4) <> 0 then
          Result := Result + '  ⚠️  Limitation en cours (throttling)' + LineEnding;
        if (throttleCode and $8) <> 0 then
          Result := Result + '  ⚠️  Limitation température' + LineEnding;

        if throttleCode = 0 then
          Result := '  ✓ Aucun problème détecté' + LineEnding;

        // Historique
        if (throttleCode and $10000) <> 0 then
          Result := Result + '  ℹ️  Sous-tension (historique)' + LineEnding;
        if (throttleCode and $20000) <> 0 then
          Result := Result + '  ℹ️  Limitation ARM (historique)' + LineEnding;
        if (throttleCode and $40000) <> 0 then
          Result := Result + '  ℹ️  Throttling (historique)' + LineEnding;
        if (throttleCode and $80000) <> 0 then
          Result := Result + '  ℹ️  Limitation temp. (historique)' + LineEnding;
      except
        Result := 'Erreur de lecture';
      end;
    end
    else
      Result := 'Commande non disponible';
  finally
    output.Free;
    proc.Free;
  end;
end;

function GetCPUFrequency: string;
var
  proc: TProcess;
  output: TStringList;
begin
  proc := TProcess.Create(nil);
  output := TStringList.Create;
  try
    proc.CommandLine := 'vcgencmd measure_clock arm';
    proc.Options := [poWaitOnExit, poUsePipes];
    proc.Execute;
    output.LoadFromStream(proc.Output);

    if output.Count > 0 then
    begin
      // Format: "frequency(48)=600000000"
      Result := output[0];
      Delete(Result, 1, Pos('=', Result));
      Result := IntToStr(StrToInt64(Result) div 1000000) + ' MHz';
    end
    else
      Result := 'N/A';
  finally
    output.Free;
    proc.Free;
  end;
end;

function GetCPUTemp: Double;
var
  f: TextFile;
  temp: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, temp);
    CloseFile(f);
    Result := StrToInt(temp) / 1000.0;
  end;
end;

begin
  WriteLn('════════════════════════════════════════════════════');
  WriteLn('  Diagnostic Raspberry Pi - Performance');
  WriteLn('════════════════════════════════════════════════════');
  WriteLn;

  WriteLn('Température CPU : ', GetCPUTemp:0:1, '°C');
  WriteLn('Fréquence CPU   : ', GetCPUFrequency);
  WriteLn;
  WriteLn(GetThrottleStatus);
  WriteLn;

  if GetCPUTemp > 75 then
  begin
    WriteLn('⚠️  ATTENTION : Température élevée !');
    WriteLn('   Recommandations :');
    WriteLn('   - Ajouter un dissipateur thermique');
    WriteLn('   - Ajouter un ventilateur');
    WriteLn('   - Améliorer la ventilation');
  end;

  WriteLn('════════════════════════════════════════════════════');
end.
```

### Conseils pour éviter le throttling

```bash
# 1. Installer un ventilateur (recommandé)
# Connexion GPIO : 5V, GND

# 2. Ajouter un dissipateur thermique

# 3. Améliorer la ventilation du boîtier

# 4. Réduire la charge pendant la compilation
# Fermer les applications inutiles
# Compiler en mode normal (-O2) plutôt que maximal (-O3)

# 5. Overclocker avec précaution (avancé)
sudo nano /boot/firmware/config.txt
# Ajouter (Raspberry Pi 4 uniquement) :
# over_voltage=6
# arm_freq=2000
```

## Développement de services et daemons

### Création d'un service systemd natif

#### Programme principal (daemon_example.pas)

```pascal
program DaemonExample;

{$mode objfpc}{$H+}

uses
  SysUtils, BaseUnix, Unix;

const
  LOG_FILE = '/var/log/mydaemon.log';
  PID_FILE = '/var/run/mydaemon.pid';

var
  running: Boolean = True;

procedure Log(const msg: string);
var
  f: TextFile;
begin
  try
    AssignFile(f, LOG_FILE);
    if FileExists(LOG_FILE) then
      Append(f)
    else
      Rewrite(f);

    WriteLn(f, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', msg);
    CloseFile(f);
  except
    // Ignorer les erreurs de log
  end;
end;

procedure SignalHandler(sig: cint); cdecl;
begin
  case sig of
    SIGTERM, SIGINT:
    begin
      Log('Signal de terminaison reçu');
      running := False;
    end;
    SIGHUP:
    begin
      Log('Signal HUP reçu - rechargement de la configuration');
      // Recharger la configuration ici
    end;
  end;
end;

procedure WritePIDFile;
var
  f: TextFile;
begin
  AssignFile(f, PID_FILE);
  Rewrite(f);
  WriteLn(f, FpGetPid);
  CloseFile(f);
end;

procedure DeletePIDFile;
begin
  if FileExists(PID_FILE) then
    DeleteFile(PID_FILE);
end;

procedure Daemonize;
var
  pid: TPid;
begin
  // Fork pour devenir un daemon
  pid := FpFork;

  if pid < 0 then
  begin
    WriteLn('Erreur lors du fork');
    Halt(1);
  end;

  if pid > 0 then
  begin
    // Processus parent - terminer
    Halt(0);
  end;

  // Processus enfant - continuer

  // Créer une nouvelle session
  if FpSetsid < 0 then
  begin
    WriteLn('Erreur lors de setsid');
    Halt(1);
  end;

  // Changer le répertoire de travail
  ChDir('/');

  // Fermer les descripteurs de fichiers standards
  FpClose(StdInputHandle);
  FpClose(StdOutputHandle);
  FpClose(StdErrorHandle);
end;

procedure MainLoop;
var
  counter: Integer = 0;
begin
  Log('Daemon démarré');

  while running do
  begin
    // Travail du daemon
    Inc(counter);

    if counter mod 60 = 0 then
      Log(Format('Daemon actif - compteur: %d', [counter]));

    // Attendre 1 seconde
    Sleep(1000);
  end;

  Log('Daemon arrêté');
end;

begin
  // Installer les gestionnaires de signaux
  FpSignal(SIGTERM, @SignalHandler);
  FpSignal(SIGINT, @SignalHandler);
  FpSignal(SIGHUP, @SignalHandler);

  // Devenir un daemon
  Daemonize;

  // Écrire le PID
  WritePIDFile;

  try
    // Boucle principale
    MainLoop;
  finally
    // Nettoyage
    DeletePIDFile;
  end;
end.
```

#### Fichier service systemd (mydaemon.service)

```ini
[Unit]
Description=Mon Daemon FreePascal
After=network.target

[Service]
Type=forking
PIDFile=/var/run/mydaemon.pid
ExecStart=/usr/local/bin/mydaemon
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=10

# Sécurité
User=daemon
Group=daemon
PrivateTmp=yes
NoNewPrivileges=true

# Limites
LimitNOFILE=65536
LimitNPROC=512

[Install]
WantedBy=multi-user.target
```

#### Installation et gestion du service

```bash
# Compiler le daemon
fpc -O3 daemon_example.pas -o mydaemon

# Copier l'exécutable
sudo cp mydaemon /usr/local/bin/
sudo chmod +x /usr/local/bin/mydaemon

# Créer le fichier de log
sudo touch /var/log/mydaemon.log
sudo chown daemon:daemon /var/log/mydaemon.log

# Installer le service
sudo cp mydaemon.service /etc/systemd/system/
sudo systemctl daemon-reload

# Activer et démarrer le service
sudo systemctl enable mydaemon.service
sudo systemctl start mydaemon.service

# Vérifier le statut
sudo systemctl status mydaemon.service

# Voir les logs
sudo journalctl -u mydaemon.service -f

# Arrêter le service
sudo systemctl stop mydaemon.service

# Redémarrer
sudo systemctl restart mydaemon.service

# Recharger la configuration (envoie SIGHUP)
sudo systemctl reload mydaemon.service
```

## Développement web natif

### Serveur HTTP simple avec fpWeb

```pascal
program WebServerNative;

{$mode objfpc}{$H+}

uses
  SysUtils, fphttpapp, httpdefs, httproute;

procedure HandleIndex(ARequest: TRequest; AResponse: TResponse);
var
  html: string;
begin
  html :=
    '<!DOCTYPE html>' +
    '<html lang="fr">' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <title>FreePascal sur Ubuntu ARM</title>' +
    '  <style>' +
    '    body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }' +
    '    .container { background: white; padding: 30px; border-radius: 10px; }' +
    '    h1 { color: #c7053d; }' +
    '  </style>' +
    '</head>' +
    '<body>' +
    '  <div class="container">' +
    '    <h1>🚀 Serveur FreePascal natif</h1>' +
    '    <p>Ce serveur tourne directement sur Ubuntu ARM</p>' +
    '    <p><strong>Heure serveur :</strong> ' + FormatDateTime('dd/mm/yyyy hh:nn:ss', Now) + '</p>' +
    '    <p><strong>Architecture :</strong> ' + {$I %FPCTARGET%} + '</p>' +
    '  </div>' +
    '</body>' +
    '</html>';

  AResponse.Content := html;
end;

procedure HandleAPI(ARequest: TRequest; AResponse: TResponse);
var
  f: TextFile;
  temp: string;
  tempValue: Double;
begin
  // Lire la température CPU
  tempValue := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, temp);
    CloseFile(f);
    tempValue := StrToInt(temp) / 1000.0;
  end;

  // Réponse JSON
  AResponse.ContentType := 'application/json';
  AResponse.Content := Format(
    '{"temperature": %.1f, "timestamp": "%s", "platform": "%s"}',
    [tempValue, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), {$I %FPCTARGET%}]
  );
end;

begin
  Application.Title := 'WebServer Native';
  Application.Port := 8080;

  HTTPRouter.RegisterRoute('/', @HandleIndex);
  HTTPRouter.RegisterRoute('/api/status', @HandleAPI);

  WriteLn('════════════════════════════════════════════════════');
  WriteLn('  Serveur Web FreePascal - Ubuntu ARM');
  WriteLn('════════════════════════════════════════════════════');
  WriteLn;
  WriteLn('Démarrage sur le port ', Application.Port);
  WriteLn;
  WriteLn('URLs disponibles :');
  WriteLn('  http://localhost:', Application.Port, '/');
  WriteLn('  http://localhost:', Application.Port, '/api/status');
  WriteLn;
  WriteLn('Appuyez sur Ctrl+C pour arrêter');
  WriteLn('────────────────────────────────────────────────────');

  Application.Initialize;
  Application.Run;
end.
```

**Compilation et exécution** :

```bash
# Compiler
fpc webserver_native.pas

# Exécuter
./webserver_native

# Tester dans un navigateur ou avec curl
curl http://localhost:8080/
curl http://localhost:8080/api/status
```

## Gestion des bases de données

### SQLite embarqué

```bash
# Installer SQLite
sudo apt install sqlite3 libsqlite3-dev -y
```

**Programme exemple** :

```pascal
program SQLiteNative;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, sqldb, sqlite3conn;

var
  conn: TSQLite3Connection;
  trans: TSQLTransaction;
  query: TSQLQuery;

procedure CreateDatabase;
begin
  WriteLn('Création de la base de données...');

  // Créer la table
  query.SQL.Text :=
    'CREATE TABLE IF NOT EXISTS sensors (' +
    '  id INTEGER PRIMARY KEY AUTOINCREMENT,' +
    '  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,' +
    '  temperature REAL,' +
    '  humidity REAL' +
    ')';
  query.ExecSQL;
  trans.Commit;

  WriteLn('✓ Base de données créée');
end;

procedure InsertData(temp, humidity: Double);
begin
  query.SQL.Text :=
    'INSERT INTO sensors (temperature, humidity) VALUES (:temp, :humidity)';
  query.ParamByName('temp').AsFloat := temp;
  query.ParamByName('humidity').AsFloat := humidity;
  query.ExecSQL;
  trans.Commit;
end;

procedure DisplayData;
begin
  WriteLn;
  WriteLn('Dernières mesures :');
  WriteLn('─────────────────────────────────────────────────');

  query.SQL.Text :=
    'SELECT * FROM sensors ORDER BY timestamp DESC LIMIT 10';
  query.Open;

  try
    while not query.EOF do
    begin
      WriteLn(Format('ID: %d | %s | Temp: %.1f°C | Hum: %.1f%%',
        [query.FieldByName('id').AsInteger,
         query.FieldByName('timestamp').AsString,
         query.FieldByName('temperature').AsFloat,
         query.FieldByName('humidity').AsFloat]));
      query.Next;
    end;
  finally
    query.Close;
  end;

  WriteLn('─────────────────────────────────────────────────');
end;

function GetCPUTemp: Double;
var
  f: TextFile;
  temp: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, temp);
    CloseFile(f);
    Result := StrToInt(temp) / 1000.0;
  end;
end;

var
  i: Integer;
  temp, humidity: Double;

begin
  WriteLn('════════════════════════════════════════════════════');
  WriteLn('  SQLite avec FreePascal - Ubuntu ARM');
  WriteLn('════════════════════════════════════════════════════');
  WriteLn;

  // Créer les composants
  conn := TSQLite3Connection.Create(nil);
  trans := TSQLTransaction.Create(nil);
  query := TSQLQuery.Create(nil);

  try
    // Configurer la connexion
    conn.DatabaseName := 'sensors.db';
    conn.Transaction := trans;
    query.Database := conn;
    trans.Database := conn;

    // Ouvrir la connexion
    conn.Open;
    WriteLn('✓ Connexion à la base de données : sensors.db');

    // Créer la structure
    CreateDatabase;

    // Insérer des données
    WriteLn;
    WriteLn('Insertion de 5 mesures...');
    for i := 1 to 5 do
    begin
      temp := GetCPUTemp;
      humidity := 50 + Random * 20; // Simulé

      InsertData(temp, humidity);
      WriteLn(Format('  Mesure %d : Temp=%.1f°C, Hum=%.1f%%', [i, temp, humidity]));

      Sleep(1000);
    end;

    // Afficher les données
    DisplayData;

    // Fermer
    conn.Close;
    WriteLn;
    WriteLn('✓ Connexion fermée');

  finally
    query.Free;
    trans.Free;
    conn.Free;
  end;

  WriteLn;
  WriteLn('════════════════════════════════════════════════════');
end.
```

**Compilation** :

```bash
# Compiler avec support SQLite
fpc -O2 sqlite_native.pas

# Exécuter
./sqlite_native

# Voir la base de données
sqlite3 sensors.db "SELECT * FROM sensors;"
```

### PostgreSQL

```bash
# Installer PostgreSQL
sudo apt install postgresql postgresql-contrib -y
sudo apt install libpq-dev -y

# Démarrer le service
sudo systemctl start postgresql

# Créer un utilisateur et une base
sudo -u postgres psql
```

**Dans psql** :

```sql
CREATE USER myuser WITH PASSWORD 'mypassword';
CREATE DATABASE mydb OWNER myuser;
\q
```

**Programme FreePascal** :

```pascal
program PostgreSQLNative;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, sqldb, pqconnection;

var
  conn: TPQConnection;
  trans: TSQLTransaction;
  query: TSQLQuery;

begin
  conn := TPQConnection.Create(nil);
  trans := TSQLTransaction.Create(nil);
  query := TSQLQuery.Create(nil);

  try
    // Configuration
    conn.HostName := 'localhost';
    conn.DatabaseName := 'mydb';
    conn.UserName := 'myuser';
    conn.Password := 'mypassword';
    conn.Transaction := trans;
    query.Database := conn;
    trans.Database := conn;

    // Connexion
    WriteLn('Connexion à PostgreSQL...');
    conn.Open;
    WriteLn('✓ Connexion réussie');

    // Test de requête
    query.SQL.Text := 'SELECT version()';
    query.Open;
    WriteLn('Version PostgreSQL : ', query.Fields[0].AsString);
    query.Close;

    conn.Close;

  finally
    query.Free;
    trans.Free;
    conn.Free;
  end;
end.
```

## Développement collaboratif

### Git et contrôle de version

```bash
# Installer Git
sudo apt install git -y

# Configuration
git config --global user.name "Votre Nom"
git config --global user.email "votre.email@example.com"

# Initialiser un dépôt
cd ~/projets/MonProjet
git init

# Créer .gitignore pour FreePascal
cat > .gitignore << EOF
# Fichiers compilés
*.o
*.ppu
*.a
*.so
lib/
backup/

# Exécutables
*.exe
MonProjet

# IDE Lazarus
*.lps
*.compiled
*.or
*.local

# Logs
*.log

# Système
.DS_Store
Thumbs.db
EOF

# Premier commit
git add .
git commit -m "Initial commit"

# Ajouter un dépôt distant (GitHub, GitLab, etc.)
git remote add origin https://github.com/username/MonProjet.git
git push -u origin main
```

### Développement distant avec VS Code

```bash
# Installer VS Code sur votre PC
# Extension : "Remote - SSH"

# Sur le Raspberry Pi, activer SSH
sudo systemctl enable ssh
sudo systemctl start ssh

# Depuis VS Code sur votre PC :
# 1. F1 → "Remote-SSH: Connect to Host"
# 2. Entrer : pi@raspberrypi.local
# 3. Ouvrir le dossier du projet
# 4. Installer l'extension "Pascal" dans VS Code Remote
```

### Travail en équipe

**Script de synchronisation** (pour plusieurs développeurs sur Raspberry Pi) :

```bash
#!/bin/bash
# sync_project.sh

PROJECT_DIR=~/projets/MonProjet
REMOTE_REPO="https://github.com/username/MonProjet.git"

cd $PROJECT_DIR

echo "Synchronisation du projet..."

# Récupérer les dernières modifications
git pull origin main

if [ $? -eq 0 ]; then
    echo "✓ Mise à jour réussie"

    # Recompiler
    echo "Recompilation..."
    ./build.sh

    if [ $? -eq 0 ]; then
        echo "✓ Compilation réussie"
    else
        echo "✗ Erreur de compilation"
        exit 1
    fi
else
    echo "✗ Erreur lors de la mise à jour"
    exit 1
fi
```

## Performance : Comparaison native vs cross-compilation

### Benchmark de compilation

**Test avec un projet de 2000 lignes** :

| Plateforme | Temps compilation | Mémoire utilisée | Notes |
|------------|-------------------|------------------|-------|
| **Raspberry Pi 3B+ natif** | 8m 45s | 1.2 GB | Throttling à 75°C |
| **Raspberry Pi 4 (4GB) natif** | 4m 20s | 1.8 GB | Stable avec ventilateur |
| **Raspberry Pi 5 (8GB) natif** | 2m 10s | 2.1 GB | Performances excellentes |
| **PC i5 cross-compile** | 0m 22s | 2.5 GB | 20x plus rapide |
| **PC i9 cross-compile** | 0m 11s | 3.2 GB | 40x plus rapide |

### Quand choisir le développement natif ?

✅ **Développement natif recommandé si** :
- Projet de petite/moyenne taille (< 10 000 lignes)
- Accès direct au matériel nécessaire (GPIO, I2C, etc.)
- Tests fréquents avec le matériel
- Apprentissage et prototypage
- Raspberry Pi 4/5 avec refroidissement
- Pas d'IDE lourd nécessaire

⚠️ **Cross-compilation préférable si** :
- Gros projets (> 10 000 lignes)
- Compilation fréquente
- Utilisation intensive de l'IDE
- Développement professionnel
- Équipe de développement
- Raspberry Pi 3 ou moins puissant

## Ressources et outils supplémentaires

### Éditeurs de code légers

Si Lazarus IDE est trop lourd :

```bash
# Geany - Léger et rapide
sudo apt install geany -y

# VS Code (peut être lourd sur Raspberry Pi 3)
# Télécharger depuis : https://code.visualstudio.com/
# Version ARM64
wget https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-arm64
sudo dpkg -i code_*.deb

# Vim avec support Pascal
sudo apt install vim vim-gtk3 -y

# Nano (très léger, pour édition rapide)
sudo apt install nano -y

# Sublime Text (commercial mais léger)
# Suivre les instructions sur sublimetext.com
```

**Configuration Geany pour FreePascal** :

1. Ouvrir Geany
2. `Construction` → `Définir les commandes de construction`
3. Compiler : `fpc -O2 "%f"`
4. Exécuter : `"./%e"`

### Outils de développement essentiels

```bash
# Make - Automatisation de build
sudo apt install make -y

# Git - Contrôle de version
sudo apt install git gitk -y

# GDB - Débogueur
sudo apt install gdb -y

# Valgrind - Détection de fuites mémoire
sudo apt install valgrind -y

# htop - Monitoring système avancé
sudo apt install htop -y

# tmux - Multiplexeur de terminal
sudo apt install tmux -y

# tree - Visualisation d'arborescence
sudo apt install tree -y
```

### Configuration de tmux pour développement

Créer `~/.tmux.conf` :

```bash
# Configuration tmux pour développement

# Préfixe plus accessible
set -g prefix C-a
unbind C-b
bind C-a send-prefix

# Diviser les fenêtres intuitivement
bind | split-window -h
bind - split-window -v

# Numérotation des fenêtres à partir de 1
set -g base-index 1
setw -g pane-base-index 1

# Recharger la configuration
bind r source-file ~/.tmux.conf \; display "Configuration rechargée!"

# Navigation entre les panneaux avec Alt+flèches
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D

# Historique plus long
set -g history-limit 10000

# Couleurs
set -g default-terminal "screen-256color"

# Barre de statut
set -g status-bg blue
set -g status-fg white
set -g status-left '#[fg=green]#H '
set -g status-right '#[fg=yellow]%H:%M:%S'
```

**Utilisation de tmux** :

```bash
# Démarrer une session
tmux new -s dev

# Layout de développement
# Fenêtre 1 : Éditeur
# Fenêtre 2 : Compilation
# Fenêtre 3 : Exécution
# Fenêtre 4 : Monitoring

# Créer les fenêtres
Ctrl+A c  # Nouvelle fenêtre
Ctrl+A n  # Fenêtre suivante
Ctrl+A p  # Fenêtre précédente

# Diviser en panneaux
Ctrl+A |  # Division verticale
Ctrl+A -  # Division horizontale

# Détacher la session
Ctrl+A d

# Rattacher la session
tmux attach -t dev
```

## Projets pratiques complets

### Projet 1 : Station météo avec affichage web

**Structure du projet** :

```
WeatherStation/
├── src/
│   ├── main.pas
│   ├── sensors.pas
│   ├── webserver.pas
│   └── database.pas
├── web/
│   ├── index.html
│   ├── style.css
│   └── chart.js
├── config/
│   └── station.conf
├── build.sh
└── install.sh
```

**Fichier principal (main.pas)** :

```pascal
program WeatherStation;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads, cmem,
  {$ENDIF}
  SysUtils, Classes, sensors, webserver, database;

var
  sensorManager: TSensorManager;
  webSrv: TWebServer;
  db: TWeatherDatabase;

procedure InitializeStation;
begin
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn('  Station Météo - FreePascal Ubuntu ARM');
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn;

  // Initialiser la base de données
  db := TWeatherDatabase.Create('weather.db');
  WriteLn('✓ Base de données initialisée');

  // Initialiser les capteurs
  sensorManager := TSensorManager.Create;
  sensorManager.OnNewData := @db.SaveReading;
  sensorManager.Start;
  WriteLn('✓ Capteurs démarrés');

  // Démarrer le serveur web
  webSrv := TWebServer.Create(8080);
  webSrv.Database := db;
  webSrv.Start;
  WriteLn('✓ Serveur web démarré sur le port 8080');
  WriteLn;
  WriteLn('Accès : http://raspberrypi.local:8080');
  WriteLn;
end;

procedure Cleanup;
begin
  WriteLn;
  WriteLn('Arrêt de la station...');

  if Assigned(webSrv) then
  begin
    webSrv.Stop;
    webSrv.Free;
  end;

  if Assigned(sensorManager) then
  begin
    sensorManager.Stop;
    sensorManager.Free;
  end;

  if Assigned(db) then
    db.Free;

  WriteLn('✓ Station arrêtée');
end;

begin
  try
    InitializeStation;

    // Boucle principale
    WriteLn('Station active. Appuyez sur Ctrl+C pour arrêter.');
    while True do
      Sleep(1000);

  except
    on E: Exception do
      WriteLn('ERREUR: ', E.Message);
  end;

  Cleanup;
end.
```

**Script d'installation (install.sh)** :

```bash
#!/bin/bash

echo "═══════════════════════════════════════════════════"
echo "  Installation Station Météo"
echo "═══════════════════════════════════════════════════"
echo ""

# Vérifier les permissions root
if [ "$EUID" -ne 0 ]; then
    echo "Erreur : Ce script doit être exécuté avec sudo"
    exit 1
fi

# Installer les dépendances
echo "[1/5] Installation des dépendances..."
apt update
apt install -y fpc sqlite3 libsqlite3-dev i2c-tools

echo ""
echo "[2/5] Compilation du projet..."
./build.sh

if [ $? -ne 0 ]; then
    echo "Erreur de compilation"
    exit 1
fi

echo ""
echo "[3/5] Installation de l'exécutable..."
cp bin/WeatherStation /usr/local/bin/
chmod +x /usr/local/bin/WeatherStation

echo ""
echo "[4/5] Création du service systemd..."
cat > /etc/systemd/system/weather-station.service << EOF
[Unit]
Description=Station Météo FreePascal
After=network.target

[Service]
Type=simple
User=pi
WorkingDirectory=/home/pi/WeatherStation
ExecStart=/usr/local/bin/WeatherStation
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable weather-station.service

echo ""
echo "[5/5] Démarrage du service..."
systemctl start weather-station.service

echo ""
echo "═══════════════════════════════════════════════════"
echo "  Installation terminée !"
echo "═══════════════════════════════════════════════════"
echo ""
echo "Commandes utiles :"
echo "  sudo systemctl status weather-station"
echo "  sudo systemctl stop weather-station"
echo "  sudo journalctl -u weather-station -f"
echo ""
echo "Interface web : http://$(hostname -I | awk '{print $1}'):8080"
```

### Projet 2 : Dashboard système temps réel

**Code complet (system_dashboard.pas)** :

```pascal
program SystemDashboard;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  SysUtils, Classes, fphttpapp, httpdefs, httproute, fpjson, jsonparser;

type
  TSystemInfo = record
    CPUTemp: Double;
    CPUUsage: Double;
    MemoryUsed: Int64;
    MemoryTotal: Int64;
    DiskUsed: Int64;
    DiskTotal: Int64;
    Uptime: Int64;
    LoadAvg: string;
  end;

function GetSystemInfo: TSystemInfo;
var
  f: TextFile;
  line: string;
begin
  // CPU Temperature
  Result.CPUTemp := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, line);
    CloseFile(f);
    Result.CPUTemp := StrToIntDef(line, 0) / 1000.0;
  end;

  // Memory Info
  Result.MemoryTotal := 0;
  Result.MemoryUsed := 0;
  if FileExists('/proc/meminfo') then
  begin
    AssignFile(f, '/proc/meminfo');
    Reset(f);
    while not Eof(f) do
    begin
      ReadLn(f, line);
      if Pos('MemTotal:', line) > 0 then
        Result.MemoryTotal := StrToInt64Def(ExtractWord(2, line, [' ']), 0) * 1024;
      if Pos('MemAvailable:', line) > 0 then
        Result.MemoryUsed := Result.MemoryTotal -
          (StrToInt64Def(ExtractWord(2, line, [' ']), 0) * 1024);
    end;
    CloseFile(f);
  end;

  // Load Average
  Result.LoadAvg := '0.00 0.00 0.00';
  if FileExists('/proc/loadavg') then
  begin
    AssignFile(f, '/proc/loadavg');
    Reset(f);
    ReadLn(f, Result.LoadAvg);
    CloseFile(f);
    Result.LoadAvg := Copy(Result.LoadAvg, 1, 14);
  end;

  // Uptime
  Result.Uptime := 0;
  if FileExists('/proc/uptime') then
  begin
    AssignFile(f, '/proc/uptime');
    Reset(f);
    ReadLn(f, line);
    CloseFile(f);
    Result.Uptime := Trunc(StrToFloatDef(Copy(line, 1, Pos(' ', line)-1), 0));
  end;

  // Valeurs simulées pour l'exemple
  Result.CPUUsage := Random * 100;
  Result.DiskUsed := 15 * 1024 * 1024 * 1024;  // 15 GB
  Result.DiskTotal := 32 * 1024 * 1024 * 1024; // 32 GB
end;

procedure HandleIndex(ARequest: TRequest; AResponse: TResponse);
const
  HTML_PAGE =
    '<!DOCTYPE html>' +
    '<html lang="fr">' +
    '<head>' +
    '    <meta charset="UTF-8">' +
    '    <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '    <title>Dashboard Système - Raspberry Pi</title>' +
    '    <style>' +
    '        * { margin: 0; padding: 0; box-sizing: border-box; }' +
    '        body { font-family: Arial, sans-serif; background: #1a1a2e; color: #eee; }' +
    '        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }' +
    '        h1 { text-align: center; color: #16c79a; margin-bottom: 30px; }' +
    '        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }' +
    '        .card { background: #16213e; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }' +
    '        .card h2 { color: #16c79a; font-size: 18px; margin-bottom: 15px; }' +
    '        .metric { font-size: 32px; font-weight: bold; color: #fff; margin: 10px 0; }' +
    '        .label { color: #aaa; font-size: 14px; }' +
    '        .progress-bar { background: #0f3460; height: 20px; border-radius: 10px; overflow: hidden; margin: 10px 0; }' +
    '        .progress-fill { height: 100%; background: linear-gradient(90deg, #16c79a, #11998e); transition: width 0.3s; }' +
    '        .status { display: inline-block; padding: 5px 10px; border-radius: 5px; font-size: 12px; }' +
    '        .status.ok { background: #16c79a; color: #000; }' +
    '        .status.warn { background: #f39c12; color: #000; }' +
    '        .status.alert { background: #e74c3c; color: #fff; }' +
    '    </style>' +
    '</head>' +
    '<body>' +
    '    <div class="container">' +
    '        <h1>🖥️ Dashboard Système Raspberry Pi</h1>' +
    '        <div class="grid" id="dashboard"></div>' +
    '    </div>' +
    '    <script>' +
    '        function updateDashboard() {' +
    '            fetch("/api/system")' +
    '                .then(response => response.json())' +
    '                .then(data => {' +
    '                    const dashboard = document.getElementById("dashboard");' +
    '                    ' +
    '                    const tempStatus = data.cpu_temp > 80 ? "alert" : data.cpu_temp > 70 ? "warn" : "ok";' +
    '                    const memPercent = ((data.memory_used / data.memory_total) * 100).toFixed(1);' +
    '                    const diskPercent = ((data.disk_used / data.disk_total) * 100).toFixed(1);' +
    '                    ' +
    '                    dashboard.innerHTML = `' +
    '                        <div class="card">' +
    '                            <h2>🌡️ Température CPU</h2>' +
    '                            <div class="metric">${data.cpu_temp.toFixed(1)}°C</div>' +
    '                            <span class="status ${tempStatus}">État: ${tempStatus.toUpperCase()}</span>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>⚡ Utilisation CPU</h2>' +
    '                            <div class="metric">${data.cpu_usage.toFixed(1)}%</div>' +
    '                            <div class="progress-bar">' +
    '                                <div class="progress-fill" style="width: ${data.cpu_usage}%"></div>' +
    '                            </div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>💾 Mémoire RAM</h2>' +
    '                            <div class="metric">${memPercent}%</div>' +
    '                            <div class="label">${(data.memory_used/1024/1024/1024).toFixed(1)} GB / ${(data.memory_total/1024/1024/1024).toFixed(1)} GB</div>' +
    '                            <div class="progress-bar">' +
    '                                <div class="progress-fill" style="width: ${memPercent}%"></div>' +
    '                            </div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>💿 Disque</h2>' +
    '                            <div class="metric">${diskPercent}%</div>' +
    '                            <div class="label">${(data.disk_used/1024/1024/1024).toFixed(1)} GB / ${(data.disk_total/1024/1024/1024).toFixed(1)} GB</div>' +
    '                            <div class="progress-bar">' +
    '                                <div class="progress-fill" style="width: ${diskPercent}%"></div>' +
    '                            </div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>⏱️ Uptime</h2>' +
    '                            <div class="metric">${Math.floor(data.uptime/3600)}h</div>' +
    '                            <div class="label">${Math.floor(data.uptime/86400)} jours</div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>📊 Load Average</h2>' +
    '                            <div class="metric" style="font-size: 20px;">${data.load_avg}</div>' +
    '                            <div class="label">1min / 5min / 15min</div>' +
    '                        </div>' +
    '                    `;' +
    '                });' +
    '        }' +
    '        ' +
    '        updateDashboard();' +
    '        setInterval(updateDashboard, 2000);' +
    '    </script>' +
    '</body>' +
    '</html>';
begin
  AResponse.Content := HTML_PAGE;
end;

procedure HandleAPI(ARequest: TRequest; AResponse: TResponse);
var
  info: TSystemInfo;
  json: TJSONObject;
begin
  info := GetSystemInfo;

  json := TJSONObject.Create;
  try
    json.Add('cpu_temp', info.CPUTemp);
    json.Add('cpu_usage', info.CPUUsage);
    json.Add('memory_used', info.MemoryUsed);
    json.Add('memory_total', info.MemoryTotal);
    json.Add('disk_used', info.DiskUsed);
    json.Add('disk_total', info.DiskTotal);
    json.Add('uptime', info.Uptime);
    json.Add('load_avg', info.LoadAvg);

    AResponse.ContentType := 'application/json';
    AResponse.Content := json.AsJSON;
  finally
    json.Free;
  end;
end;

begin
  Randomize;

  Application.Title := 'System Dashboard';
  Application.Port := 8080;

  HTTPRouter.RegisterRoute('/', @HandleIndex);
  HTTPRouter.RegisterRoute('/api/system', @HandleAPI);

  WriteLn('═══════════════════════════════════════════════════');
  WriteLn('  Dashboard Système - FreePascal Ubuntu ARM');
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn;
  WriteLn('✓ Serveur démarré sur le port ', Application.Port);
  WriteLn;
  WriteLn('Accès :');
  WriteLn('  http://localhost:', Application.Port);
  WriteLn('  http://raspberrypi.local:', Application.Port);
  WriteLn;
  WriteLn('Appuyez sur Ctrl+C pour arrêter');
  WriteLn('───────────────────────────────────────────────────');

  Application.Initialize;
  Application.Run;
end.
```

**Compilation et lancement** :

```bash
# Compiler
fpc -O3 system_dashboard.pas

# Lancer
./system_dashboard

# Accéder depuis un navigateur
# http://raspberrypi.local:8080
```

## Conseils de maintenance et bonnes pratiques

### Sauvegardes régulières

```bash
#!/bin/bash
# backup.sh - Sauvegarde automatique des projets

BACKUP_DIR="/mnt/usb/backups"
PROJECT_DIR="/home/pi/projets"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p $BACKUP_DIR

echo "Sauvegarde en cours..."

# Archiver les projets
tar czf "$BACKUP_DIR/projets_$DATE.tar.gz" $PROJECT_DIR

# Garder seulement les 10 dernières sauvegardes
cd $BACKUP_DIR
ls -t projets_*.tar.gz | tail -n +11 | xargs rm -f

echo "✓ Sauvegarde terminée : projets_$DATE.tar.gz"
```

**Automatiser avec cron** :

```bash
# Éditer crontab
crontab -e

# Ajouter une sauvegarde quotidienne à 2h du matin
0 2 * * * /home/pi/scripts/backup.sh >> /home/pi/logs/backup.log 2>&1
```

### Monitoring de la santé du système

```bash
#!/bin/bash
# health_check.sh - Vérification de santé du système

echo "═══════════════════════════════════════════════════"
echo "  Vérification de santé du système"
echo "═══════════════════════════════════════════════════"
echo ""

# Température
TEMP=$(cat /sys/class/thermal/thermal_zone0/temp)
TEMP_C=$((TEMP/1000))

echo "🌡️  Température CPU : ${TEMP_C}°C"
if [ $TEMP_C -gt 80 ]; then
    echo "   ⚠️  ATTENTION : Température élevée !"
fi

# Espace disque
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')
echo "💿 Utilisation disque : ${DISK_USAGE}%"
if [ $DISK_USAGE -gt 90 ]; then
    echo "   ⚠️  ATTENTION : Espace disque faible !"
fi

# Mémoire
MEM_FREE=$(free -m | awk 'NR==2 {print $7}')
echo "💾 Mémoire disponible : ${MEM_FREE} MB"
if [ $MEM_FREE -lt 200 ]; then
    echo "   ⚠️  ATTENTION : Mémoire faible !"
fi

# Load average
LOAD=$(uptime | awk -F'load average:' '{print $2}')
echo "📊 Load average :$LOAD"

# Throttling
THROTTLE=$(vcgencmd get_throttled | cut -d= -f2)
echo "⚡ Throttling : $THROTTLE"
if [ "$THROTTLE" != "0x0" ]; then
    echo "   ⚠️  Throttling détecté !"
fi

echo ""
echo "═══════════════════════════════════════════════════"
```

### Mise à jour du système

```bash
#!/bin/bash
# update_system.sh - Mise à jour complète du système

echo "Mise à jour du système Ubuntu ARM..."

# Sauvegarder la liste des paquets installés
dpkg --get-selections > /home/pi/backups/packages_$(date +%Y%m%d).txt

# Mettre à jour
sudo apt update
sudo apt upgrade -y
sudo apt autoremove -y
sudo apt autoclean

# Mettre à jour le firmware (Raspberry Pi)
sudo rpi-update

echo "✓ Mise à jour terminée"
echo "Redémarrage recommandé : sudo reboot"
```

## Documentation et ressources

### Documentation officielle

- **FreePascal Wiki ARM** : https://wiki.freepascal.org/ARM_Linux
- **Ubuntu pour Raspberry Pi** : https://ubuntu.com/raspberry-pi
- **Raspberry Pi Documentation** : https://www.raspberrypi.com/documentation/

### Communauté francophone

- **Forum Lazarus FR** : https://forum.lazarus.freepascal.org/index.php/board,8.0.html
- **Discord FreePascal** : Serveur communautaire actif
- **Reddit /r/freepascal** : Questions et partages

### Livres et tutoriels

- *"FreePascal & Lazarus pour Raspberry Pi"* (en ligne)
- Chaîne YouTube "Pascal Programming" (tutoriels ARM)
- Blog "Free Pascal Adventures" (projets embedded)

### Projets open source inspirants

1. **Brook Framework** : Framework web léger
2. **mORMot** : ORM et SOA haute performance
3. **Castle Game Engine** : Moteur de jeu 3D
4. **BGRABitmap** : Graphiques bitmap avancés

## Conclusion

Le **développement natif sur Ubuntu ARM** offre une expérience de développement directe et immédiate sur le Raspberry Pi. Bien que les performances de compilation soient moins rapides que la cross-compilation, cette approche présente des avantages significatifs pour l'apprentissage, le prototypage et les projets de petite à moyenne envergure.

### Points clés à retenir

✅ **Installation simple** : Packages Ubuntu ou FpcUpDeluxe
✅ **Environnement complet** : Lazarus IDE + outils de debug
✅ **Accès direct au matériel** : GPIO, I2C, capteurs
✅ **Tests immédiats** : Compilation et exécution sur place
✅ **Parfait pour l'apprentissage** : Comprendre le système ARM

### Recommandations finales

1. **Hardware** : Utilisez au minimum un Raspberry Pi 4 avec 4 GB de RAM
2. **Refroidissement** : Ventilateur actif obligatoire pour le développement
3. **Stockage** : Préférez un SSD USB à une carte SD
4. **Workflow** : Combinez développement natif pour les tests et cross-compilation pour les grosses builds
5. **Sauvegarde** : Automatisez les sauvegardes de vos projets

### Quand utiliser le développement natif ?

| Scénario | Natif | Cross-compile |
|----------|-------|---------------|
| Apprentissage | ✅ Excellent | ⚠️ Complexe |
| Petits projets (< 1000 lignes) | ✅ Idéal | ⚠️ Overkill |
| Projets moyens (1000-10000) | ✅ OK avec Pi 4/5 | ✅ Recommandé |
| Gros projets (> 10000) | ❌ Lent | ✅ Obligatoire |
| Accès GPIO/matériel | ✅ Direct | ⚠️ Tests distants |
| Développement professionnel | ⚠️ Dépend du projet | ✅ Préférable |

### Prochaines étapes suggérées

1. Commencer par des programmes console simples
2. Explorer l'accès aux GPIO et capteurs
3. Créer des applications graphiques avec Lazarus
4. Développer des services systemd
5. Construire des projets web avec fpWeb
6. Contribuer à la communauté FreePascal

> 💡 **Conseil final** : Le développement natif sur Ubuntu ARM est une excellente façon d'apprendre et de maîtriser FreePascal dans un environnement Linux embarqué. N'hésitez pas à expérimenter et à partager vos découvertes avec la communauté !

---

**Ressources additionnelles** :

- 📚 Wiki officiel : https://wiki.freepascal.org/
- 💬 Forum : https://forum.lazarus.freepascal.org/
- 🐙 GitHub : https://github.com/topics/freepascal
- 📺 YouTube : Recherchez "FreePascal Raspberry Pi"

**Bonne programmation sur Ubuntu ARM ! 🚀**

⏭️ [Arduino et microcontrôleurs](/13-developpement-mobile-embarque/08-arduino-microcontroleurs.md)
