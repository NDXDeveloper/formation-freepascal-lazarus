🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 13.7.1 Cross-compilation depuis Windows

## Introduction à la cross-compilation

La **cross-compilation** (compilation croisée) consiste à compiler un programme sur une machine (votre PC Windows) pour qu'il fonctionne sur une autre machine avec une architecture différente (le Raspberry Pi ARM).

### Pourquoi faire de la cross-compilation ?

**Avantages** :
- ⚡ **Rapidité** : Votre PC Windows est beaucoup plus puissant que le Raspberry Pi
- 🖥️ **Confort** : Développer avec Lazarus sur un écran confortable
- 💾 **Ressources** : Pas de surcharge du Raspberry Pi pendant la compilation
- 🔄 **Workflow efficace** : Compiler sur PC, tester sur Raspberry Pi

**Inconvénients** :
- 🔧 **Configuration complexe** : Installation du toolchain croisé
- 📦 **Dépendances** : Gérer les bibliothèques pour ARM
- 🐛 **Débogage** : Plus difficile à distance

### Le principe de fonctionnement

```
┌─────────────────────────────────────────────────┐
│         PC Windows (x86_64)                     │
│                                                 │
│  ┌────────────────────────────────────────┐     │
│  │  Code FreePascal (.pas)                │     │
│  └──────────────┬─────────────────────────┘     │
│                 │                               │
│                 ▼                               │
│  ┌────────────────────────────────────────┐     │
│  │  Compilateur Cross FPC                 │     │
│  │  (Windows → ARM Linux)                 │     │
│  └──────────────┬─────────────────────────┘     │
│                 │                               │
│                 ▼                               │
│  ┌────────────────────────────────────────┐     │
│  │  Exécutable ARM Linux                  │     │
│  └──────────────┬─────────────────────────┘     │
└─────────────────┼───────────────────────────────┘
                  │ Transfert (SCP/FTP/Réseau)
                  ▼
┌─────────────────────────────────────────────────┐
│         Raspberry Pi (ARM)                      │
│                                                 │
│  ┌────────────────────────────────────────┐     │
│  │  Exécution du programme                │     │
│  └────────────────────────────────────────┘     │
└─────────────────────────────────────────────────┘
```

## Prérequis

### Sur votre PC Windows

- **Windows 10/11** (64 bits recommandé)
- **FreePascal 3.2.2** ou supérieur installé
- **Lazarus 2.2.0** ou supérieur (optionnel mais recommandé)
- **Connexion réseau** au Raspberry Pi
- **Au moins 2 GB d'espace disque** pour le toolchain

### Sur le Raspberry Pi cible

- **Raspberry Pi OS** (anciennement Raspbian) installé
- **SSH activé** pour le transfert de fichiers
- **Connexion réseau** (WiFi ou Ethernet)
- Connaître **l'adresse IP** du Raspberry Pi

## Installation du cross-compilateur

### Méthode 1 : FpcUpDeluxe (recommandée pour débutants)

**FpcUpDeluxe** est un outil graphique qui automatise l'installation du cross-compilateur.

#### Téléchargement et installation

1. **Télécharger FpcUpDeluxe** :
   - Site officiel : https://github.com/LongDirtyAnimAlf/fpcupdeluxe/releases
   - Télécharger `fpcupdeluxe-x86_64-win64.exe`

2. **Lancer FpcUpDeluxe** :
   ```
   Double-cliquer sur fpcupdeluxe-x86_64-win64.exe
   ```

3. **Configuration initiale** :
   - Première ouverture : FpcUpDeluxe demande où installer FPC/Lazarus
   - Choisir un dossier, par exemple : `C:\FreePascal\fpcupdeluxe`
   - Laisser FpcUpDeluxe installer la version de base

#### Installation du cross-compilateur ARM

1. **Ouvrir l'onglet "Cross"** dans FpcUpDeluxe

2. **Sélectionner la cible** :
   - **OS Target** : `linux`
   - **CPU Target** : `arm` (pour Raspberry Pi 1/Zero) ou `aarch64` (pour Pi 3/4/5)

3. **Installer le cross-compilateur** :
   - Cliquer sur le bouton **"Install cross-compiler"**
   - FpcUpDeluxe télécharge et configure automatiquement :
     - Le compilateur croisé FPC
     - Les bibliothèques système ARM
     - Les outils de linkage (binutils)

4. **Patienter** : L'installation prend 10-30 minutes

5. **Vérification** :
   - Une fois terminé, vous devriez voir "Cross-compiler installed successfully"

#### Configuration dans Lazarus

1. **Ouvrir Lazarus**

2. **Menu Projet** → **Options du projet**

3. **Compiler Options** → **Paths de compilation** :
   ```
   Unités supplémentaires :
   C:\FreePascal\fpcupdeluxe\cross\lib\arm-linux
   ```

4. **Compiler Options** → **Config and Target** :
   - **Target OS** : `linux`
   - **Target CPU family** : `arm`

### Méthode 2 : Installation manuelle avec FPC

Cette méthode est plus technique mais offre plus de contrôle.

#### Étape 1 : Installer FreePascal sur Windows

```batch
# Télécharger l'installeur depuis https://www.freepascal.org/
# Version 3.2.2 recommandée
fpc-3.2.2.i386-win32.exe
```

Installer dans `C:\FPC\3.2.2\`

#### Étape 2 : Télécharger les binutils ARM

Les **binutils** sont les outils de compilation croisée (assembleur, linker, etc.).

**Sources possibles** :
- **Site FPC officiel** : https://www.freepascal.org/down/arm-linux/cross-bins.html
- **Projet Linaro** : https://releases.linaro.org/components/toolchain/binaries/

**Fichiers nécessaires** :
```
arm-linux-gnueabihf-as.exe      # Assembleur
arm-linux-gnueabihf-ld.exe      # Linker
arm-linux-gnueabihf-ar.exe      # Archiveur
arm-linux-gnueabihf-objcopy.exe # Copie d'objets
arm-linux-gnueabihf-strip.exe   # Suppression de symboles
```

**Installation** :
1. Créer un dossier : `C:\FPC\cross\arm-linux\bin`
2. Copier tous les binutils dans ce dossier

#### Étape 3 : Récupérer les bibliothèques ARM depuis le Raspberry Pi

Les bibliothèques système ARM du Raspberry Pi sont nécessaires pour le linkage.

**Sur le Raspberry Pi** (via SSH) :

```bash
# Se connecter au Raspberry Pi
ssh pi@raspberrypi.local

# Créer une archive des bibliothèques
cd /
tar czf ~/rpi-libs.tar.gz \
  lib/arm-linux-gnueabihf \
  usr/lib/arm-linux-gnueabihf \
  usr/include
```

**Sur Windows** (dans PowerShell ou CMD) :

```batch
# Télécharger l'archive
scp pi@raspberrypi.local:~/rpi-libs.tar.gz C:\Temp\

# Extraire (nécessite 7-Zip ou WinRAR)
# Extraire dans C:\FPC\cross\arm-linux\
```

Structure finale :
```
C:\FPC\cross\arm-linux\
├── bin\              (binutils)
├── lib\              (bibliothèques .so)
└── include\          (headers .h)
```

#### Étape 4 : Configurer FPC pour la cross-compilation

Créer un fichier de configuration `fpc-arm.cfg` dans `C:\FPC\3.2.2\bin\` :

```ini
# Configuration pour cross-compilation ARM Linux
#IFDEF cpuarm
  #IFDEF linux

    # Architecture cible
    -Tlinux
    -Parm
    -XParm-linux-gnueabihf-

    # Chemins des binutils
    -FDC:\FPC\cross\arm-linux\bin

    # Chemins des bibliothèques
    -FlC:\FPC\cross\arm-linux\lib\arm-linux-gnueabihf
    -FuC:\FPC\cross\arm-linux\lib\arm-linux-gnueabihf

    # Chemins des includes
    -FiC:\FPC\cross\arm-linux\include

    # Options de linkage
    -XR/lib/arm-linux-gnueabihf
    -XR/usr/lib/arm-linux-gnueabihf

  #ENDIF
#ENDIF
```

#### Étape 5 : Créer un script batch de compilation

Créer `compile-arm.bat` :

```batch
@echo off
REM Script de compilation croisée pour Raspberry Pi

SET FPC=C:\FPC\3.2.2\bin\i386-win32\fpc.exe
SET SOURCE=%1
SET OUTPUT=%~n1

echo Compilation de %SOURCE% pour ARM Linux...

%FPC% -Tlinux -Parm -XParm-linux-gnueabihf- %SOURCE% -o%OUTPUT%

if %errorlevel% equ 0 (
    echo Compilation reussie : %OUTPUT%
) else (
    echo Erreur de compilation
    exit /b 1
)
```

**Utilisation** :
```batch
compile-arm.bat monprogramme.pas
```

## Premier programme cross-compilé

### Code source simple

Créer un fichier `hello_rpi.pas` :

```pascal
program HelloRaspberryPi;

{$mode objfpc}{$H+}

uses
  SysUtils;

var
  i: Integer;

begin
  WriteLn('═══════════════════════════════════════');
  WriteLn('  Programme compilé depuis Windows     ');
  WriteLn('  pour Raspberry Pi (ARM Linux)        ');
  WriteLn('═══════════════════════════════════════');
  WriteLn;

  WriteLn('Architecture cible : ', {$I %FPCTARGET%});
  WriteLn('OS cible          : ', {$I %FPCTARGETOS%});
  WriteLn('Compilateur       : FreePascal ', {$I %FPCVERSION%});
  WriteLn;

  WriteLn('Comptage de 1 à 10 :');
  for i := 1 to 10 do
  begin
    Write(i, ' ');
    Sleep(100);
  end;
  WriteLn;
  WriteLn;

  WriteLn('Date/Heure : ', DateTimeToStr(Now));
  WriteLn;
  WriteLn('Programme terminé avec succès !');
end.
```

### Compilation depuis Windows

**Avec FpcUpDeluxe** :

```batch
# Ouvrir une console dans le dossier du projet
cd C:\MesProjets\RaspberryPi

# Compiler avec les options ARM
fpc -Tlinux -Parm hello_rpi.pas
```

**Avec le script batch** (méthode manuelle) :

```batch
compile-arm.bat hello_rpi.pas
```

**Vérification** :
- Un fichier `hello_rpi` (sans extension .exe) doit être créé
- C'est un exécutable Linux ARM

### Transfert vers le Raspberry Pi

#### Méthode 1 : SCP (Secure Copy)

**Avec WinSCP** (interface graphique) :
1. Télécharger WinSCP : https://winscp.net/
2. Se connecter au Raspberry Pi (protocole SCP)
3. Glisser-déposer le fichier `hello_rpi`

**Avec la ligne de commande** (PowerShell) :

```powershell
# Transfert du fichier
scp hello_rpi pi@raspberrypi.local:/home/pi/

# Donner les droits d'exécution
ssh pi@raspberrypi.local "chmod +x /home/pi/hello_rpi"
```

> 💡 **Astuce** : Installer OpenSSH sur Windows 10/11 via les fonctionnalités optionnelles pour avoir `scp` et `ssh` en ligne de commande.

#### Méthode 2 : Partage réseau (SMB/CIFS)

**Sur le Raspberry Pi** :

```bash
# Installer Samba
sudo apt install samba samba-common-bin

# Configurer un partage
sudo nano /etc/samba/smb.conf

# Ajouter à la fin du fichier :
[pishare]
path = /home/pi/shared
browseable = yes
writable = yes
only guest = no
create mask = 0777
directory mask = 0777
public = yes
```

**Sur Windows** :
1. Ouvrir l'Explorateur
2. Saisir `\\raspberrypi.local\pishare`
3. Copier-coller les fichiers compilés

### Exécution sur le Raspberry Pi

**Se connecter en SSH** :

```bash
ssh pi@raspberrypi.local
```

**Exécuter le programme** :

```bash
cd /home/pi
chmod +x hello_rpi
./hello_rpi
```

**Résultat attendu** :

```
═══════════════════════════════════════
  Programme compilé depuis Windows
  pour Raspberry Pi (ARM Linux)
═══════════════════════════════════════

Architecture cible : arm-linux
OS cible          : linux
Compilateur       : FreePascal 3.2.2

Comptage de 1 à 10 :
1 2 3 4 5 6 7 8 9 10

Date/Heure : 03/10/2025 15:45:32

Programme terminé avec succès !
```

## Projet avancé : Surveillance système du Raspberry Pi

### Code source (temp_monitor.pas)

```pascal
program TempMonitor;

{$mode objfpc}{$H+}

uses
  SysUtils, DateUtils;

const
  TEMP_FILE = '/sys/class/thermal/thermal_zone0/temp';
  REFRESH_INTERVAL = 2; // secondes

function GetCPUTemp: Double;
var
  f: TextFile;
  tempStr: string;
  tempValue: Int64;
begin
  Result := 0.0;
  if not FileExists(TEMP_FILE) then Exit;

  try
    AssignFile(f, TEMP_FILE);
    Reset(f);
    ReadLn(f, tempStr);
    CloseFile(f);

    tempValue := StrToInt64(tempStr);
    Result := tempValue / 1000.0;
  except
    Result := 0.0;
  end;
end;

function GetMemoryInfo: string;
var
  f: TextFile;
  line: string;
  total, available: Int64;
begin
  Result := 'N/A';
  total := 0;
  available := 0;

  if not FileExists('/proc/meminfo') then Exit;

  try
    AssignFile(f, '/proc/meminfo');
    Reset(f);

    while not Eof(f) do
    begin
      ReadLn(f, line);

      if Pos('MemTotal:', line) > 0 then
        total := StrToInt64Def(ExtractWord(2, line, [' ', ':']), 0);

      if Pos('MemAvailable:', line) > 0 then
        available := StrToInt64Def(ExtractWord(2, line, [' ', ':']), 0);
    end;

    CloseFile(f);

    if total > 0 then
      Result := Format('%d MB utilisés / %d MB total',
        [(total - available) div 1024, total div 1024]);
  except
    Result := 'Erreur lecture';
  end;
end;

procedure ClearScreen;
begin
  Write(#27'[2J'); // Code ANSI pour effacer l'écran
  Write(#27'[H');  // Retour en haut à gauche
end;

procedure DisplayMonitor;
var
  temp: Double;
  startTime: TDateTime;
  elapsed: Integer;
begin
  startTime := Now;

  repeat
    ClearScreen;

    WriteLn('╔════════════════════════════════════════════════════╗');
    WriteLn('║    SURVEILLANCE RASPBERRY PI - FREEPASCAL          ║');
    WriteLn('╚════════════════════════════════════════════════════╝');
    WriteLn;

    temp := GetCPUTemp;
    Write('🌡️  Température CPU : ', temp:0:1, '°C  ');

    if temp > 80 then
      WriteLn('[⚠️  CHAUD]')
    else if temp > 70 then
      WriteLn('[⚠️  Élevée]')
    else
      WriteLn('[✓ Normal]');

    WriteLn;
    WriteLn('💾 Mémoire        : ', GetMemoryInfo);
    WriteLn;
    WriteLn('🕐 Heure          : ', FormatDateTime('hh:nn:ss', Now));

    elapsed := SecondsBetween(Now, startTime);
    WriteLn('⏱️  Temps écoulé   : ', elapsed, ' secondes');
    WriteLn;
    WriteLn('───────────────────────────────────────────────────');
    WriteLn('Appuyez sur Ctrl+C pour quitter');

    Sleep(REFRESH_INTERVAL * 1000);
  until False;
end;

begin
  WriteLn('Démarrage du moniteur système...');
  Sleep(1000);

  try
    DisplayMonitor;
  except
    on E: Exception do
      WriteLn('Erreur : ', E.Message);
  end;
end.
```

### Compilation et déploiement

```batch
# Compilation depuis Windows
fpc -Tlinux -Parm -O2 temp_monitor.pas

# Transfert vers Raspberry Pi
scp temp_monitor pi@raspberrypi.local:/home/pi/

# Exécution (via SSH)
ssh pi@raspberrypi.local "chmod +x /home/pi/temp_monitor && /home/pi/temp_monitor"
```

## Automatisation avec scripts

### Script batch Windows complet

Créer `deploy-rpi.bat` :

```batch
@echo off
REM ============================================
REM  Script de compilation et déploiement
REM  Windows → Raspberry Pi
REM ============================================

SET RPI_HOST=raspberrypi.local
SET RPI_USER=pi
SET RPI_PATH=/home/pi
SET PROJECT=%1

if "%PROJECT%"=="" (
    echo Usage: deploy-rpi.bat nom_fichier.pas
    exit /b 1
)

echo ========================================
echo  Compilation cross ARM...
echo ========================================

fpc -Tlinux -Parm -O2 %PROJECT%

if %errorlevel% neq 0 (
    echo ERREUR: Compilation echouee
    exit /b 1
)

SET EXECUTABLE=%~n1

echo.
echo ========================================
echo  Transfert vers Raspberry Pi...
echo ========================================

scp %EXECUTABLE% %RPI_USER%@%RPI_HOST%:%RPI_PATH%/

if %errorlevel% neq 0 (
    echo ERREUR: Transfert echoue
    exit /b 1
)

echo.
echo ========================================
echo  Configuration des permissions...
echo ========================================

ssh %RPI_USER%@%RPI_HOST% "chmod +x %RPI_PATH%/%EXECUTABLE%"

echo.
echo ========================================
echo  DEPLOIEMENT TERMINE
echo ========================================
echo.
echo Pour executer sur le Raspberry Pi:
echo   ssh %RPI_USER%@%RPI_HOST%
echo   ./%EXECUTABLE%
echo.

pause
```

**Utilisation** :

```batch
deploy-rpi.bat temp_monitor.pas
```

### Script PowerShell avancé

Créer `Deploy-RaspberryPi.ps1` :

```powershell
<#
.SYNOPSIS
    Compile et déploie un programme FreePascal sur Raspberry Pi
.PARAMETER SourceFile
    Fichier source Pascal à compiler
.PARAMETER RpiHost
    Adresse du Raspberry Pi (défaut: raspberrypi.local)
.PARAMETER AutoRun
    Exécuter automatiquement après déploiement
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$SourceFile,

    [string]$RpiHost = "raspberrypi.local",
    [string]$RpiUser = "pi",
    [switch]$AutoRun
)

$ErrorActionPreference = "Stop"

# Couleurs
function Write-ColorOutput($ForegroundColor) {
    $fc = $host.UI.RawUI.ForegroundColor
    $host.UI.RawUI.ForegroundColor = $ForegroundColor
    if ($args) {
        Write-Output $args
    }
    $host.UI.RawUI.ForegroundColor = $fc
}

Write-ColorOutput Green "═══════════════════════════════════════════════"
Write-ColorOutput Green "  Compilation et déploiement Raspberry Pi"
Write-ColorOutput Green "═══════════════════════════════════════════════"
Write-Output ""

# Vérifier que le fichier source existe
if (-not (Test-Path $SourceFile)) {
    Write-ColorOutput Red "ERREUR: Fichier source introuvable: $SourceFile"
    exit 1
}

$BaseName = [System.IO.Path]::GetFileNameWithoutExtension($SourceFile)

# Compilation
Write-Output "Compilation de $SourceFile..."
& fpc -Tlinux -Parm -O2 $SourceFile

if ($LASTEXITCODE -ne 0) {
    Write-ColorOutput Red "ERREUR: Compilation échouée"
    exit 1
}

Write-ColorOutput Green "✓ Compilation réussie"
Write-Output ""

# Transfert
Write-Output "Transfert vers $RpiHost..."
& scp $BaseName "${RpiUser}@${RpiHost}:/home/${RpiUser}/"

if ($LASTEXITCODE -ne 0) {
    Write-ColorOutput Red "ERREUR: Transfert échoué"
    exit 1
}

Write-ColorOutput Green "✓ Transfert réussi"
Write-Output ""

# Permissions
Write-Output "Configuration des permissions..."
& ssh "${RpiUser}@${RpiHost}" "chmod +x /home/${RpiUser}/${BaseName}"

Write-ColorOutput Green "✓ Permissions configurées"
Write-Output ""

# Exécution auto si demandé
if ($AutoRun) {
    Write-ColorOutput Yellow "Exécution automatique..."
    Write-Output ""
    & ssh "${RpiUser}@${RpiHost}" "/home/${RpiUser}/${BaseName}"
}

Write-ColorOutput Green "═══════════════════════════════════════════════"
Write-ColorOutput Green "  DÉPLOIEMENT TERMINÉ"
Write-ColorOutput Green "═══════════════════════════════════════════════"
Write-Output ""
Write-Output "Pour exécuter manuellement:"
Write-Output "  ssh ${RpiUser}@${RpiHost}"
Write-Output "  ./${BaseName}"
```

**Utilisation** :

```powershell
# Compilation et déploiement simple
.\Deploy-RaspberryPi.ps1 -SourceFile temp_monitor.pas

# Avec exécution automatique
.\Deploy-RaspberryPi.ps1 -SourceFile temp_monitor.pas -AutoRun

# Vers une IP spécifique
.\Deploy-RaspberryPi.ps1 -SourceFile temp_monitor.pas -RpiHost 192.168.1.100
```

## Intégration avec Lazarus IDE

### Configuration du projet

1. **Créer un nouveau projet** dans Lazarus

2. **Menu Projet** → **Options du projet**

3. **Onglet "Compiler Options"** :
   - **Target OS** : `linux`
   - **Target CPU family** : `arm`

4. **Onglet "Paths de compilation"** :
   ```
   Autres sources d'unités (-Fu):
   C:\FPC\cross\arm-linux\lib
   ```

5. **Onglet "Compilation et Edition de liens"** :
   ```
   Options personnalisées:
   -O2 -Xs
   ```

### Créer une cible de build personnalisée

1. **Menu Exécuter** → **Configurer Compilation+Exécution**

2. **Ajouter une nouvelle configuration** :
   - **Nom** : "Raspberry Pi (ARM Linux)"
   - **Commande Compilation** :
     ```
     fpc -Tlinux -Parm -O2 $(ProjFile)
     ```
   - **Commande après compilation** :
     ```
     scp $(TargetFile) pi@raspberrypi.local:/home/pi/
     ```

### Macro de déploiement

Créer un fichier `deploy.bat` dans le dossier du projet :

```batch
@echo off
SET EXEC=%~n1
scp %EXEC% pi@raspberrypi.local:/home/pi/
ssh pi@raspberrypi.local "chmod +x /home/pi/%EXEC%"
echo Deploiement termine
pause
```

**Dans Lazarus** :
- **Menu Exécuter** → **Paramètres Exécution**
- **Commande de lancement** : `deploy.bat $(TargetFile)`

## Gestion des bibliothèques externes

### Problème : Bibliothèques manquantes

Si votre programme utilise des bibliothèques externes (SQLite, OpenSSL, etc.), vous devez :

1. **Identifier les dépendances** sur le Raspberry Pi :
   ```bash
   ldd monprogramme
   ```

2. **Copier les bibliothèques** nécessaires :
   ```bash
   # Sur le Raspberry Pi
   cd /usr/lib/arm-linux-gnueabihf
   tar czf libs-supplementaires.tar.gz libsqlite3.so* libssl.so*

   # Sur Windows
   scp pi@raspberrypi.local:~/libs-supplementaires.tar.gz C:\FPC\cross\arm-linux\lib\
   ```

3. **Ajouter au chemin de compilation** dans `fpc.cfg` :
   ```ini
   -FlC:\FPC\cross\arm-linux\lib\extras
   ```

### Exemple avec SQLite

**Code Pascal** :

```pascal
program TestSQLite;

{$mode objfpc}{$H+}

uses
  SysUtils, sqlite3conn, sqldb;

var
  conn: TSQLite3Connection;
  trans: TSQLTransaction;
  query: TSQLQuery;

begin
  conn := TSQLite3Connection.Create(nil);
  trans := TSQLTransaction.Create(nil);
  query := TSQLQuery.Create(nil);

  try
    conn.DatabaseName := '/home/pi/test.db';
    conn.Transaction := trans;
    query.Database := conn;

    conn.Open;

    WriteLn('✓ Connexion SQLite réussie');
    WriteLn('Base de données : ', conn.DatabaseName);

    conn.Close;
  finally
    query.Free;
    trans.Free;
    conn.Free;
  end;

  WriteLn('Programme terminé');
end.
```

**Compilation** :

```batch
# S'assurer que libsqlite3.so est disponible
fpc -Tlinux -Parm -O2 TestSQLite.pas
```

## Débogage à distance

### GDB Remote Debugging

Pour déboguer un programme sur le Raspberry Pi depuis Windows :

#### Sur le Raspberry Pi

```bash
# Installer gdbserver
sudo apt install gdbserver

# Lancer le programme avec gdbserver
gdbserver :2345 ./monprogramme
```

#### Sur Windows (avec Lazarus)

1. **Compiler avec symboles de débogage** :
   ```
   fpc -Tlinux -Parm -g -gl monprogramme.pas
   ```

2. **Configurer Lazarus** :
   - **Menu Exécuter** → **Attacher au processus**
   - **Type** : Remote GDB
   - **Hôte** : `raspberrypi.local`
   - **Port** : `2345`

3. **Placer des points d'arrêt** et déboguer normalement

### Logs et traces

**Ajouter des logs dans le code** :

```pascal
program LoggedApp;

{$mode objfpc}{$H+}

uses
  SysUtils;

const
  LOG_FILE = '/home/pi/app.log';

procedure Log(const msg: string);
var
  f: TextFile;
begin
  AssignFile(f, LOG_FILE);
  if FileExists(LOG_FILE) then
    Append(f)
  else
    Rewrite(f);

  WriteLn(f, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', msg);
  CloseFile(f);
end;

begin
  Log('Application démarrée');

  try
    // Code principal
    Log('Traitement en cours...');
    Sleep(1000);
    Log('Traitement terminé');
  except
    on E: Exception do
      Log('ERREUR: ' + E.Message);
  end;

  Log('Application terminée');
end.
```

## Optimisation pour la cross-compilation

### Options de compilation recommandées

```batch
# Optimisation équilibrée (recommandé)
fpc -Tlinux -Parm -O2 -Xs programme.pas

# Optimisation maximale (production)
fpc -Tlinux -Parm -O3 -Xs -XX programme.pas

# Optimisation avec options ARM spécifiques
fpc -Tlinux -Parm -O3 -CpARMV7A -CfVFPV3 -Xs programme.pas

# Version debug (développement)
fpc -Tlinux -Parm -g -gl -O- programme.pas
```

### Explication des options

| Option | Description | Usage |
|--------|-------------|-------|
| `-Tlinux` | Système cible : Linux | **Obligatoire** |
| `-Parm` | Processeur cible : ARM | **Obligatoire** |
| `-O2` | Optimisation niveau 2 | Recommandé (équilibré) |
| `-O3` | Optimisation niveau 3 | Production (plus agressif) |
| `-O4` | Optimisation maximale | Risqué (peut casser le code) |
| `-Xs` | Strip symbols (enlever les symboles) | Réduit la taille |
| `-XX` | Smart linking | Réduit encore la taille |
| `-CpARMV7A` | Cible ARMv7-A (Pi 2/3/4) | Performances optimales |
| `-CfVFPV3` | Utiliser VFP v3 (flottants) | Calculs plus rapides |
| `-g` | Symboles de debug | Débogage |
| `-gl` | Numéros de ligne debug | Débogage détaillé |

### Fichier de configuration projet

Créer un fichier `fpc.cfg` dans votre dossier projet :

```ini
# ============================================
# Configuration FreePascal pour Raspberry Pi
# Cross-compilation depuis Windows
# ============================================

# Cibles
-Tlinux
-Parm

# Optimisations (production)
-O3
-CpARMV7A
-CfVFPV3

# Taille réduite
-Xs
-XX

# Chemins (adapter selon votre installation)
-FuC:\FPC\cross\arm-linux\lib
-FlC:\FPC\cross\arm-linux\lib\arm-linux-gnueabihf

# Préfixe des outils
-XParm-linux-gnueabihf-

# Binutils
-FDC:\FPC\cross\arm-linux\bin

# Messages en français
-Mobjfpc
-Scghi

# Sortie détaillée
-viwn
```

Pour utiliser ce fichier :

```batch
# Compilation avec fpc.cfg du projet
fpc @fpc.cfg monprogramme.pas
```

### Comparaison des tailles d'exécutables

Exemple avec un programme simple :

```pascal
program SizeTest;
begin
  WriteLn('Test de taille d''exécutable');
end.
```

**Résultats de compilation** :

| Options | Taille | Vitesse compilation |
|---------|--------|---------------------|
| Aucune | 856 KB | Rapide |
| `-O2` | 620 KB | Moyenne |
| `-O3 -Xs` | 485 KB | Moyenne |
| `-O3 -Xs -XX` | 156 KB | Lente |
| `-O4 -Xs -XX` | 148 KB | Très lente |

> 💡 **Recommandation** : Utilisez `-O2` pendant le développement et `-O3 -Xs -XX` pour la production.

## Gestion des différences d'architecture

### Compilation pour différents modèles de Raspberry Pi

#### Raspberry Pi 1 / Zero (ARMv6)

```batch
# ARMv6 - Architecture la plus ancienne
fpc -Tlinux -Parm -CpARMV6 -O2 programme.pas
```

#### Raspberry Pi 2 / 3 (ARMv7 32 bits)

```batch
# ARMv7-A avec VFP v3 (recommandé)
fpc -Tlinux -Parm -CpARMV7A -CfVFPV3 -O2 programme.pas
```

#### Raspberry Pi 3 / 4 / 5 (ARMv8 64 bits)

```batch
# AArch64 - Architecture 64 bits
fpc -Tlinux -Paarch64 -O2 programme.pas
```

> ⚠️ **Important** : Un exécutable compilé pour ARMv7 fonctionnera sur ARMv8, mais pas l'inverse. Pour une compatibilité maximale, utilisez ARMv6.

### Détection automatique de l'architecture

```pascal
program ArchDetect;

{$mode objfpc}{$H+}

uses
  SysUtils;

begin
  WriteLn('Architecture détectée :');

  {$IFDEF CPUARM}
    WriteLn('  - Processeur : ARM 32 bits');

    {$IFDEF CPUARMV6}
      WriteLn('  - Version : ARMv6 (Pi 1/Zero)');
    {$ENDIF}

    {$IFDEF CPUARMV7}
      WriteLn('  - Version : ARMv7 (Pi 2/3/4)');
    {$ENDIF}
  {$ENDIF}

  {$IFDEF CPUAARCH64}
    WriteLn('  - Processeur : ARM 64 bits (AArch64)');
    WriteLn('  - Compatible : Pi 3/4/5');
  {$ENDIF}

  {$IFDEF LINUX}
    WriteLn('  - Système : Linux');
  {$ENDIF}

  WriteLn;
  WriteLn('Taille des types :');
  WriteLn('  - Integer  : ', SizeOf(Integer), ' octets');
  WriteLn('  - Pointer  : ', SizeOf(Pointer), ' octets');
  WriteLn('  - NativeInt: ', SizeOf(NativeInt), ' octets');
end.
```

## Projet complet : Serveur HTTP simple

### Code source (http_server.pas)

```pascal
program SimpleHTTPServer;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, Sockets, BaseUnix;

const
  SERVER_PORT = 8080;
  BUFFER_SIZE = 4096;

type
  THTTPServer = class
  private
    FSocket: TSocket;
    FRunning: Boolean;
    procedure HandleClient(ClientSocket: TSocket);
    function GenerateResponse: string;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Start;
    procedure Stop;
  end;

constructor THTTPServer.Create;
begin
  inherited Create;
  FRunning := False;
end;

destructor THTTPServer.Destroy;
begin
  Stop;
  inherited Destroy;
end;

function THTTPServer.GenerateResponse: string;
var
  uptime: string;
  temp: Double;
  f: TextFile;
  tempStr: string;
begin
  // Lire la température
  temp := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, tempStr);
    CloseFile(f);
    temp := StrToIntDef(tempStr, 0) / 1000.0;
  end;

  // Uptime système
  uptime := 'N/A';
  if FileExists('/proc/uptime') then
  begin
    AssignFile(f, '/proc/uptime');
    Reset(f);
    ReadLn(f, tempStr);
    CloseFile(f);
    uptime := Copy(tempStr, 1, Pos(' ', tempStr) - 1) + ' secondes';
  end;

  // Générer la page HTML
  Result :=
    'HTTP/1.1 200 OK' + #13#10 +
    'Content-Type: text/html; charset=utf-8' + #13#10 +
    'Connection: close' + #13#10 +
    #13#10 +
    '<!DOCTYPE html>' +
    '<html lang="fr">' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '  <title>Raspberry Pi - FreePascal</title>' +
    '  <style>' +
    '    body { font-family: Arial, sans-serif; margin: 40px; background: #f0f0f0; }' +
    '    .container { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }' +
    '    h1 { color: #c7053d; }' +
    '    .info { margin: 20px 0; padding: 15px; background: #f8f9fa; border-left: 4px solid #c7053d; }' +
    '    .temp { font-size: 24px; color: #333; font-weight: bold; }' +
    '  </style>' +
    '</head>' +
    '<body>' +
    '  <div class="container">' +
    '    <h1>🍓 Raspberry Pi - Serveur FreePascal</h1>' +
    '    <div class="info">' +
    '      <p><strong>🌡️ Température CPU:</strong> <span class="temp">' + Format('%.1f°C', [temp]) + '</span></p>' +
    '      <p><strong>⏱️ Uptime:</strong> ' + uptime + '</p>' +
    '      <p><strong>📅 Date/Heure:</strong> ' + FormatDateTime('dd/mm/yyyy hh:nn:ss', Now) + '</p>' +
    '      <p><strong>🖥️ Serveur:</strong> FreePascal HTTP Server</p>' +
    '    </div>' +
    '    <p><em>Compilé depuis Windows pour ARM Linux</em></p>' +
    '  </div>' +
    '</body>' +
    '</html>';
end;

procedure THTTPServer.HandleClient(ClientSocket: TSocket);
var
  buffer: array[0..BUFFER_SIZE-1] of Char;
  bytesRead: Integer;
  response: string;
begin
  // Lire la requête (on ne la traite pas vraiment dans cet exemple)
  bytesRead := fprecv(ClientSocket, @buffer, BUFFER_SIZE, 0);

  if bytesRead > 0 then
  begin
    WriteLn('[', FormatDateTime('hh:nn:ss', Now), '] Requête reçue');

    // Générer et envoyer la réponse
    response := GenerateResponse;
    fpsend(ClientSocket, @response[1], Length(response), 0);
  end;

  // Fermer la connexion client
  CloseSocket(ClientSocket);
end;

procedure THTTPServer.Start;
var
  serverAddr: TInetSockAddr;
  clientSocket: TSocket;
begin
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn('  Serveur HTTP FreePascal pour Raspberry Pi');
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn;

  // Créer le socket
  FSocket := fpSocket(AF_INET, SOCK_STREAM, 0);
  if FSocket = -1 then
  begin
    WriteLn('Erreur : Impossible de créer le socket');
    Exit;
  end;

  // Permettre la réutilisation de l'adresse
  fpsetsockopt(FSocket, SOL_SOCKET, SO_REUSEADDR, @SO_REUSEADDR, SizeOf(Integer));

  // Configurer l'adresse du serveur
  serverAddr.sin_family := AF_INET;
  serverAddr.sin_port := htons(SERVER_PORT);
  serverAddr.sin_addr.s_addr := INADDR_ANY;

  // Lier le socket
  if fpBind(FSocket, @serverAddr, SizeOf(serverAddr)) = -1 then
  begin
    WriteLn('Erreur : Impossible de lier le socket au port ', SERVER_PORT);
    CloseSocket(FSocket);
    Exit;
  end;

  // Écouter les connexions
  if fpListen(FSocket, 5) = -1 then
  begin
    WriteLn('Erreur : Impossible d''écouter sur le socket');
    CloseSocket(FSocket);
    Exit;
  end;

  WriteLn('✓ Serveur démarré sur le port ', SERVER_PORT);
  WriteLn('✓ Accédez au serveur : http://raspberrypi.local:', SERVER_PORT);
  WriteLn;
  WriteLn('Appuyez sur Ctrl+C pour arrêter le serveur');
  WriteLn('───────────────────────────────────────────────────');
  WriteLn;

  FRunning := True;

  // Boucle principale
  while FRunning do
  begin
    // Accepter les connexions clientes
    clientSocket := fpAccept(FSocket, nil, nil);

    if clientSocket <> -1 then
    begin
      HandleClient(clientSocket);
    end;
  end;
end;

procedure THTTPServer.Stop;
begin
  FRunning := False;
  if FSocket <> -1 then
    CloseSocket(FSocket);
  WriteLn('Serveur arrêté');
end;

var
  server: THTTPServer;

begin
  server := THTTPServer.Create;
  try
    server.Start;
  finally
    server.Free;
  end;
end.
```

### Compilation et déploiement

```batch
# Compilation optimisée
fpc -Tlinux -Parm -O3 -Xs http_server.pas

# Déploiement
scp http_server pi@raspberrypi.local:/home/pi/

# Exécution (via SSH)
ssh pi@raspberrypi.local "chmod +x /home/pi/http_server && /home/pi/http_server"
```

### Créer un service systemd

**Sur le Raspberry Pi**, créer `/etc/systemd/system/httpserver.service` :

```ini
[Unit]
Description=Serveur HTTP FreePascal
After=network.target

[Service]
Type=simple
User=pi
WorkingDirectory=/home/pi
ExecStart=/home/pi/http_server
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
```

**Activer et démarrer le service** :

```bash
sudo systemctl daemon-reload
sudo systemctl enable httpserver.service
sudo systemctl start httpserver.service

# Vérifier le statut
sudo systemctl status httpserver.service
```

## Déploiement automatisé avancé

### Script PowerShell avec logs

Créer `Deploy-Advanced.ps1` :

```powershell
<#
.SYNOPSIS
    Déploiement avancé avec compilation, transfert, et logging
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectFile,

    [string]$RpiHost = "raspberrypi.local",
    [string]$RpiUser = "pi",
    [string]$RpiPath = "/home/pi",

    [switch]$OptimizeSize,
    [switch]$Debug,
    [switch]$CreateService,
    [switch]$AutoStart
)

$ErrorActionPreference = "Stop"
$LogFile = "deploy_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"

    Add-Content -Path $LogFile -Value $logMessage

    switch ($Level) {
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "WARN"  { Write-Host $Message -ForegroundColor Yellow }
        "OK"    { Write-Host $Message -ForegroundColor Green }
        default { Write-Host $Message }
    }
}

function Test-Prerequisites {
    Write-Log "Vérification des prérequis..." "INFO"

    # Vérifier FPC
    try {
        $fpcVersion = & fpc -iV
        Write-Log "✓ FreePascal trouvé : version $fpcVersion" "OK"
    } catch {
        Write-Log "✗ FreePascal introuvable" "ERROR"
        exit 1
    }

    # Vérifier SSH/SCP
    try {
        & ssh -V 2>&1 | Out-Null
        Write-Log "✓ OpenSSH trouvé" "OK"
    } catch {
        Write-Log "✗ OpenSSH introuvable - Installez-le via les fonctionnalités Windows" "ERROR"
        exit 1
    }

    # Tester la connexion au Raspberry Pi
    Write-Log "Test de connexion à $RpiHost..." "INFO"
    try {
        & ssh -o ConnectTimeout=5 "${RpiUser}@${RpiHost}" "echo 'OK'" 2>&1 | Out-Null
        Write-Log "✓ Connexion SSH réussie" "OK"
    } catch {
        Write-Log "✗ Impossible de se connecter au Raspberry Pi" "ERROR"
        Write-Log "  Vérifiez : 1) Le Pi est allumé, 2) SSH est activé, 3) L'adresse est correcte" "WARN"
        exit 1
    }
}

function Build-Project {
    Write-Log "═══════════════════════════════════════" "INFO"
    Write-Log "COMPILATION" "INFO"
    Write-Log "═══════════════════════════════════════" "INFO"

    $compileOptions = "-Tlinux -Parm"

    if ($Debug) {
        $compileOptions += " -g -gl -O-"
        Write-Log "Mode : DEBUG (avec symboles)" "INFO"
    } else {
        $compileOptions += " -O3"
        Write-Log "Mode : RELEASE (optimisé)" "INFO"
    }

    if ($OptimizeSize) {
        $compileOptions += " -Xs -XX"
        Write-Log "Option : Optimisation de taille activée" "INFO"
    }

    Write-Log "Options : $compileOptions" "INFO"
    Write-Log "Compilation de $ProjectFile..." "INFO"

    $compileCommand = "fpc $compileOptions $ProjectFile"
    Write-Log "Commande : $compileCommand" "INFO"

    try {
        Invoke-Expression $compileCommand 2>&1 | Tee-Object -Variable compileOutput

        if ($LASTEXITCODE -eq 0) {
            Write-Log "✓ Compilation réussie" "OK"

            $exeName = [System.IO.Path]::GetFileNameWithoutExtension($ProjectFile)
            $exeSize = (Get-Item $exeName).Length / 1KB
            Write-Log "  Taille de l'exécutable : $([math]::Round($exeSize, 2)) KB" "INFO"

            return $exeName
        } else {
            Write-Log "✗ Erreur de compilation" "ERROR"
            Write-Log $compileOutput "ERROR"
            exit 1
        }
    } catch {
        Write-Log "✗ Exception pendant la compilation : $($_.Exception.Message)" "ERROR"
        exit 1
    }
}

function Deploy-ToRaspberryPi {
    param([string]$ExecutableName)

    Write-Log "═══════════════════════════════════════" "INFO"
    Write-Log "DÉPLOIEMENT" "INFO"
    Write-Log "═══════════════════════════════════════" "INFO"

    Write-Log "Transfert vers ${RpiUser}@${RpiHost}:${RpiPath}/" "INFO"

    try {
        & scp $ExecutableName "${RpiUser}@${RpiHost}:${RpiPath}/"

        if ($LASTEXITCODE -eq 0) {
            Write-Log "✓ Transfert réussi" "OK"
        } else {
            Write-Log "✗ Erreur lors du transfert" "ERROR"
            exit 1
        }
    } catch {
        Write-Log "✗ Exception pendant le transfert : $($_.Exception.Message)" "ERROR"
        exit 1
    }

    Write-Log "Configuration des permissions..." "INFO"
    & ssh "${RpiUser}@${RpiHost}" "chmod +x ${RpiPath}/${ExecutableName}"
    Write-Log "✓ Permissions configurées" "OK"
}

function Create-SystemdService {
    param([string]$ExecutableName)

    Write-Log "═══════════════════════════════════════" "INFO"
    Write-Log "CRÉATION DU SERVICE SYSTEMD" "INFO"
    Write-Log "═══════════════════════════════════════" "INFO"

    $serviceName = $ExecutableName.ToLower()
    $serviceContent = @"
[Unit]
Description=$ExecutableName Service (FreePascal)
After=network.target

[Service]
Type=simple
User=$RpiUser
WorkingDirectory=$RpiPath
ExecStart=$RpiPath/$ExecutableName
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
"@

    Write-Log "Création du fichier service..." "INFO"

    # Créer le fichier temporaire localement
    $tempServiceFile = "$env:TEMP\$serviceName.service"
    Set-Content -Path $tempServiceFile -Value $serviceContent

    # Transférer et installer le service
    & scp $tempServiceFile "${RpiUser}@${RpiHost}:/tmp/$serviceName.service"
    & ssh "${RpiUser}@${RpiHost}" "sudo mv /tmp/$serviceName.service /etc/systemd/system/"
    & ssh "${RpiUser}@${RpiHost}" "sudo systemctl daemon-reload"
    & ssh "${RpiUser}@${RpiHost}" "sudo systemctl enable $serviceName.service"

    Write-Log "✓ Service systemd créé et activé" "OK"
    Write-Log "  Pour démarrer : sudo systemctl start $serviceName.service" "INFO"
    Write-Log "  Pour voir les logs : sudo journalctl -u $serviceName.service -f" "INFO"

    Remove-Item $tempServiceFile
}

# ═══════════════════════════════════════════════════════════
# SCRIPT PRINCIPAL
# ═══════════════════════════════════════════════════════════

Write-Host ""
Write-Host "═══════════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host "  Déploiement FreePascal → Raspberry Pi" -ForegroundColor Cyan
Write-Host "═══════════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host ""

Write-Log "Début du déploiement" "INFO"
Write-Log "Projet : $ProjectFile" "INFO"
Write-Log "Cible : ${RpiUser}@${RpiHost}" "INFO"

# Vérifier les prérequis
Test-Prerequisites

# Compiler le projet
$exeName = Build-Project

# Déployer sur le Raspberry Pi
Deploy-ToRaspberryPi -ExecutableName $exeName

# Créer un service systemd si demandé
if ($CreateService) {
    Create-SystemdService -ExecutableName $exeName
}

# Démarrer automatiquement si demandé
if ($AutoStart) {
    Write-Log "═══════════════════════════════════════" "INFO"
    Write-Log "DÉMARRAGE AUTOMATIQUE" "INFO"
    Write-Log "═══════════════════════════════════════" "INFO"

    if ($CreateService) {
        $serviceName = $exeName.ToLower()
        Write-Log "Démarrage du service $serviceName..." "INFO"
        & ssh "${RpiUser}@${RpiHost}" "sudo systemctl start $serviceName.service"
        Start-Sleep -Seconds 2
        & ssh "${RpiUser}@${RpiHost}" "sudo systemctl status $serviceName.service --no-pager"
    } else {
        Write-Log "Exécution du programme..." "INFO"
        & ssh "${RpiUser}@${RpiHost}" "${RpiPath}/${exeName}"
    }
}

Write-Host ""
Write-Host "═══════════════════════════════════════════════════════" -ForegroundColor Green
Write-Host "  DÉPLOIEMENT TERMINÉ AVEC SUCCÈS" -ForegroundColor Green
Write-Host "═══════════════════════════════════════════════════════" -ForegroundColor Green
Write-Host ""

Write-Log "Déploiement terminé avec succès" "OK"
Write-Log "Log sauvegardé dans : $LogFile" "INFO"

Write-Host "Pour exécuter manuellement :"
Write-Host "  ssh ${RpiUser}@${RpiHost}" -ForegroundColor Yellow
Write-Host "  ./${exeName}" -ForegroundColor Yellow
Write-Host ""
```

### Utilisation du script avancé

```powershell
# Déploiement simple
.\Deploy-Advanced.ps1 -ProjectFile http_server.pas

# Déploiement avec optimisation de taille
.\Deploy-Advanced.ps1 -ProjectFile http_server.pas -OptimizeSize

# Déploiement avec création de service et démarrage auto
.\Deploy-Advanced.ps1 -ProjectFile http_server.pas -CreateService -AutoStart

# Mode debug
.\Deploy-Advanced.ps1 -ProjectFile monapp.pas -Debug

# Vers une IP spécifique
.\Deploy-Advanced.ps1 -ProjectFile monapp.pas -RpiHost 192.168.1.100
```

## Dépannage (Troubleshooting)

### Problème 1 : "Error: Can't find unit system"

**Cause** : Les unités système ARM ne sont pas trouvées.

**Solution** :

```batch
# Vérifier les chemins dans fpc.cfg
fpc -va hello.pas

# Ajouter explicitement le chemin
fpc -Tlinux -Parm -FuC:\FPC\cross\arm-linux\lib hello.pas
```

### Problème 2 : "Error: Assembler arm-linux-gnueabihf-as not found"

**Cause** : Les binutils ARM ne sont pas dans le PATH.

**Solution** :

```batch
# Spécifier le chemin des binutils
fpc -Tlinux -Parm -FDC:\FPC\cross\arm-linux\bin hello.pas

# Ou ajouter au PATH système (via Panneau de configuration)
```

### Problème 3 : "Error: Can't call the linker"

**Cause** : Le linker ne trouve pas les bibliothèques.

**Solution** :

```batch
# Ajouter le chemin des bibliothèques
fpc -Tlinux -Parm -FlC:\FPC\cross\arm-linux\lib\arm-linux-gnueabihf hello.pas
```

### Problème 4 : Programme ne démarre pas sur le Raspberry Pi

**Symptômes** : `bash: ./monprogramme: cannot execute binary file: Exec format error`

**Causes possibles** :
1. Mauvaise architecture (compiled pour x86 au lieu de ARM)
2. Bibliothèques manquantes

**Solutions** :

```bash
# Sur le Raspberry Pi, vérifier l'architecture du fichier
file monprogramme
# Doit afficher : "ARM, version 1 (SYSV)" ou similaire

# Vérifier les dépendances manquantes
ldd monprogramme

# Si des bibliothèques sont manquantes, les installer
sudo apt install libnom-de-la-lib
```

### Problème 5 : Erreur de permission SSH/SCP

**Solution** :

```batch
# Configurer les clés SSH (évite de taper le mot de passe)
ssh-keygen -t rsa
ssh-copy-id pi@raspberrypi.local

# Tester la connexion
ssh pi@raspberrypi.local "echo 'Test OK'"
```

## Conseils et bonnes pratiques

### 1. Organisation du projet

```
MonProjet/
├── src/
│   ├── main.pas
│   ├── units/
│   │   ├── myunit.pas
│   │   └── helpers.pas
│   └── config/
│       └── settings.inc
├── build/
│   ├── windows/
│   └── arm-linux/
├── scripts/
│   ├── deploy-rpi.bat
│   └── Deploy-RaspberryPi.ps1
├── config/
│   └── fpc.cfg
└── README.md
```

### 2. Makefile pour automatisation

Créer un `Makefile` :

```makefile
# Makefile pour cross-compilation Raspberry Pi

PROJECT = monprojet
SOURCE = src/main.pas
FPC = fpc
TARGET_OS = linux
TARGET_CPU = arm
BUILD_DIR = build/arm-linux

# Options de compilation
FPC_OPTIONS = -T$(TARGET_OS) -P$(TARGET_CPU) -O3 -Xs -XX
FPC_PATHS = -FuC:\FPC\cross\arm-linux\lib

# Cible Raspberry Pi
RPI_HOST = raspberrypi.local
RPI_USER = pi
RPI_PATH = /home/pi

.PHONY: all clean build deploy run

all: build deploy

build:
	@echo "Compilation pour $(TARGET_CPU)-$(TARGET_OS)..."
	$(FPC) $(FPC_OPTIONS) $(FPC_PATHS) $(SOURCE) -o$(BUILD_DIR)/$(PROJECT)
	@echo "Compilation terminée : $(BUILD_DIR)/$(PROJECT)"

clean:
	@echo "Nettoyage des fichiers de build..."
	del /Q $(BUILD_DIR)\*.o $(BUILD_DIR)\*.ppu $(BUILD_DIR)\$(PROJECT)

deploy: build
	@echo "Transfert vers $(RPI_USER)@$(RPI_HOST)..."
	scp $(BUILD_DIR)/$(PROJECT) $(RPI_USER)@$(RPI_HOST):$(RPI_PATH)/
	ssh $(RPI_USER)@$(RPI_HOST) "chmod +x $(RPI_PATH)/$(PROJECT)"
	@echo "Déploiement terminé"

run: deploy
	@echo "Exécution sur Raspberry Pi..."
	ssh $(RPI_USER)@$(RPI_HOST) "$(RPI_PATH)/$(PROJECT)"

debug:
	@echo "Compilation en mode debug..."
	$(FPC) -T$(TARGET_OS) -P$(TARGET_CPU) -g -gl $(FPC_PATHS) $(SOURCE) -o$(BUILD_DIR)/$(PROJECT)

help:
	@echo "Makefile pour cross-compilation Raspberry Pi"
	@echo ""
	@echo "Commandes disponibles :"
	@echo "  make build   - Compiler le projet"
	@echo "  make clean   - Nettoyer les fichiers temporaires"
	@echo "  make deploy  - Compiler et déployer sur Raspberry Pi"
	@echo "  make run     - Compiler, déployer et exécuter"
	@echo "  make debug   - Compiler en mode debug"
	@echo "  make help    - Afficher cette aide"
```

**Utilisation** (nécessite `make` pour Windows, disponible via MinGW ou Chocolatey) :

```batch
# Installer make avec Chocolatey
choco install make

# Utiliser le Makefile
make build    # Compiler uniquement
make deploy   # Compiler et déployer
make run      # Compiler, déployer et exécuter
make clean    # Nettoyer
```

### 3. Script batch simplifié

Pour ceux qui préfèrent un script batch simple :

```batch
@echo off
REM ============================================
REM  Build & Deploy - Raspberry Pi
REM ============================================

SET PROJECT=monprojet
SET SOURCE=src\main.pas

SET RPI_HOST=raspberrypi.local
SET RPI_USER=pi
SET RPI_PATH=/home/pi

echo ========================================
echo  Compilation...
echo ========================================

fpc -Tlinux -Parm -O3 -Xs -XX %SOURCE% -o%PROJECT%

if %errorlevel% neq 0 (
    echo ERREUR: Compilation echouee
    pause
    exit /b 1
)

echo.
echo ========================================
echo  Deploiement...
echo ========================================

scp %PROJECT% %RPI_USER%@%RPI_HOST%:%RPI_PATH%/
ssh %RPI_USER%@%RPI_HOST% "chmod +x %RPI_PATH%/%PROJECT%"

echo.
echo ========================================
echo  TERMINE
echo ========================================
echo.
echo Pour executer:
echo   ssh %RPI_USER%@%RPI_HOST%
echo   ./%PROJECT%
echo.

pause
```

### 4. Gestion des versions

**Structure recommandée** :

```
MonProjet/
├── version.inc          # Fichier avec numéro de version
├── src/
│   └── main.pas
└── build/
    ├── v1.0.0/
    ├── v1.0.1/
    └── latest/
```

**Fichier version.inc** :

```pascal
{$DEFINE VERSION_MAJOR := 1}
{$DEFINE VERSION_MINOR := 0}
{$DEFINE VERSION_PATCH := 0}
```

**Utilisation dans le code** :

```pascal
program MonProjet;

{$mode objfpc}{$H+}
{$I version.inc}

const
  APP_VERSION = '1.0.0';  // À synchroniser avec version.inc
  BUILD_DATE = {$I %DATE%};
  BUILD_TIME = {$I %TIME%};

begin
  WriteLn('Application : MonProjet');
  WriteLn('Version     : ', APP_VERSION);
  WriteLn('Build       : ', BUILD_DATE, ' ', BUILD_TIME);
  WriteLn('Plateforme  : ', {$I %FPCTARGET%});
  WriteLn;
end.
```

### 5. Tests automatiques

**Script de test** (`test-deploy.bat`) :

```batch
@echo off
echo ========================================
echo  Tests de validation
echo ========================================

REM Compiler
fpc -Tlinux -Parm -O2 tests\test_units.pas -otest_runner

if %errorlevel% neq 0 (
    echo ERREUR: Compilation des tests echouee
    exit /b 1
)

REM Déployer
scp test_runner pi@raspberrypi.local:/home/pi/

REM Exécuter les tests
ssh pi@raspberrypi.local "/home/pi/test_runner"

if %errorlevel% neq 0 (
    echo ERREUR: Tests echoues
    exit /b 1
)

echo.
echo ========================================
echo  TOUS LES TESTS PASSES
echo ========================================
```

## Projet complet : Application de monitoring avec interface web

### Structure du projet

```
RaspberryMonitor/
├── src/
│   ├── main.pas
│   ├── webserver.pas
│   ├── sensors.pas
│   └── logger.pas
├── web/
│   ├── index.html
│   ├── style.css
│   └── app.js
├── config/
│   └── settings.ini
├── scripts/
│   └── deploy.ps1
└── README.md
```

### Code principal (main.pas)

```pascal
program RaspberryMonitor;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  SysUtils, Classes, webserver, sensors, logger;

const
  CONFIG_FILE = 'settings.ini';
  DEFAULT_PORT = 8080;

var
  server: TWebServer;
  sensorManager: TSensorManager;
  port: Integer;

procedure InitializeApplication;
begin
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn('  Raspberry Pi Monitor - FreePascal Edition');
  WriteLn('  Version 1.0.0');
  WriteLn('═══════════════════════════════════════════════════');
  WriteLn;

  // Initialiser le logger
  InitLogger('/var/log/rpimonitor.log');
  LogInfo('Application démarrée');

  // Lire la configuration
  if FileExists(CONFIG_FILE) then
  begin
    // Lecture du port depuis le fichier config
    port := DEFAULT_PORT;
    LogInfo('Configuration chargée');
  end
  else
  begin
    port := DEFAULT_PORT;
    LogWarning('Fichier de configuration non trouvé, utilisation des valeurs par défaut');
  end;

  // Initialiser le gestionnaire de capteurs
  sensorManager := TSensorManager.Create;
  LogInfo('Gestionnaire de capteurs initialisé');
end;

procedure StartServices;
begin
  WriteLn('Démarrage des services...');
  WriteLn;

  // Démarrer la surveillance des capteurs
  sensorManager.Start;
  WriteLn('✓ Capteurs : Actifs');

  // Démarrer le serveur web
  server := TWebServer.Create(port);
  server.SensorManager := sensorManager;

  WriteLn('✓ Serveur web : Port ', port);
  WriteLn;
  WriteLn('Accès : http://raspberrypi.local:', port);
  WriteLn('        http://', GetLocalIP, ':', port);
  WriteLn;
  WriteLn('Appuyez sur Ctrl+C pour arrêter');
  WriteLn('───────────────────────────────────────────────────');

  server.Start;
end;

procedure Cleanup;
begin
  WriteLn;
  WriteLn('Arrêt en cours...');

  if Assigned(server) then
  begin
    server.Stop;
    server.Free;
  end;

  if Assigned(sensorManager) then
  begin
    sensorManager.Stop;
    sensorManager.Free;
  end;

  LogInfo('Application arrêtée');
  WriteLn('Application arrêtée correctement');
end;

begin
  try
    InitializeApplication;
    StartServices;
  except
    on E: Exception do
    begin
      WriteLn('ERREUR FATALE: ', E.Message);
      LogError('Erreur fatale: ' + E.Message);
      ExitCode := 1;
    end;
  end;

  Cleanup;
end.
```

### Module capteurs (sensors.pas)

```pascal
unit sensors;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, fgl;

type
  TSensorData = record
    Temperature: Double;
    CPUUsage: Double;
    MemoryUsed: Int64;
    MemoryTotal: Int64;
    DiskUsed: Int64;
    DiskTotal: Int64;
    Uptime: Int64;
    Timestamp: TDateTime;
  end;

  TSensorDataList = specialize TFPGList<TSensorData>;

  { TSensorManager }
  TSensorManager = class(TThread)
  private
    FData: TSensorData;
    FHistory: TSensorDataList;
    FUpdateInterval: Integer;
    FLock: TRTLCriticalSection;
    procedure UpdateSensorData;
    function GetCPUTemperature: Double;
    function GetCPUUsage: Double;
    function GetMemoryInfo(out Used, Total: Int64): Boolean;
    function GetDiskInfo(out Used, Total: Int64): Boolean;
    function GetSystemUptime: Int64;
  protected
    procedure Execute; override;
  public
    constructor Create;
    destructor Destroy; override;
    function GetCurrentData: TSensorData;
    function GetHistory(Minutes: Integer): TSensorDataList;
    procedure Start;
    procedure Stop;
  end;

implementation

uses
  logger;

{ TSensorManager }

constructor TSensorManager.Create;
begin
  inherited Create(True); // Créer suspendu
  FreeOnTerminate := False;
  FUpdateInterval := 2000; // 2 secondes
  FHistory := TSensorDataList.Create;
  InitCriticalSection(FLock);
end;

destructor TSensorManager.Destroy;
begin
  DoneCriticalSection(FLock);
  FHistory.Free;
  inherited Destroy;
end;

function TSensorManager.GetCPUTemperature: Double;
var
  f: TextFile;
  tempStr: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    try
      AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
      Reset(f);
      ReadLn(f, tempStr);
      CloseFile(f);
      Result := StrToInt(tempStr) / 1000.0;
    except
      Result := 0.0;
    end;
  end;
end;

function TSensorManager.GetCPUUsage: Double;
var
  f: TextFile;
  line: string;
  values: array[0..9] of Int64;
  i, total, idle: Int64;
  static_total, static_idle: Int64;
begin
  // Implémentation simplifiée
  // Une vraie implémentation nécessiterait de comparer deux mesures
  Result := 0.0;

  if FileExists('/proc/stat') then
  begin
    try
      AssignFile(f, '/proc/stat');
      Reset(f);
      ReadLn(f, line);
      CloseFile(f);

      // Parser la ligne "cpu ..." et calculer l'usage
      // (Simplifié pour l'exemple)
      Result := Random * 100; // Placeholder
    except
      Result := 0.0;
    end;
  end;
end;

function TSensorManager.GetMemoryInfo(out Used, Total: Int64): Boolean;
var
  f: TextFile;
  line: string;
  memTotal, memAvailable: Int64;
begin
  Result := False;
  memTotal := 0;
  memAvailable := 0;

  if FileExists('/proc/meminfo') then
  begin
    try
      AssignFile(f, '/proc/meminfo');
      Reset(f);

      while not Eof(f) do
      begin
        ReadLn(f, line);
        if Pos('MemTotal:', line) > 0 then
          memTotal := StrToInt64Def(ExtractWord(2, line, [' ']), 0) * 1024;
        if Pos('MemAvailable:', line) > 0 then
          memAvailable := StrToInt64Def(ExtractWord(2, line, [' ']), 0) * 1024;
      end;

      CloseFile(f);

      Total := memTotal;
      Used := memTotal - memAvailable;
      Result := True;
    except
      Result := False;
    end;
  end;
end;

function TSensorManager.GetDiskInfo(out Used, Total: Int64): Boolean;
var
  fs: TStatFS;
begin
  Result := False;

  try
    if fpStatFS('/', @fs) = 0 then
    begin
      Total := Int64(fs.bavail) * fs.bsize;
      Used := (Int64(fs.blocks) - Int64(fs.bfree)) * fs.bsize;
      Result := True;
    end;
  except
    Result := False;
  end;
end;

function TSensorManager.GetSystemUptime: Int64;
var
  f: TextFile;
  uptimeStr: string;
begin
  Result := 0;

  if FileExists('/proc/uptime') then
  begin
    try
      AssignFile(f, '/proc/uptime');
      Reset(f);
      ReadLn(f, uptimeStr);
      CloseFile(f);

      Result := Trunc(StrToFloatDef(Copy(uptimeStr, 1, Pos(' ', uptimeStr) - 1), 0));
    except
      Result := 0;
    end;
  end;
end;

procedure TSensorManager.UpdateSensorData;
var
  newData: TSensorData;
  memUsed, memTotal, diskUsed, diskTotal: Int64;
begin
  newData.Timestamp := Now;
  newData.Temperature := GetCPUTemperature;
  newData.CPUUsage := GetCPUUsage;
  newData.Uptime := GetSystemUptime;

  if GetMemoryInfo(memUsed, memTotal) then
  begin
    newData.MemoryUsed := memUsed;
    newData.MemoryTotal := memTotal;
  end;

  if GetDiskInfo(diskUsed, diskTotal) then
  begin
    newData.DiskUsed := diskUsed;
    newData.DiskTotal := diskTotal;
  end;

  EnterCriticalSection(FLock);
  try
    FData := newData;
    FHistory.Add(newData);

    // Garder seulement les 30 dernières minutes (900 entrées à 2s)
    while FHistory.Count > 900 do
      FHistory.Delete(0);
  finally
    LeaveCriticalSection(FLock);
  end;
end;

procedure TSensorManager.Execute;
begin
  LogInfo('Thread de surveillance des capteurs démarré');

  while not Terminated do
  begin
    UpdateSensorData;
    Sleep(FUpdateInterval);
  end;

  LogInfo('Thread de surveillance des capteurs arrêté');
end;

function TSensorManager.GetCurrentData: TSensorData;
begin
  EnterCriticalSection(FLock);
  try
    Result := FData;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

function TSensorManager.GetHistory(Minutes: Integer): TSensorDataList;
var
  i, startIndex: Integer;
begin
  Result := TSensorDataList.Create;

  EnterCriticalSection(FLock);
  try
    // Calculer l'index de départ (30 entrées par minute à 2s d'intervalle)
    startIndex := FHistory.Count - (Minutes * 30);
    if startIndex < 0 then
      startIndex := 0;

    for i := startIndex to FHistory.Count - 1 do
      Result.Add(FHistory[i]);
  finally
    LeaveCriticalSection(FLock);
  end;
end;

procedure TSensorManager.Start;
begin
  inherited Start;
end;

procedure TSensorManager.Stop;
begin
  Terminate;
  WaitFor;
end;

end.
```

### Compilation et déploiement complet

**Script PowerShell** (`scripts/deploy.ps1`) :

```powershell
param(
    [string]$RpiHost = "raspberrypi.local",
    [switch]$InstallService
)

Write-Host "═══════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host "  Déploiement RaspberryMonitor" -ForegroundColor Cyan
Write-Host "═══════════════════════════════════════════════════" -ForegroundColor Cyan

# Compilation
Write-Host "`n[1/5] Compilation..." -ForegroundColor Yellow
fpc -Tlinux -Parm -O3 -Xs -XX src/main.pas -oRaspberryMonitor

if ($LASTEXITCODE -ne 0) {
    Write-Host "Erreur de compilation" -ForegroundColor Red
    exit 1
}
Write-Host "✓ Compilation réussie" -ForegroundColor Green

# Création du package
Write-Host "`n[2/5] Création du package..." -ForegroundColor Yellow
$tempDir = "temp_deploy"
New-Item -ItemType Directory -Force -Path $tempDir | Out-Null

Copy-Item "RaspberryMonitor" "$tempDir/"
Copy-Item -Recurse "web" "$tempDir/"
Copy-Item "config/settings.ini" "$tempDir/"

Write-Host "✓ Package créé" -ForegroundColor Green

# Transfert
Write-Host "`n[3/5] Transfert vers $RpiHost..." -ForegroundColor Yellow
scp -r "$tempDir/*" "pi@${RpiHost}:/home/pi/rpimonitor/"

if ($LASTEXITCODE -ne 0) {
    Write-Host "Erreur de transfert" -ForegroundColor Red
    Remove-Item -Recurse -Force $tempDir
    exit 1
}
Write-Host "✓ Transfert réussi" -ForegroundColor Green

# Permissions
Write-Host "`n[4/5] Configuration des permissions..." -ForegroundColor Yellow
ssh "pi@${RpiHost}" "chmod +x /home/pi/rpimonitor/RaspberryMonitor"
Write-Host "✓ Permissions configurées" -ForegroundColor Green

# Installation du service (optionnel)
if ($InstallService) {
    Write-Host "`n[5/5] Installation du service systemd..." -ForegroundColor Yellow

    $serviceContent = @'
[Unit]
Description=Raspberry Pi Monitor (FreePascal)
After=network.target

[Service]
Type=simple
User=pi
WorkingDirectory=/home/pi/rpimonitor
ExecStart=/home/pi/rpimonitor/RaspberryMonitor
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
'@

    Set-Content -Path "$tempDir/rpimonitor.service" -Value $serviceContent
    scp "$tempDir/rpimonitor.service" "pi@${RpiHost}:/tmp/"
    ssh "pi@${RpiHost}" @"
sudo mv /tmp/rpimonitor.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable rpimonitor.service
sudo systemctl start rpimonitor.service
"@

    Write-Host "✓ Service installé et démarré" -ForegroundColor Green
}

# Nettoyage
Remove-Item -Recurse -Force $tempDir

Write-Host "`n═══════════════════════════════════════════════════" -ForegroundColor Green
Write-Host "  DÉPLOIEMENT TERMINÉ" -ForegroundColor Green
Write-Host "═══════════════════════════════════════════════════" -ForegroundColor Green

Write-Host "`nAccès : http://${RpiHost}:8080" -ForegroundColor Yellow

if ($InstallService) {
    Write-Host "`nGestion du service :"
    Write-Host "  sudo systemctl status rpimonitor" -ForegroundColor Cyan
    Write-Host "  sudo systemctl stop rpimonitor" -ForegroundColor Cyan
    Write-Host "  sudo journalctl -u rpimonitor -f" -ForegroundColor Cyan
}
```

**Utilisation** :

```powershell
# Déploiement simple
.\scripts\deploy.ps1

# Déploiement avec installation du service
.\scripts\deploy.ps1 -InstallService

# Vers une IP spécifique
.\scripts\deploy.ps1 -RpiHost 192.168.1.50 -InstallService
```

## Performances et optimisations

### Comparaison des temps de compilation

**Test avec un projet de 5000 lignes** :

| Méthode | Temps (min:s) | Observations |
|---------|---------------|--------------|
| Sur Raspberry Pi 3 | 12:45 | Référence |
| Sur Raspberry Pi 4 | 8:30 | 33% plus rapide |
| Cross-compilation PC i5 | 0:35 | **21x plus rapide !** |
| Cross-compilation PC i9 | 0:18 | **42x plus rapide !** |

### Taille des exécutables selon les options

**Programme de test : 500 lignes avec LCL** :

| Options de compilation | Taille | Temps | Commentaire |
|------------------------|--------|-------|-------------|
| Aucune | 2.8 MB | Rapide | Développement |
| `-O2` | 2.1 MB | Moyen | Équilibré |
| `-O3 -Xs` | 1.6 MB | Moyen | Production |
| `-O3 -Xs -XX` | 890 KB | Lent | Optimisé taille |
| Avec UPX | 340 KB | - | Compression post-build |

### Utilisation d'UPX pour compresser

UPX (Ultimate Packer for eXecutables) peut réduire encore la taille :

```batch
# Télécharger UPX : https://upx.github.io/

# Compiler
fpc -Tlinux -Parm -O3 -Xs -XX monprogramme.pas

# Compresser avec UPX
upx --best monprogramme

# Résultat : réduction de 60-70% de la taille
```

## Ressources et références

### Documentation officielle

- **FreePascal Wiki - ARM** : https://wiki.freepascal.org/ARM_Linux
- **FreePascal Wiki - Cross Compile** : https://wiki.freepascal.org/Cross_compiling
- **Lazarus Wiki - Raspberry Pi** : https://wiki.lazarus.freepascal.org/Raspberry_Pi

### Outils recommandés

| Outil | Utilité | Lien |
|-------|---------|------|
| **FpcUpDeluxe** | Installation automatique | https://github.com/LongDirtyAnimAlf/fpcupdeluxe |
| **WinSCP** | Transfert fichiers GUI | https://winscp.net/ |
| **PuTTY** | Client SSH | https://www.putty.org/ |
| **VS Code Remote** | Développement distant | https://code.visualstudio.com/ |
| **UPX** | Compression exécutables | https://upx.github.io/ |

### Communauté et support

- **Forum Lazarus** : https://forum.lazarus.freepascal.org/
- **Forum Raspberry Pi** : https://forums.raspberrypi.com/
- **Reddit /r/freepascal** : Communauté active
- **Discord FreePascal** : Support en temps réel

## Conclusion

La **cross-compilation depuis Windows** pour Raspberry Pi avec FreePascal offre de nombreux avantages :

### ✅ Avantages
- **Rapidité** : Compilation 20-40x plus rapide qu'en natif
- **Confort** : Développement sur PC avec IDE complet
- **Efficacité** : Workflow optimisé (édition → compilation → déploiement)
- **Performance** : Code natif ARM haute performance

### ⚠️ Points d'attention
- Configuration initiale complexe
- Maintenance du toolchain
- Gestion des dépendances système
- Besoin de synchronisation avec le Raspberry Pi

### 🎯 Recommandations finales

1. **Débutants** : Utilisez **FpcUpDeluxe** pour l'installation automatique
2. **Workflow** : Automatisez avec PowerShell ou scripts batch
3. **Tests** : Testez régulièrement sur le Raspberry Pi réel
4. **Production** : Utilisez les options d'optimisation `-O3 -Xs -XX`
5. **CI/CD** : Intégrez dans un pipeline automatisé

La cross-compilation est la méthode professionnelle pour développer efficacement des applications FreePascal destinées au Raspberry Pi, combinant la puissance de votre PC de développement avec la flexibilité de la plateforme ARM.

---

**Prochaine section** : **13.7.2 Développement natif sur Ubuntu ARM** - Nous verrons comment développer directement sur le Raspberry Pi ou sur un système Ubuntu ARM.

> 💡 **Astuce finale** : Créez un dépôt Git pour vos projets et utilisez GitHub Actions pour automatiser la cross-compilation et le déploiement sur chaque commit !

⏭️ [Développement natif sur Ubuntu ARM](/13-developpement-mobile-embarque/07.2-developpement-natif-ubuntu-arm.md)
