üîù Retour au [Sommaire](/SOMMAIRE.md)

# 23.4.3 OpenAL (universel)

## Introduction

**OpenAL** (Open Audio Library) est une API audio 3D multi-plateforme con√ßue sp√©cifiquement pour les jeux. C'est l'√©quivalent audio d'OpenGL pour les graphiques. OpenAL fonctionne sur Windows, Linux, macOS, iOS, Android et m√™me sur consoles.

### Pourquoi choisir OpenAL ?

**Avantages** :
- **Multi-plateforme** : Un seul code pour Windows, Linux et macOS
- **Audio 3D natif** : Positionnement spatial, effet Doppler, att√©nuation
- **Simple et puissant** : API intuitive mais compl√®te
- **Standard industriel** : Utilis√© dans des milliers de jeux
- **Open source** : OpenAL Soft est gratuit et activement maintenu
- **Bien document√©** : Nombreux tutoriels et exemples
- **Performant** : Gestion efficace de nombreux sons simultan√©s

**Inconv√©nients** :
- Pas d'effets avanc√©s natifs (reverb n√©cessite des extensions)
- API C n√©cessite des bindings Pascal
- Pas de streaming audio natif (doit √™tre impl√©ment√©)

### Concepts fondamentaux

OpenAL utilise une m√©taphore simple bas√©e sur le monde r√©el :

1. **Listener** (Auditeur) : Repr√©sente le joueur/la cam√©ra, unique
2. **Sources** (Sources) : Sons √©mis dans le monde 3D
3. **Buffers** (Tampons) : Donn√©es audio charg√©es en m√©moire
4. **Context** (Contexte) : Environnement de rendu audio
5. **Device** (P√©riph√©rique) : Carte son physique

**Analogie** : Imaginez une sc√®ne de th√©√¢tre. Le **listener** est le spectateur, les **sources** sont les acteurs qui parlent, les **buffers** sont leurs scripts m√©moris√©s, le **context** est la salle de th√©√¢tre, et le **device** est le syst√®me de sonorisation.

## Installation

### Windows

**Option 1 : OpenAL Soft (recommand√©)**
1. T√©l√©chargez OpenAL Soft depuis https://openal-soft.org/
2. Extrayez `OpenAL32.dll` (32-bit) ou `OpenAL64.dll` (64-bit)
3. Placez-le dans le dossier de votre application ou dans `C:\Windows\System32\`

**Option 2 : Installeur officiel**
1. T√©l√©chargez depuis https://www.openal.org/downloads/
2. Installez `oalinst.exe`

### Linux

```bash
# Ubuntu/Debian
sudo apt-get install libopenal-dev libopenal1

# Fedora/RHEL
sudo dnf install openal-soft openal-soft-devel

# Arch Linux
sudo pacman -S openal

# V√©rifier l'installation
ldconfig -p | grep openal
```

### macOS

OpenAL est pr√©install√© sur macOS (framework syst√®me).

```bash
# V√©rifier
ls /System/Library/Frameworks/OpenAL.framework/
```

## Bindings Pascal complets pour OpenAL

```pascal
unit OpenAL;

{$mode objfpc}{$H+}
{$PACKRECORDS C}

interface

const
  {$IFDEF WINDOWS}
    {$IFDEF CPU64}
    OPENAL_LIB = 'OpenAL64.dll';
    {$ELSE}
    OPENAL_LIB = 'OpenAL32.dll';
    {$ENDIF}
  {$ENDIF}

  {$IFDEF LINUX}
  OPENAL_LIB = 'libopenal.so.1';
  {$ENDIF}

  {$IFDEF DARWIN}
  OPENAL_LIB = 'OpenAL.framework/OpenAL';
  {$ENDIF}

type
  // Types de base
  ALboolean = Boolean;
  ALchar = Char;
  ALbyte = ShortInt;
  ALubyte = Byte;
  ALshort = SmallInt;
  ALushort = Word;
  ALint = Integer;
  ALuint = Cardinal;
  ALsizei = Integer;
  ALenum = Integer;
  ALfloat = Single;
  ALdouble = Double;
  ALvoid = Pointer;

const
  // Valeurs bool√©ennes
  AL_FALSE = 0;
  AL_TRUE = 1;

  // Formats audio
  AL_FORMAT_MONO8 = $1100;
  AL_FORMAT_MONO16 = $1101;
  AL_FORMAT_STEREO8 = $1102;
  AL_FORMAT_STEREO16 = $1103;

  // √âtats de source
  AL_INITIAL = $1011;
  AL_PLAYING = $1012;
  AL_PAUSED = $1013;
  AL_STOPPED = $1014;

  // Propri√©t√©s de source
  AL_SOURCE_RELATIVE = $202;
  AL_CONE_INNER_ANGLE = $1001;
  AL_CONE_OUTER_ANGLE = $1002;
  AL_PITCH = $1003;
  AL_POSITION = $1004;
  AL_DIRECTION = $1005;
  AL_VELOCITY = $1006;
  AL_LOOPING = $1007;
  AL_BUFFER = $1009;
  AL_GAIN = $100A;
  AL_MIN_GAIN = $100D;
  AL_MAX_GAIN = $100E;
  AL_ORIENTATION = $100F;
  AL_SOURCE_STATE = $1010;
  AL_BUFFERS_QUEUED = $1015;
  AL_BUFFERS_PROCESSED = $1016;
  AL_REFERENCE_DISTANCE = $1020;
  AL_ROLLOFF_FACTOR = $1021;
  AL_CONE_OUTER_GAIN = $1022;
  AL_MAX_DISTANCE = $1023;
  AL_SEC_OFFSET = $1024;
  AL_SAMPLE_OFFSET = $1025;
  AL_BYTE_OFFSET = $1026;
  AL_SOURCE_TYPE = $1027;

  // Types de source
  AL_STATIC = $1028;
  AL_STREAMING = $1029;
  AL_UNDETERMINED = $1030;

  // Propri√©t√©s de listener
  AL_METERS_PER_UNIT = $20004;

  // Propri√©t√©s de buffer
  AL_FREQUENCY = $2001;
  AL_BITS = $2002;
  AL_CHANNELS = $2003;
  AL_SIZE = $2004;

  // Erreurs
  AL_NO_ERROR = 0;
  AL_INVALID_NAME = $A001;
  AL_INVALID_ENUM = $A002;
  AL_INVALID_VALUE = $A003;
  AL_INVALID_OPERATION = $A004;
  AL_OUT_OF_MEMORY = $A005;

  // Propri√©t√©s de contexte
  ALC_FREQUENCY = $1007;
  ALC_REFRESH = $1008;
  ALC_SYNC = $1009;
  ALC_MONO_SOURCES = $1010;
  ALC_STEREO_SOURCES = $1011;

  // Erreurs de contexte
  ALC_NO_ERROR = 0;
  ALC_INVALID_DEVICE = $A001;
  ALC_INVALID_CONTEXT = $A002;
  ALC_INVALID_ENUM = $A003;
  ALC_INVALID_VALUE = $A004;
  ALC_OUT_OF_MEMORY = $A005;

  // Extensions
  ALC_EXTENSIONS = $1006;
  AL_EXTENSIONS = $B004;

// ============================================================================
// Fonctions de gestion des p√©riph√©riques et contextes (ALC)
// ============================================================================

// Ouvrir/fermer un p√©riph√©rique
function alcOpenDevice(devicename: PChar): Pointer; cdecl; external OPENAL_LIB;
function alcCloseDevice(device: Pointer): ALboolean; cdecl; external OPENAL_LIB;

// Cr√©er/d√©truire un contexte
function alcCreateContext(device: Pointer; attrlist: PALint): Pointer; cdecl; external OPENAL_LIB;
function alcMakeContextCurrent(context: Pointer): ALboolean; cdecl; external OPENAL_LIB;
procedure alcProcessContext(context: Pointer); cdecl; external OPENAL_LIB;
procedure alcSuspendContext(context: Pointer); cdecl; external OPENAL_LIB;
procedure alcDestroyContext(context: Pointer); cdecl; external OPENAL_LIB;
function alcGetCurrentContext: Pointer; cdecl; external OPENAL_LIB;
function alcGetContextsDevice(context: Pointer): Pointer; cdecl; external OPENAL_LIB;

// Gestion d'erreurs
function alcGetError(device: Pointer): ALenum; cdecl; external OPENAL_LIB;

// Informations
function alcIsExtensionPresent(device: Pointer; const extname: PChar): ALboolean; cdecl; external OPENAL_LIB;
function alcGetProcAddress(device: Pointer; const funcname: PChar): Pointer; cdecl; external OPENAL_LIB;
function alcGetEnumValue(device: Pointer; const enumname: PChar): ALenum; cdecl; external OPENAL_LIB;
function alcGetString(device: Pointer; param: ALenum): PChar; cdecl; external OPENAL_LIB;
procedure alcGetIntegerv(device: Pointer; param: ALenum; size: ALsizei; values: PALint); cdecl; external OPENAL_LIB;

// ============================================================================
// Fonctions principales OpenAL (AL)
// ============================================================================

// Gestion d'erreurs
function alGetError: ALenum; cdecl; external OPENAL_LIB;

// Extensions
function alIsExtensionPresent(const extname: PChar): ALboolean; cdecl; external OPENAL_LIB;
function alGetProcAddress(const fname: PChar): Pointer; cdecl; external OPENAL_LIB;
function alGetEnumValue(const ename: PChar): ALenum; cdecl; external OPENAL_LIB;

// Informations
function alGetString(param: ALenum): PChar; cdecl; external OPENAL_LIB;
procedure alGetBooleanv(param: ALenum; values: PALboolean); cdecl; external OPENAL_LIB;
procedure alGetIntegerv(param: ALenum; values: PALint); cdecl; external OPENAL_LIB;
procedure alGetFloatv(param: ALenum; values: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetDoublev(param: ALenum; values: PALdouble); cdecl; external OPENAL_LIB;
function alGetBoolean(param: ALenum): ALboolean; cdecl; external OPENAL_LIB;
function alGetInteger(param: ALenum): ALint; cdecl; external OPENAL_LIB;
function alGetFloat(param: ALenum): ALfloat; cdecl; external OPENAL_LIB;
function alGetDouble(param: ALenum): ALdouble; cdecl; external OPENAL_LIB;

// ============================================================================
// Gestion du Listener (auditeur)
// ============================================================================

procedure alListenerf(param: ALenum; value: ALfloat); cdecl; external OPENAL_LIB;
procedure alListener3f(param: ALenum; value1, value2, value3: ALfloat); cdecl; external OPENAL_LIB;
procedure alListenerfv(param: ALenum; const values: PALfloat); cdecl; external OPENAL_LIB;
procedure alListeneri(param: ALenum; value: ALint); cdecl; external OPENAL_LIB;
procedure alListener3i(param: ALenum; value1, value2, value3: ALint); cdecl; external OPENAL_LIB;
procedure alListeneriv(param: ALenum; const values: PALint); cdecl; external OPENAL_LIB;

procedure alGetListenerf(param: ALenum; value: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetListener3f(param: ALenum; value1, value2, value3: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetListenerfv(param: ALenum; values: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetListeneri(param: ALenum; value: PALint); cdecl; external OPENAL_LIB;
procedure alGetListener3i(param: ALenum; value1, value2, value3: PALint); cdecl; external OPENAL_LIB;
procedure alGetListeneriv(param: ALenum; values: PALint); cdecl; external OPENAL_LIB;

// ============================================================================
// Gestion des Sources (√©metteurs de son)
// ============================================================================

procedure alGenSources(n: ALsizei; sources: PALuint); cdecl; external OPENAL_LIB;
procedure alDeleteSources(n: ALsizei; const sources: PALuint); cdecl; external OPENAL_LIB;
function alIsSource(source: ALuint): ALboolean; cdecl; external OPENAL_LIB;

// Propri√©t√©s des sources (setters)
procedure alSourcef(source: ALuint; param: ALenum; value: ALfloat); cdecl; external OPENAL_LIB;
procedure alSource3f(source: ALuint; param: ALenum; value1, value2, value3: ALfloat); cdecl; external OPENAL_LIB;
procedure alSourcefv(source: ALuint; param: ALenum; const values: PALfloat); cdecl; external OPENAL_LIB;
procedure alSourcei(source: ALuint; param: ALenum; value: ALint); cdecl; external OPENAL_LIB;
procedure alSource3i(source: ALuint; param: ALenum; value1, value2, value3: ALint); cdecl; external OPENAL_LIB;
procedure alSourceiv(source: ALuint; param: ALenum; const values: PALint); cdecl; external OPENAL_LIB;

// Propri√©t√©s des sources (getters)
procedure alGetSourcef(source: ALuint; param: ALenum; value: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetSource3f(source: ALuint; param: ALenum; value1, value2, value3: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetSourcefv(source: ALuint; param: ALenum; values: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetSourcei(source: ALuint; param: ALenum; value: PALint); cdecl; external OPENAL_LIB;
procedure alGetSource3i(source: ALuint; param: ALenum; value1, value2, value3: PALint); cdecl; external OPENAL_LIB;
procedure alGetSourceiv(source: ALuint; param: ALenum; values: PALint); cdecl; external OPENAL_LIB;

// Contr√¥le de lecture
procedure alSourcePlay(source: ALuint); cdecl; external OPENAL_LIB;
procedure alSourceStop(source: ALuint); cdecl; external OPENAL_LIB;
procedure alSourceRewind(source: ALuint); cdecl; external OPENAL_LIB;
procedure alSourcePause(source: ALuint); cdecl; external OPENAL_LIB;

// Contr√¥le de lecture multiple
procedure alSourcePlayv(n: ALsizei; const sources: PALuint); cdecl; external OPENAL_LIB;
procedure alSourceStopv(n: ALsizei; const sources: PALuint); cdecl; external OPENAL_LIB;
procedure alSourceRewindv(n: ALsizei; const sources: PALuint); cdecl; external OPENAL_LIB;
procedure alSourcePausev(n: ALsizei; const sources: PALuint); cdecl; external OPENAL_LIB;

// File d'attente de buffers (pour streaming)
procedure alSourceQueueBuffers(source: ALuint; nb: ALsizei; const buffers: PALuint); cdecl; external OPENAL_LIB;
procedure alSourceUnqueueBuffers(source: ALuint; nb: ALsizei; buffers: PALuint); cdecl; external OPENAL_LIB;

// ============================================================================
// Gestion des Buffers (donn√©es audio)
// ============================================================================

procedure alGenBuffers(n: ALsizei; buffers: PALuint); cdecl; external OPENAL_LIB;
procedure alDeleteBuffers(n: ALsizei; const buffers: PALuint); cdecl; external OPENAL_LIB;
function alIsBuffer(buffer: ALuint): ALboolean; cdecl; external OPENAL_LIB;

// Charger des donn√©es dans un buffer
procedure alBufferData(buffer: ALuint; format: ALenum; const data: Pointer; size: ALsizei; freq: ALsizei); cdecl; external OPENAL_LIB;

// Propri√©t√©s des buffers
procedure alBufferf(buffer: ALuint; param: ALenum; value: ALfloat); cdecl; external OPENAL_LIB;
procedure alBuffer3f(buffer: ALuint; param: ALenum; value1, value2, value3: ALfloat); cdecl; external OPENAL_LIB;
procedure alBufferfv(buffer: ALuint; param: ALenum; const values: PALfloat); cdecl; external OPENAL_LIB;
procedure alBufferi(buffer: ALuint; param: ALenum; value: ALint); cdecl; external OPENAL_LIB;
procedure alBuffer3i(buffer: ALuint; param: ALenum; value1, value2, value3: ALint); cdecl; external OPENAL_LIB;
procedure alBufferiv(buffer: ALuint; param: ALenum; const values: PALint); cdecl; external OPENAL_LIB;

procedure alGetBufferf(buffer: ALuint; param: ALenum; value: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetBuffer3f(buffer: ALuint; param: ALenum; value1, value2, value3: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetBufferfv(buffer: ALuint; param: ALenum; values: PALfloat); cdecl; external OPENAL_LIB;
procedure alGetBufferi(buffer: ALuint; param: ALenum; value: PALint); cdecl; external OPENAL_LIB;
procedure alGetBuffer3i(buffer: ALuint; param: ALenum; value1, value2, value3: PALint); cdecl; external OPENAL_LIB;
procedure alGetBufferiv(buffer: ALuint; param: ALenum; values: PALint); cdecl; external OPENAL_LIB;

// ============================================================================
// Fonctions utilitaires
// ============================================================================

procedure alDopplerFactor(value: ALfloat); cdecl; external OPENAL_LIB;
procedure alDopplerVelocity(value: ALfloat); cdecl; external OPENAL_LIB;
procedure alSpeedOfSound(value: ALfloat); cdecl; external OPENAL_LIB;
procedure alDistanceModel(distanceModel: ALenum); cdecl; external OPENAL_LIB;

// Mod√®les de distance
const
  AL_NONE = 0;
  AL_INVERSE_DISTANCE = $D001;
  AL_INVERSE_DISTANCE_CLAMPED = $D002;
  AL_LINEAR_DISTANCE = $D003;
  AL_LINEAR_DISTANCE_CLAMPED = $D004;
  AL_EXPONENT_DISTANCE = $D005;
  AL_EXPONENT_DISTANCE_CLAMPED = $D006;

implementation

end.
```

---

## Wrapper de haut niveau pour OpenAL

Cr√©ons une interface Pascal intuitive pour faciliter l'utilisation d'OpenAL.

```pascal
unit OpenALWrapper;

{$mode objfpc}{$H+}

interface

uses
  OpenAL, Classes, SysUtils;

type
  // Classe repr√©sentant un son
  TOpenALSound = class
  private
    FBuffer: ALuint;
    FSource: ALuint;
    FFilename: string;
    FDuration: Single;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    // Contr√¥le de lecture
    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure Pause;
    procedure Resume;
    procedure Rewind;

    // √âtat
    function IsPlaying: Boolean;
    function IsPaused: Boolean;
    function IsStopped: Boolean;

    // Propri√©t√©s audio
    procedure SetVolume(Volume: Single);
    procedure SetPitch(Pitch: Single);
    procedure SetLooping(Loop: Boolean);

    function GetVolume: Single;
    function GetPitch: Single;
    function GetLooping: Boolean;

    // Audio 3D
    procedure SetPosition(X, Y, Z: Single);
    procedure SetVelocity(VX, VY, VZ: Single);
    procedure SetDirection(DX, DY, DZ: Single);

    procedure GetPosition(out X, Y, Z: Single);
    procedure GetVelocity(out VX, VY, VZ: Single);

    // Propri√©t√©s avanc√©es
    procedure SetReferenceDistance(Distance: Single);
    procedure SetMaxDistance(Distance: Single);
    procedure SetRolloffFactor(Factor: Single);
    procedure SetRelativeToListener(Relative: Boolean);

    // Informations
    function GetPlaybackPosition: Single; // En secondes
    procedure SetPlaybackPosition(Seconds: Single);

    property Filename: string read FFilename;
    property Duration: Single read FDuration;
    property Buffer: ALuint read FBuffer;
    property Source: ALuint read FSource;
  end;

  // Syst√®me audio principal
  TOpenALSystem = class
  private
    FDevice: Pointer;
    FContext: Pointer;
    FSounds: TList;
    FInitialized: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    // Chargement de sons
    function LoadSound(const Filename: string): TOpenALSound;
    procedure UnloadSound(Sound: TOpenALSound);
    procedure UnloadAll;

    // Contr√¥le du listener (joueur/cam√©ra)
    procedure SetListenerPosition(X, Y, Z: Single);
    procedure SetListenerVelocity(VX, VY, VZ: Single);
    procedure SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ: Single);
    procedure SetListenerGain(Gain: Single);

    procedure GetListenerPosition(out X, Y, Z: Single);
    procedure GetListenerVelocity(out VX, VY, VZ: Single);

    // Param√®tres globaux
    procedure SetSpeedOfSound(Speed: Single);
    procedure SetDopplerFactor(Factor: Single);
    procedure SetDistanceModel(Model: ALenum);

    // Contr√¥le g√©n√©ral
    procedure StopAllSounds;
    procedure PauseAllSounds;
    procedure ResumeAllSounds;

    // Informations
    function GetVersion: string;
    function GetVendor: string;
    function GetRenderer: string;
    function GetExtensions: string;
    function IsExtensionSupported(const Extension: string): Boolean;

    property Initialized: Boolean read FInitialized;
    property Device: Pointer read FDevice;
    property Context: Pointer read FContext;
  end;

implementation

{ Fonctions utilitaires }

function LoadWaveFile(const Filename: string; out Format: ALenum;
  out Data: Pointer; out Size: ALsizei; out Frequency: ALsizei): Boolean;
var
  WaveFile: TFileStream;
  Header: array[0..43] of Byte;
  Channels: Word;
  SampleRate: Cardinal;
  BitsPerSample: Word;
  AudioSize: Cardinal;
begin
  Result := False;
  Data := nil;

  if not FileExists(Filename) then
  begin
    WriteLn('Erreur: Fichier introuvable: ', Filename);
    Exit;
  end;

  try
    WaveFile := TFileStream.Create(Filename, fmOpenRead);
    try
      // Lire l'en-t√™te WAV (44 octets)
      if WaveFile.Size < 44 then
      begin
        WriteLn('Erreur: Fichier WAV trop petit');
        Exit;
      end;

      WaveFile.Read(Header, 44);

      // V√©rifier la signature RIFF
      if (Chr(Header[0]) + Chr(Header[1]) + Chr(Header[2]) + Chr(Header[3]) <> 'RIFF') then
      begin
        WriteLn('Erreur: Pas un fichier RIFF');
        Exit;
      end;

      // V√©rifier WAVE
      if (Chr(Header[8]) + Chr(Header[9]) + Chr(Header[10]) + Chr(Header[11]) <> 'WAVE') then
      begin
        WriteLn('Erreur: Pas un fichier WAVE');
        Exit;
      end;

      // Extraire les informations du format
      Channels := PWord(@Header[22])^;
      SampleRate := PLongWord(@Header[24])^;
      BitsPerSample := PWord(@Header[34])^;
      AudioSize := PLongWord(@Header[40])^;

      // D√©terminer le format OpenAL
      if (Channels = 1) and (BitsPerSample = 8) then
        Format := AL_FORMAT_MONO8
      else if (Channels = 1) and (BitsPerSample = 16) then
        Format := AL_FORMAT_MONO16
      else if (Channels = 2) and (BitsPerSample = 8) then
        Format := AL_FORMAT_STEREO8
      else if (Channels = 2) and (BitsPerSample = 16) then
        Format := AL_FORMAT_STEREO16
      else
      begin
        WriteLn('Erreur: Format audio non support√© (', Channels, ' canaux, ', BitsPerSample, ' bits)');
        Exit;
      end;

      // Allouer et charger les donn√©es audio
      Size := AudioSize;
      Frequency := SampleRate;
      GetMem(Data, AudioSize);
      WaveFile.Read(Data^, AudioSize);

      Result := True;

    finally
      WaveFile.Free;
    end;
  except
    on E: Exception do
    begin
      WriteLn('Exception lors du chargement de ', Filename, ': ', E.Message);
      if Data <> nil then
        FreeMem(Data);
      Data := nil;
    end;
  end;
end;

{ TOpenALSound }

constructor TOpenALSound.Create(const Filename: string);
var
  Format: ALenum;
  Data: Pointer;
  Size: ALsizei;
  Frequency: ALsizei;
  Error: ALenum;
begin
  inherited Create;

  FFilename := Filename;
  FBuffer := 0;
  FSource := 0;
  FDuration := 0;

  // Charger le fichier WAV
  if not LoadWaveFile(Filename, Format, Data, Size, Frequency) then
    raise Exception.Create('Impossible de charger le fichier: ' + Filename);

  try
    // Cr√©er le buffer OpenAL
    alGenBuffers(1, @FBuffer);
    Error := alGetError;
    if Error <> AL_NO_ERROR then
      raise Exception.Create('Erreur alGenBuffers: ' + IntToStr(Error));

    // Charger les donn√©es dans le buffer
    alBufferData(FBuffer, Format, Data, Size, Frequency);
    Error := alGetError;
    if Error <> AL_NO_ERROR then
      raise Exception.Create('Erreur alBufferData: ' + IntToStr(Error));

    // Calculer la dur√©e
    case Format of
      AL_FORMAT_MONO8:    FDuration := Size / Frequency;
      AL_FORMAT_MONO16:   FDuration := Size / (2 * Frequency);
      AL_FORMAT_STEREO8:  FDuration := Size / (2 * Frequency);
      AL_FORMAT_STEREO16: FDuration := Size / (4 * Frequency);
    end;

  finally
    FreeMem(Data);
  end;

  // Cr√©er la source
  alGenSources(1, @FSource);
  Error := alGetError;
  if Error <> AL_NO_ERROR then
  begin
    alDeleteBuffers(1, @FBuffer);
    raise Exception.Create('Erreur alGenSources: ' + IntToStr(Error));
  end;

  // Attacher le buffer √† la source
  alSourcei(FSource, AL_BUFFER, FBuffer);

  // Valeurs par d√©faut
  SetVolume(1.0);
  SetPitch(1.0);
  SetLooping(False);
end;

destructor TOpenALSound.Destroy;
begin
  if FSource <> 0 then
  begin
    alSourceStop(FSource);
    alDeleteSources(1, @FSource);
  end;

  if FBuffer <> 0 then
    alDeleteBuffers(1, @FBuffer);

  inherited;
end;

procedure TOpenALSound.Play(Loop: Boolean = False);
begin
  SetLooping(Loop);
  alSourcePlay(FSource);
end;

procedure TOpenALSound.Stop;
begin
  alSourceStop(FSource);
end;

procedure TOpenALSound.Pause;
begin
  alSourcePause(FSource);
end;

procedure TOpenALSound.Resume;
begin
  alSourcePlay(FSource);
end;

procedure TOpenALSound.Rewind;
begin
  alSourceRewind(FSource);
end;

function TOpenALSound.IsPlaying: Boolean;
var
  State: ALint;
begin
  alGetSourcei(FSource, AL_SOURCE_STATE, @State);
  Result := (State = AL_PLAYING);
end;

function TOpenALSound.IsPaused: Boolean;
var
  State: ALint;
begin
  alGetSourcei(FSource, AL_SOURCE_STATE, @State);
  Result := (State = AL_PAUSED);
end;

function TOpenALSound.IsStopped: Boolean;
var
  State: ALint;
begin
  alGetSourcei(FSource, AL_SOURCE_STATE, @State);
  Result := (State = AL_STOPPED) or (State = AL_INITIAL);
end;

procedure TOpenALSound.SetVolume(Volume: Single);
begin
  if Volume < 0 then Volume := 0;
  if Volume > 1 then Volume := 1;
  alSourcef(FSource, AL_GAIN, Volume);
end;

procedure TOpenALSound.SetPitch(Pitch: Single);
begin
  if Pitch < 0.5 then Pitch := 0.5;
  if Pitch > 2.0 then Pitch := 2.0;
  alSourcef(FSource, AL_PITCH, Pitch);
end;

procedure TOpenALSound.SetLooping(Loop: Boolean);
begin
  alSourcei(FSource, AL_LOOPING, Ord(Loop));
end;

function TOpenALSound.GetVolume: Single;
begin
  alGetSourcef(FSource, AL_GAIN, @Result);
end;

function TOpenALSound.GetPitch: Single;
begin
  alGetSourcef(FSource, AL_PITCH, @Result);
end;

function TOpenALSound.GetLooping: Boolean;
var
  Value: ALint;
begin
  alGetSourcei(FSource, AL_LOOPING, @Value);
  Result := Value <> 0;
end;

procedure TOpenALSound.SetPosition(X, Y, Z: Single);
begin
  alSource3f(FSource, AL_POSITION, X, Y, Z);
end;

procedure TOpenALSound.SetVelocity(VX, VY, VZ: Single);
begin
  alSource3f(FSource, AL_VELOCITY, VX, VY, VZ);
end;

procedure TOpenALSound.SetDirection(DX, DY, DZ: Single);
begin
  alSource3f(FSource, AL_DIRECTION, DX, DY, DZ);
end;

procedure TOpenALSound.GetPosition(out X, Y, Z: Single);
begin
  alGetSource3f(FSource, AL_POSITION, @X, @Y, @Z);
end;

procedure TOpenALSound.GetVelocity(out VX, VY, VZ: Single);
begin
  alGetSource3f(FSource, AL_VELOCITY, @VX, @VY, @VZ);
end;

procedure TOpenALSound.SetReferenceDistance(Distance: Single);
begin
  alSourcef(FSource, AL_REFERENCE_DISTANCE, Distance);
end;

procedure TOpenALSound.SetMaxDistance(Distance: Single);
begin
  alSourcef(FSource, AL_MAX_DISTANCE, Distance);
end;

procedure TOpenALSound.SetRolloffFactor(Factor: Single);
begin
  alSourcef(FSource, AL_ROLLOFF_FACTOR, Factor);
end;

procedure TOpenALSound.SetRelativeToListener(Relative: Boolean);
begin
  alSourcei(FSource, AL_SOURCE_RELATIVE, Ord(Relative));
end;

function TOpenALSound.GetPlaybackPosition: Single;
begin
  alGetSourcef(FSource, AL_SEC_OFFSET, @Result);
end;

procedure TOpenALSound.SetPlaybackPosition(Seconds: Single);
begin
  alSourcef(FSource, AL_SEC_OFFSET, Seconds);
end;

{ TOpenALSystem }

constructor TOpenALSystem.Create;
var
  DeviceName: PChar;
begin
  inherited Create;

  FSounds := TList.Create;
  FInitialized := False;

  // Ouvrir le p√©riph√©rique audio par d√©faut
  DeviceName := nil; // nil = p√©riph√©rique par d√©faut
  FDevice := alcOpenDevice(DeviceName);

  if FDevice = nil then
    raise Exception.Create('Impossible d''ouvrir le p√©riph√©rique audio OpenAL');

  // Cr√©er le contexte
  FContext := alcCreateContext(FDevice, nil);
  if FContext = nil then
  begin
    alcCloseDevice(FDevice);
    raise Exception.Create('Impossible de cr√©er le contexte OpenAL');
  end;

  // Activer le contexte
  if not alcMakeContextCurrent(FContext) then
  begin
    alcDestroyContext(FContext);
    alcCloseDevice(FDevice);
    raise Exception.Create('Impossible d''activer le contexte OpenAL');
  end;

  FInitialized := True;

  WriteLn('OpenAL initialis√©:');
  WriteLn('  Vendor: ', GetVendor);
  WriteLn('  Renderer: ', GetRenderer);
  WriteLn('  Version: ', GetVersion);
end;

destructor TOpenALSystem.Destroy;
begin
  UnloadAll;
  FSounds.Free;

  if FInitialized then
  begin
    alcMakeContextCurrent(nil);
    if FContext <> nil then
      alcDestroyContext(FContext);
    if FDevice <> nil then
      alcCloseDevice(FDevice);
  end;

  inherited;
end;

function TOpenALSystem.LoadSound(const Filename: string): TOpenALSound;
begin
  Result := TOpenALSound.Create(Filename);
  FSounds.Add(Result);
end;

procedure TOpenALSystem.UnloadSound(Sound: TOpenALSound);
begin
  if Assigned(Sound) then
  begin
    FSounds.Remove(Sound);
    Sound.Free;
  end;
end;

procedure TOpenALSystem.UnloadAll;
var
  i: Integer;
begin
  for i := FSounds.Count - 1 downto 0 do
    TOpenALSound(FSounds[i]).Free;
  FSounds.Clear;
end;

procedure TOpenALSystem.SetListenerPosition(X, Y, Z: Single);
begin
  alListener3f(AL_POSITION, X, Y, Z);
end;

procedure TOpenALSystem.SetListenerVelocity(VX, VY, VZ: Single);
begin
  alListener3f(AL_VELOCITY, VX, VY, VZ);
end;

procedure TOpenALSystem.SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ: Single);
var
  Orientation: array[0..5] of ALfloat;
begin
  Orientation[0] := ForwardX;  // Direction "devant"
  Orientation[1] := ForwardY;
  Orientation[2] := ForwardZ;
  Orientation[3] := UpX;       // Direction "haut"
  Orientation[4] := UpY;
  Orientation[5] := UpZ;

  alListenerfv(AL_ORIENTATION, @Orientation[0]);
end;

procedure TOpenALSystem.SetListenerGain(Gain: Single);
begin
  alListenerf(AL_GAIN, Gain);
end;

procedure TOpenALSystem.GetListenerPosition(out X, Y, Z: Single);
begin
  alGetListener3f(AL_POSITION, @X, @Y, @Z);
end;

procedure TOpenALSystem.GetListenerVelocity(out VX, VY, VZ: Single);
begin
  alGetListener3f(AL_VELOCITY, @VX, @VY, @VZ);
end;

procedure TOpenALSystem.SetSpeedOfSound(Speed: Single);
begin
  alSpeedOfSound(Speed);
end;

procedure TOpenALSystem.SetDopplerFactor(Factor: Single);
begin
  alDopplerFactor(Factor);
end;

procedure TOpenALSystem.SetDistanceModel(Model: ALenum);
begin
  alDistanceModel(Model);
end;

procedure TOpenALSystem.StopAllSounds;
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    TOpenALSound(FSounds[i]).Stop;
end;

procedure TOpenALSystem.PauseAllSounds;
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    if TOpenALSound(FSounds[i]).IsPlaying then
      TOpenALSound(FSounds[i]).Pause;
end;

procedure TOpenALSystem.ResumeAllSounds;
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    if TOpenALSound(FSounds[i]).IsPaused then
      TOpenALSound(FSounds[i]).Resume;
end;

function TOpenALSystem.GetVersion: string;
begin
  Result := string(alGetString(AL_VERSION));
end;

function TOpenALSystem.GetVendor: string;
begin
  Result := string(alGetString(AL_VENDOR));
end;

function TOpenALSystem.GetRenderer: string;
begin
  Result := string(alGetString(AL_RENDERER));
end;

function TOpenALSystem.GetExtensions: string;
begin
  Result := string(alGetString(AL_EXTENSIONS));
end;

function TOpenALSystem.IsExtensionSupported(const Extension: string): Boolean;
begin
  Result := alIsExtensionPresent(PChar(Extension));
end;

end.
```

## Utilisation basique

```pascal
program OpenALBasicDemo;

{$mode objfpc}{$H+}

uses
  OpenALWrapper, SysUtils;

var
  Audio: TOpenALSystem;
  Music: TOpenALSound;
  JumpSound: TOpenALSound;
  ExplosionSound: TOpenALSound;

begin
  WriteLn('=== D√©mo OpenAL Basique ===');
  WriteLn;

  // Initialiser OpenAL
  Audio := TOpenALSystem.Create;

  try
    // Charger les sons
    WriteLn('Chargement des sons...');
    Music := Audio.LoadSound('music.wav');
    JumpSound := Audio.LoadSound('jump.wav');
    ExplosionSound := Audio.LoadSound('explosion.wav');

    WriteLn('Sons charg√©s avec succ√®s !');
    WriteLn;

    // Jouer la musique en boucle
    WriteLn('Lecture de la musique...');
    Music.SetVolume(0.5); // 50% du volume
    Music.Play(True); // True = en boucle

    Sleep(2000);

    // Jouer un effet sonore
    WriteLn('Jump!');
    JumpSound.Play;

    Sleep(1000);

    // Jouer une explosion
    WriteLn('Boom!');
    ExplosionSound.Play;

    Sleep(2000);

    // Arr√™ter la musique
    WriteLn('Arr√™t de la musique');
    Music.Stop;

    WriteLn;
    WriteLn('Termin√© !');

  finally
    Audio.Free;
  end;
end.
```

## Audio 3D - Exemple complet

```pascal
program OpenAL3DDemo;

{$mode objfpc}{$H+}

uses
  OpenALWrapper, SysUtils, Math;

var
  Audio: TOpenALSystem;
  Helicopter: TOpenALSound;
  Angle: Single;
  X, Z: Single;
  i: Integer;

begin
  WriteLn('=== D√©mo Audio 3D ===');
  WriteLn('Un h√©licopt√®re tourne autour de vous');
  WriteLn;

  Audio := TOpenALSystem.Create;

  try
    // Charger le son
    Helicopter := Audio.LoadSound('helicopter.wav');

    // Configurer le listener (vous √™tes au centre)
    Audio.SetListenerPosition(0, 0, 0);
    Audio.SetListenerOrientation(0, 0, -1, 0, 1, 0); // Regarde vers -Z, haut = +Y

    // Configurer la source
    Helicopter.SetReferenceDistance(1.0);   // Distance de r√©f√©rence
    Helicopter.SetMaxDistance(50.0);        // Distance maximale
    Helicopter.SetRolloffFactor(1.0);       // Att√©nuation normale

    // Jouer en boucle
    Helicopter.Play(True);

    // Faire tourner l'h√©licopt√®re autour du listener
    WriteLn('Rotation pendant 10 secondes...');
    for i := 0 to 360 do
    begin
      Angle := i * Pi / 180.0;

      // Position circulaire
      X := Cos(Angle) * 5.0; // Rayon de 5 m√®tres
      Z := Sin(Angle) * 5.0;

      Helicopter.SetPosition(X, 1.5, Z); // √Ä 1.5m de hauteur

      // Calculer la v√©locit√© pour l'effet Doppler
      Helicopter.SetVelocity(-Sin(Angle) * 2, 0, Cos(Angle) * 2);

      Sleep(50); // ~20 FPS
    end;

    WriteLn('Termin√© !');

  finally
    Audio.Free;
  end;
end.
```

---

## Streaming audio

Pour les fichiers volumineux comme la musique de fond, le streaming √©vite de charger tout le fichier en m√©moire.

### Classe de streaming

```pascal
unit OpenALStreaming;

{$mode objfpc}{$H+}

interface

uses
  OpenAL, Classes, SysUtils;

const
  STREAM_BUFFER_COUNT = 3;     // Triple buffering
  STREAM_BUFFER_SIZE = 65536;  // 64 KB par buffer

type
  TStreamingSound = class
  private
    FSource: ALuint;
    FBuffers: array[0..STREAM_BUFFER_COUNT-1] of ALuint;
    FFile: TFileStream;
    FFormat: ALenum;
    FFrequency: ALsizei;
    FDataOffset: Int64;
    FFileSize: Int64;
    FLooping: Boolean;
    FPlaying: Boolean;
    FFinished: Boolean;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure Update; // √Ä appeler r√©guli√®rement (chaque frame)

    function IsPlaying: Boolean;
    function IsFinished: Boolean;

    procedure SetVolume(Volume: Single);
    procedure SetPitch(Pitch: Single);

  private
    function FillBuffer(Buffer: ALuint): Boolean;
    procedure QueueBuffers;
  end;

implementation

constructor TStreamingSound.Create(const Filename: string);
var
  Header: array[0..43] of Byte;
  Channels: Word;
  SampleRate: Cardinal;
  BitsPerSample: Word;
  i: Integer;
begin
  inherited Create;

  FPlaying := False;
  FFinished := False;
  FLooping := False;

  // Ouvrir le fichier WAV
  FFile := TFileStream.Create(Filename, fmOpenRead or fmShareDenyWrite);

  // Lire l'en-t√™te
  FFile.Read(Header, 44);
  FDataOffset := 44;

  // Extraire les informations
  Channels := PWord(@Header[22])^;
  SampleRate := PLongWord(@Header[24])^;
  BitsPerSample := PWord(@Header[34])^;
  FFileSize := FFile.Size - 44;

  // D√©terminer le format
  if (Channels = 1) and (BitsPerSample = 8) then
    FFormat := AL_FORMAT_MONO8
  else if (Channels = 1) and (BitsPerSample = 16) then
    FFormat := AL_FORMAT_MONO16
  else if (Channels = 2) and (BitsPerSample = 8) then
    FFormat := AL_FORMAT_STEREO8
  else if (Channels = 2) and (BitsPerSample = 16) then
    FFormat := AL_FORMAT_STEREO16
  else
    raise Exception.Create('Format non support√© pour le streaming');

  FFrequency := SampleRate;

  // Cr√©er les buffers
  alGenBuffers(STREAM_BUFFER_COUNT, @FBuffers[0]);

  // Cr√©er la source
  alGenSources(1, @FSource);

  // V√©rifier les erreurs
  if alGetError <> AL_NO_ERROR then
    raise Exception.Create('Erreur lors de l''initialisation du streaming');
end;

destructor TStreamingSound.Destroy;
begin
  Stop;

  if FSource <> 0 then
    alDeleteSources(1, @FSource);

  alDeleteBuffers(STREAM_BUFFER_COUNT, @FBuffers[0]);

  FFile.Free;

  inherited;
end;

function TStreamingSound.FillBuffer(Buffer: ALuint): Boolean;
var
  Data: array[0..STREAM_BUFFER_SIZE-1] of Byte;
  BytesRead: Integer;
begin
  Result := False;

  // Lire les donn√©es du fichier
  BytesRead := FFile.Read(Data, STREAM_BUFFER_SIZE);

  if BytesRead > 0 then
  begin
    // Charger dans le buffer OpenAL
    alBufferData(Buffer, FFormat, @Data[0], BytesRead, FFrequency);
    Result := True;
  end
  else if FLooping then
  begin
    // Revenir au d√©but du fichier
    FFile.Position := FDataOffset;
    BytesRead := FFile.Read(Data, STREAM_BUFFER_SIZE);

    if BytesRead > 0 then
    begin
      alBufferData(Buffer, FFormat, @Data[0], BytesRead, FFrequency);
      Result := True;
    end;
  end;
end;

procedure TStreamingSound.QueueBuffers;
var
  i: Integer;
begin
  // Remplir et enqueue tous les buffers initialement
  for i := 0 to STREAM_BUFFER_COUNT - 1 do
  begin
    if FillBuffer(FBuffers[i]) then
      alSourceQueueBuffers(FSource, 1, @FBuffers[i]);
  end;
end;

procedure TStreamingSound.Play(Loop: Boolean);
begin
  if FPlaying then Exit;

  FLooping := Loop;
  FFinished := False;

  // Rembobiner le fichier
  FFile.Position := FDataOffset;

  // Remplir les buffers
  QueueBuffers;

  // D√©marrer la lecture
  alSourcePlay(FSource);
  FPlaying := True;
end;

procedure TStreamingSound.Stop;
var
  Queued: ALint;
  Buffer: ALuint;
begin
  if not FPlaying then Exit;

  alSourceStop(FSource);
  FPlaying := False;

  // Vider la file de buffers
  alGetSourcei(FSource, AL_BUFFERS_QUEUED, @Queued);
  while Queued > 0 do
  begin
    alSourceUnqueueBuffers(FSource, 1, @Buffer);
    Dec(Queued);
  end;
end;

procedure TStreamingSound.Update;
var
  Processed: ALint;
  Buffer: ALuint;
  State: ALint;
begin
  if not FPlaying then Exit;

  // V√©rifier combien de buffers ont √©t√© trait√©s
  alGetSourcei(FSource, AL_BUFFERS_PROCESSED, @Processed);

  // Recharger les buffers trait√©s
  while Processed > 0 do
  begin
    // R√©cup√©rer un buffer trait√©
    alSourceUnqueueBuffers(FSource, 1, @Buffer);

    // Le remplir avec de nouvelles donn√©es
    if FillBuffer(Buffer) then
    begin
      // Le remettre dans la file
      alSourceQueueBuffers(FSource, 1, @Buffer);
    end
    else
    begin
      // Plus de donn√©es et pas de boucle
      FFinished := True;
    end;

    Dec(Processed);
  end;

  // V√©rifier si la source s'est arr√™t√©e
  alGetSourcei(FSource, AL_SOURCE_STATE, @State);
  if State <> AL_PLAYING then
  begin
    // Si on a encore des buffers en attente, red√©marrer
    alGetSourcei(FSource, AL_BUFFERS_QUEUED, @Processed);
    if (Processed > 0) and not FFinished then
      alSourcePlay(FSource)
    else
      FPlaying := False;
  end;
end;

function TStreamingSound.IsPlaying: Boolean;
begin
  Result := FPlaying;
end;

function TStreamingSound.IsFinished: Boolean;
begin
  Result := FFinished;
end;

procedure TStreamingSound.SetVolume(Volume: Single);
begin
  alSourcef(FSource, AL_GAIN, Volume);
end;

procedure TStreamingSound.SetPitch(Pitch: Single);
begin
  alSourcef(FSource, AL_PITCH, Pitch);
end;

end.
```

### Utilisation du streaming

```pascal
program StreamingDemo;

uses
  OpenALWrapper, OpenALStreaming, SysUtils;

var
  Audio: TOpenALSystem;
  BackgroundMusic: TStreamingSound;

begin
  WriteLn('=== D√©mo Streaming Audio ===');

  Audio := TOpenALSystem.Create;

  try
    // Cr√©er un son en streaming
    BackgroundMusic := TStreamingSound.Create('long_music.wav');

    try
      BackgroundMusic.SetVolume(0.7);
      BackgroundMusic.Play(True); // En boucle

      WriteLn('Musique en streaming...');
      WriteLn('Appuyez sur Entr√©e pour arr√™ter');

      // Boucle principale - IMPORTANT : appeler Update() r√©guli√®rement !
      while BackgroundMusic.IsPlaying do
      begin
        BackgroundMusic.Update; // Mettre √† jour le streaming
        Sleep(16); // ~60 FPS

        if KeyPressed then
          Break;
      end;

      BackgroundMusic.Stop;

    finally
      BackgroundMusic.Free;
    end;

  finally
    Audio.Free;
  end;
end.
```

## Effets audio avec EFX (Extension)

OpenAL EFX (Effects Extension) permet d'ajouter des effets comme la r√©verb√©ration.

### V√©rifier le support EFX

```pascal
function SupportsEFX(Audio: TOpenALSystem): Boolean;
begin
  Result := Audio.IsExtensionSupported('ALC_EXT_EFX');
end;
```

### Bindings pour EFX (simplifi√©)

```pascal
unit OpenALEFX;

interface

uses
  OpenAL;

const
  // Types d'effets
  AL_EFFECT_NULL = $0000;
  AL_EFFECT_REVERB = $0001;
  AL_EFFECT_CHORUS = $0002;
  AL_EFFECT_DISTORTION = $0003;
  AL_EFFECT_ECHO = $0004;
  AL_EFFECT_FLANGER = $0005;

  // Propri√©t√©s de reverb
  AL_REVERB_DENSITY = $0001;
  AL_REVERB_DIFFUSION = $0002;
  AL_REVERB_GAIN = $0003;
  AL_REVERB_GAINHF = $0004;
  AL_REVERB_DECAY_TIME = $0005;
  AL_REVERB_DECAY_HFRATIO = $0006;

type
  // Fonctions EFX (charg√©es dynamiquement)
  TALPROCGENEFFECTS = procedure(n: ALsizei; effects: PALuint); cdecl;
  TALPROCDELETEEFFECTS = procedure(n: ALsizei; effects: PALuint); cdecl;
  TALPROCEFFECTI = procedure(effect: ALuint; param: ALenum; value: ALint); cdecl;
  TALPROCEFFECTF = procedure(effect: ALuint; param: ALenum; value: ALfloat); cdecl;

  TALPROCGENAUXILIARYEFFECTSLOTS = procedure(n: ALsizei; slots: PALuint); cdecl;
  TALPROCDELETEAUXILIARYEFFECTSLOTS = procedure(n: ALsizei; slots: PALuint); cdecl;
  TALPROCSOURCE3I = procedure(source: ALuint; param: ALenum; v1, v2, v3: ALint); cdecl;

var
  alGenEffects: TALPROCGENEFFECTS;
  alDeleteEffects: TALPROCDELETEEFFECTS;
  alEffecti: TALPROCEFFECTI;
  alEffectf: TALPROCEFFECTF;
  alGenAuxiliaryEffectSlots: TALPROCGENAUXILIARYEFFECTSLOTS;
  alDeleteAuxiliaryEffectSlots: TALPROCDELETEAUXILIARYEFFECTSLOTS;
  alSource3i: TALPROCSOURCE3I;

function InitEFX: Boolean;

implementation

function InitEFX: Boolean;
begin
  Result := False;

  // Charger les fonctions EFX
  @alGenEffects := alGetProcAddress('alGenEffects');
  @alDeleteEffects := alGetProcAddress('alDeleteEffects');
  @alEffecti := alGetProcAddress('alEffecti');
  @alEffectf := alGetProcAddress('alEffectf');
  @alGenAuxiliaryEffectSlots := alGetProcAddress('alGenAuxiliaryEffectSlots');
  @alDeleteAuxiliaryEffectSlots := alGetProcAddress('alDeleteAuxiliaryEffectSlots');
  @alSource3i := alGetProcAddress('alSource3i');

  Result := Assigned(alGenEffects) and Assigned(alDeleteEffects);
end;

end.
```

### Appliquer un effet de r√©verb√©ration

```pascal
type
  TReverbEffect = class
  private
    FEffect: ALuint;
    FSlot: ALuint;
  public
    constructor Create;
    destructor Destroy; override;

    procedure SetPreset(Preset: string);
    procedure ApplyToSource(Source: ALuint);
    procedure RemoveFromSource(Source: ALuint);
  end;

constructor TReverbEffect.Create;
begin
  inherited Create;

  if not InitEFX then
    raise Exception.Create('EFX non support√©');

  // Cr√©er l'effet
  alGenEffects(1, @FEffect);
  alEffecti(FEffect, AL_EFFECT_TYPE, AL_EFFECT_REVERB);

  // Cr√©er le slot
  alGenAuxiliaryEffectSlots(1, @FSlot);
end;

destructor TReverbEffect.Destroy;
begin
  if FSlot <> 0 then
    alDeleteAuxiliaryEffectSlots(1, @FSlot);
  if FEffect <> 0 then
    alDeleteEffects(1, @FEffect);
  inherited;
end;

procedure TReverbEffect.SetPreset(Preset: string);
begin
  if Preset = 'cave' then
  begin
    alEffectf(FEffect, AL_REVERB_DENSITY, 1.0);
    alEffectf(FEffect, AL_REVERB_DIFFUSION, 1.0);
    alEffectf(FEffect, AL_REVERB_GAIN, 0.32);
    alEffectf(FEffect, AL_REVERB_DECAY_TIME, 2.91);
  end
  else if Preset = 'bathroom' then
  begin
    alEffectf(FEffect, AL_REVERB_DENSITY, 1.0);
    alEffectf(FEffect, AL_REVERB_DIFFUSION, 1.0);
    alEffectf(FEffect, AL_REVERB_GAIN, 0.17);
    alEffectf(FEffect, AL_REVERB_DECAY_TIME, 1.4);
  end;
  // ... autres presets
end;

procedure TReverbEffect.ApplyToSource(Source: ALuint);
begin
  // Attacher l'effet au slot
  alAuxiliaryEffectSloti(FSlot, AL_EFFECTSLOT_EFFECT, FEffect);

  // Connecter la source au slot
  alSource3i(Source, AL_AUXILIARY_SEND_FILTER, FSlot, 0, AL_FILTER_NULL);
end;
```

## Gestionnaire audio complet pour jeux

```pascal
unit GameAudioManager;

{$mode objfpc}{$H+}

interface

uses
  OpenALWrapper, OpenALStreaming, Classes, SysUtils;

type
  TAudioCategory = (acMusic, acSFX, acVoice, acAmbient);

  TManagedSound = record
    Sound: TOpenALSound;
    Category: TAudioCategory;
    Priority: Integer;
    Tag: string;
  end;

  TManagedStreamingSound = record
    Sound: TStreamingSound;
    Category: TAudioCategory;
  end;

  TGameAudioManager = class
  private
    FAudioSystem: TOpenALSystem;
    FSounds: array of TManagedSound;
    FStreamingSounds: array of TManagedStreamingSound;
    FCategoryVolumes: array[TAudioCategory] of Single;
    FMasterVolume: Single;
    FMuted: Boolean;
    FMaxSounds: Integer;
  public
    constructor Create(MaxSimultaneousSounds: Integer = 32);
    destructor Destroy; override;

    // Chargement
    function LoadSound(const Filename: string; Category: TAudioCategory;
      Priority: Integer = 50; const Tag: string = ''): Integer;
    function LoadStreamingSound(const Filename: string;
      Category: TAudioCategory): Integer;
    procedure UnloadSound(Index: Integer);
    procedure UnloadAllSounds;

    // Lecture
    procedure PlaySound(Index: Integer; Loop: Boolean = False);
    procedure PlaySoundByTag(const Tag: string; Loop: Boolean = False);
    procedure StopSound(Index: Integer);
    procedure StopAllSounds;
    procedure StopCategory(Category: TAudioCategory);

    // Volume
    procedure SetMasterVolume(Volume: Single);
    procedure SetCategoryVolume(Category: TAudioCategory; Volume: Single);
    function GetMasterVolume: Single;
    function GetCategoryVolume(Category: TAudioCategory): Single;
    procedure Mute(Muted: Boolean);
    function IsMuted: Boolean;

    // Audio 3D
    procedure SetListenerPosition(X, Y, Z: Single);
    procedure SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ: Single);
    procedure SetSoundPosition(Index: Integer; X, Y, Z: Single);

    // Mise √† jour
    procedure Update; // √Ä appeler chaque frame

    // Recherche
    function FindSoundByTag(const Tag: string): Integer;
    function IsPlaying(Index: Integer): Boolean;

    // Sauvegarde/chargement des param√®tres
    procedure SaveSettings(const Filename: string);
    procedure LoadSettings(const Filename: string);

    property MasterVolume: Single read FMasterVolume write SetMasterVolume;
    property Muted: Boolean read FMuted write Mute;
  end;

implementation

uses
  IniFiles;

constructor TGameAudioManager.Create(MaxSimultaneousSounds: Integer);
var
  Cat: TAudioCategory;
begin
  inherited Create;

  FMaxSounds := MaxSimultaneousSounds;
  FAudioSystem := TOpenALSystem.Create;

  // Initialiser les volumes
  FMasterVolume := 1.0;
  for Cat := Low(TAudioCategory) to High(TAudioCategory) do
    FCategoryVolumes[Cat] := 1.0;

  FMuted := False;

  SetLength(FSounds, 0);
  SetLength(FStreamingSounds, 0);
end;

destructor TGameAudioManager.Destroy;
begin
  UnloadAllSounds;
  FAudioSystem.Free;
  inherited;
end;

function TGameAudioManager.LoadSound(const Filename: string;
  Category: TAudioCategory; Priority: Integer; const Tag: string): Integer;
var
  MSound: TManagedSound;
begin
  MSound.Sound := FAudioSystem.LoadSound(Filename);
  MSound.Category := Category;
  MSound.Priority := Priority;
  MSound.Tag := Tag;

  SetLength(FSounds, Length(FSounds) + 1);
  FSounds[High(FSounds)] := MSound;

  Result := High(FSounds);
end;

function TGameAudioManager.LoadStreamingSound(const Filename: string;
  Category: TAudioCategory): Integer;
var
  MSound: TManagedStreamingSound;
begin
  MSound.Sound := TStreamingSound.Create(Filename);
  MSound.Category := Category;

  SetLength(FStreamingSounds, Length(FStreamingSounds) + 1);
  FStreamingSounds[High(FStreamingSounds)] := MSound;

  Result := High(FStreamingSounds);
end;

procedure TGameAudioManager.UnloadSound(Index: Integer);
begin
  if (Index >= 0) and (Index < Length(FSounds)) then
  begin
    FSounds[Index].Sound.Free;
    // D√©caler les √©l√©ments suivants
    if Index < High(FSounds) then
      Move(FSounds[Index + 1], FSounds[Index], (High(FSounds) - Index) * SizeOf(TManagedSound));
    SetLength(FSounds, Length(FSounds) - 1);
  end;
end;

procedure TGameAudioManager.UnloadAllSounds;
var
  i: Integer;
begin
  for i := High(FSounds) downto 0 do
    FSounds[i].Sound.Free;
  SetLength(FSounds, 0);

  for i := High(FStreamingSounds) downto 0 do
    FStreamingSounds[i].Sound.Free;
  SetLength(FStreamingSounds, 0);
end;

procedure TGameAudioManager.PlaySound(Index: Integer; Loop: Boolean);
var
  Volume: Single;
begin
  if (Index < 0) or (Index >= Length(FSounds)) then Exit;

  // Calculer le volume final
  Volume := FMasterVolume * FCategoryVolumes[FSounds[Index].Category];
  if FMuted then Volume := 0;

  FSounds[Index].Sound.SetVolume(Volume);
  FSounds[Index].Sound.Play(Loop);
end;

procedure TGameAudioManager.PlaySoundByTag(const Tag: string; Loop: Boolean);
var
  Index: Integer;
begin
  Index := FindSoundByTag(Tag);
  if Index >= 0 then
    PlaySound(Index, Loop);
end;

procedure TGameAudioManager.StopSound(Index: Integer);
begin
  if (Index >= 0) and (Index < Length(FSounds)) then
    FSounds[Index].Sound.Stop;
end;

procedure TGameAudioManager.StopAllSounds;
var
  i: Integer;
begin
  for i := 0 to High(FSounds) do
    FSounds[i].Sound.Stop;

  for i := 0 to High(FStreamingSounds) do
    FStreamingSounds[i].Sound.Stop;
end;

procedure TGameAudioManager.StopCategory(Category: TAudioCategory);
var
  i: Integer;
begin
  for i := 0 to High(FSounds) do
    if FSounds[i].Category = Category then
      FSounds[i].Sound.Stop;

  for i := 0 to High(FStreamingSounds) do
    if FStreamingSounds[i].Category = Category then
      FStreamingSounds[i].Sound.Stop;
end;

procedure TGameAudioManager.SetMasterVolume(Volume: Single);
var
  i: Integer;
  FinalVol: Single;
begin
  FMasterVolume := Volume;
  if FMasterVolume < 0 then FMasterVolume := 0;
  if FMasterVolume > 1 then FMasterVolume := 1;

  // Mettre √† jour tous les sons actifs
  for i := 0 to High(FSounds) do
  begin
    if FSounds[i].Sound.IsPlaying then
    begin
      FinalVol := FMasterVolume * FCategoryVolumes[FSounds[i].Category];
      if FMuted then FinalVol := 0;
      FSounds[i].Sound.SetVolume(FinalVol);
    end;
  end;
end;

procedure TGameAudioManager.SetCategoryVolume(Category: TAudioCategory; Volume: Single);
var
  i: Integer;
  FinalVol: Single;
begin
  FCategoryVolumes[Category] := Volume;
  if FCategoryVolumes[Category] < 0 then FCategoryVolumes[Category] := 0;
  if FCategoryVolumes[Category] > 1 then FCategoryVolumes[Category] := 1;

  // Mettre √† jour les sons de cette cat√©gorie
  for i := 0 to High(FSounds) do
  begin
    if (FSounds[i].Category = Category) and FSounds[i].Sound.IsPlaying then
    begin
      FinalVol := FMasterVolume * FCategoryVolumes[Category];
      if FMuted then FinalVol := 0;
      FSounds[i].Sound.SetVolume(FinalVol);
    end;
  end;
end;

function TGameAudioManager.GetMasterVolume: Single;
begin
  Result := FMasterVolume;
end;

function TGameAudioManager.GetCategoryVolume(Category: TAudioCategory): Single;
begin
  Result := FCategoryVolumes[Category];
end;

procedure TGameAudioManager.Mute(Muted: Boolean);
begin
  FMuted := Muted;
  SetMasterVolume(FMasterVolume); // Forcer la mise √† jour
end;

function TGameAudioManager.IsMuted: Boolean;
begin
  Result := FMuted;
end;

procedure TGameAudioManager.SetListenerPosition(X, Y, Z: Single);
begin
  FAudioSystem.SetListenerPosition(X, Y, Z);
end;

procedure TGameAudioManager.SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ: Single);
begin
  FAudioSystem.SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ);
end;

procedure TGameAudioManager.SetSoundPosition(Index: Integer; X, Y, Z: Single);
begin
  if (Index >= 0) and (Index < Length(FSounds)) then
    FSounds[Index].Sound.SetPosition(X, Y, Z);
end;

procedure TGameAudioManager.Update;
var
  i: Integer;
begin
  // Mettre √† jour les sons en streaming
  for i := 0 to High(FStreamingSounds) do
    FStreamingSounds[i].Sound.Update;
end;

function TGameAudioManager.FindSoundByTag(const Tag: string): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := 0 to High(FSounds) do
  begin
    if FSounds[i].Tag = Tag then
    begin
      Result := i;
      Exit;
    end;
  end;
end;

function TGameAudioManager.IsPlaying(Index: Integer): Boolean;
begin
  Result := False;
  if (Index >= 0) and (Index < Length(FSounds)) then
    Result := FSounds[Index].Sound.IsPlaying;
end;

procedure TGameAudioManager.SaveSettings(const Filename: string);
var
  Ini: TIniFile;
  Cat: TAudioCategory;
begin
  Ini := TIniFile.Create(Filename);
  try
    Ini.WriteFloat('Audio', 'MasterVolume', FMasterVolume);
    Ini.WriteBool('Audio', 'Muted', FMuted);

    for Cat := Low(TAudioCategory) to High(TAudioCategory) do
      Ini.WriteFloat('Volumes', GetEnumName(TypeInfo(TAudioCategory), Ord(Cat)),
                    FCategoryVolumes[Cat]);
  finally
    Ini.Free;
  end;
end;

procedure TGameAudioManager.LoadSettings(const Filename: string);
var
  Ini: TIniFile;
  Cat: TAudioCategory;
begin
  if not FileExists(Filename) then Exit;

  Ini := TIniFile.Create(Filename);
  try
    FMasterVolume := Ini.ReadFloat('Audio', 'MasterVolume', 1.0);
    FMuted := Ini.ReadBool('Audio', 'Muted', False);

    for Cat := Low(TAudioCategory) to High(TAudioCategory) do
      FCategoryVolumes[Cat] := Ini.ReadFloat('Volumes',
        GetEnumName(TypeInfo(TAudioCategory), Ord(Cat)), 1.0);
  finally
    Ini.Free;
  end;
end;

end.
```

## Utilisation du gestionnaire complet

```pascal
program CompleteAudioDemo;

{$mode objfpc}{$H+}

uses
  GameAudioManager, SysUtils;

var
  AudioMgr: TGameAudioManager;
  MusicIndex, JumpIndex, ExplosionIndex: Integer;

begin
  WriteLn('=== D√©mo Gestionnaire Audio Complet ===');

  AudioMgr := TGameAudioManager.Create;

  try
    // Charger les param√®tres sauvegard√©s
    AudioMgr.LoadSettings('audio_config.ini');

    // Charger les sons
    MusicIndex := AudioMgr.LoadStreamingSound('music.wav', acMusic);
    JumpIndex := AudioMgr.LoadSound('jump.wav', acSFX, 50, 'jump_sound');
    ExplosionIndex := AudioMgr.LoadSound('explosion.wav', acSFX, 80, 'explosion');

    // Configurer les volumes par cat√©gorie
    AudioMgr.SetCategoryVolume(acMusic, 0.7);
    AudioMgr.SetCategoryVolume(acSFX, 1.0);

    // Jouer la musique
    AudioMgr.PlaySound(MusicIndex, True);

    // Simulation de jeu
    WriteLn('Simulation de gameplay...');
    for i := 1 to 100 do
    begin
      // Mettre √† jour (important pour le streaming)
      AudioMgr.Update;

      // Simuler des √©v√©nements
      if (i mod 20) = 0 then
        AudioMgr.PlaySoundByTag('jump_sound');

      if (i mod 50) = 0 then
        AudioMgr.PlaySoundByTag('explosion');

      Sleep(50);
    end;

    // Sauvegarder les param√®tres
    AudioMgr.SaveSettings('audio_config.ini');

    WriteLn('Termin√© !');

  finally
    AudioMgr.Free;
  end;
end.
```

---

## Optimisations

### 1. Pool de sources

Limiter et r√©utiliser les sources OpenAL pour de meilleures performances.

```pascal
type
  TSourcePool = class
  private
    FSources: array of ALuint;
    FAvailable: array of Boolean;
    FMaxSources: Integer;
  public
    constructor Create(MaxSources: Integer);
    destructor Destroy; override;

    function AcquireSource: ALuint;
    procedure ReleaseSource(Source: ALuint);
    function GetActiveCount: Integer;
  end;

constructor TSourcePool.Create(MaxSources: Integer);
var
  i: Integer;
begin
  inherited Create;

  FMaxSources := MaxSources;
  SetLength(FSources, MaxSources);
  SetLength(FAvailable, MaxSources);

  // Cr√©er toutes les sources
  alGenSources(MaxSources, @FSources[0]);

  // Marquer toutes comme disponibles
  for i := 0 to MaxSources - 1 do
    FAvailable[i] := True;
end;

destructor TSourcePool.Destroy;
begin
  alDeleteSources(FMaxSources, @FSources[0]);
  inherited;
end;

function TSourcePool.AcquireSource: ALuint;
var
  i: Integer;
begin
  Result := 0;

  for i := 0 to FMaxSources - 1 do
  begin
    if FAvailable[i] then
    begin
      FAvailable[i] := False;
      Result := FSources[i];
      Exit;
    end;
  end;

  // Aucune source disponible
  WriteLn('ATTENTION: Pool de sources √©puis√©');
end;

procedure TSourcePool.ReleaseSource(Source: ALuint);
var
  i: Integer;
begin
  for i := 0 to FMaxSources - 1 do
  begin
    if FSources[i] = Source then
    begin
      // Arr√™ter la source
      alSourceStop(Source);
      FAvailable[i] := True;
      Exit;
    end;
  end;
end;

function TSourcePool.GetActiveCount: Integer;
var
  i: Integer;
begin
  Result := 0;
  for i := 0 to FMaxSources - 1 do
    if not FAvailable[i] then
      Inc(Result);
end;
```

### 2. Gestion des priorit√©s

Arr√™ter les sons de faible priorit√© quand n√©cessaire.

```pascal
type
  TPrioritizedSound = record
    Source: ALuint;
    Priority: Integer;
    LastPlayTime: QWord;
  end;

procedure PlayWithPriority(Sound: TOpenALSound; Priority: Integer;
  var ActiveSounds: array of TPrioritizedSound);
var
  i, LowestIndex: Integer;
  LowestPriority: Integer;
  Source: ALuint;
begin
  // Chercher une source libre
  Source := 0;
  for i := 0 to High(ActiveSounds) do
  begin
    if ActiveSounds[i].Source = 0 then
    begin
      Source := AcquireSource;
      ActiveSounds[i].Source := Source;
      ActiveSounds[i].Priority := Priority;
      ActiveSounds[i].LastPlayTime := GetTickCount64;
      // Jouer le son
      Exit;
    end;
  end;

  // Pas de source libre, chercher la priorit√© la plus basse
  LowestPriority := MaxInt;
  LowestIndex := -1;

  for i := 0 to High(ActiveSounds) do
  begin
    if ActiveSounds[i].Priority < LowestPriority then
    begin
      LowestPriority := ActiveSounds[i].Priority;
      LowestIndex := i;
    end;
  end;

  // Si le nouveau son est plus prioritaire, remplacer
  if Priority > LowestPriority then
  begin
    alSourceStop(ActiveSounds[LowestIndex].Source);
    ActiveSounds[LowestIndex].Priority := Priority;
    ActiveSounds[LowestIndex].LastPlayTime := GetTickCount64;
    // Jouer le nouveau son
  end;
end;
```

### 3. Distance culling

Ne pas jouer les sons trop lointains.

```pascal
function ShouldPlaySound(SoundPosition, ListenerPosition: TVector3;
  MaxDistance: Single): Boolean;
var
  Distance: Single;
begin
  Distance := Sqrt(
    Sqr(SoundPosition.X - ListenerPosition.X) +
    Sqr(SoundPosition.Y - ListenerPosition.Y) +
    Sqr(SoundPosition.Z - ListenerPosition.Z)
  );

  Result := Distance <= MaxDistance;
end;

// Utilisation
if ShouldPlaySound(EnemyPosition, PlayerPosition, 50.0) then
  EnemySound.Play;
```

### 4. Cache de buffers

√âviter de recharger les m√™mes fichiers.

```pascal
type
  TBufferCache = class
  private
    FCache: TStringList; // Filename -> Buffer ID
  public
    constructor Create;
    destructor Destroy; override;

    function GetBuffer(const Filename: string): ALuint;
    procedure Clear;
  end;

constructor TBufferCache.Create;
begin
  inherited Create;
  FCache := TStringList.Create;
  FCache.Sorted := True;
end;

destructor TBufferCache.Destroy;
begin
  Clear;
  FCache.Free;
  inherited;
end;

function TBufferCache.GetBuffer(const Filename: string): ALuint;
var
  Index: Integer;
  Buffer: ALuint;
  Format: ALenum;
  Data: Pointer;
  Size, Frequency: ALsizei;
begin
  Index := FCache.IndexOf(Filename);

  if Index >= 0 then
  begin
    // Buffer d√©j√† en cache
    Result := ALuint(PtrUInt(FCache.Objects[Index]));
  end
  else
  begin
    // Charger et mettre en cache
    if LoadWaveFile(Filename, Format, Data, Size, Frequency) then
    begin
      alGenBuffers(1, @Buffer);
      alBufferData(Buffer, Format, Data, Size, Frequency);
      FreeMem(Data);

      FCache.AddObject(Filename, TObject(PtrUInt(Buffer)));
      Result := Buffer;
    end
    else
      Result := 0;
  end;
end;

procedure TBufferCache.Clear;
var
  i: Integer;
  Buffer: ALuint;
begin
  for i := 0 to FCache.Count - 1 do
  begin
    Buffer := ALuint(PtrUInt(FCache.Objects[i]));
    alDeleteBuffers(1, @Buffer);
  end;
  FCache.Clear;
end;
```

## Formats audio avanc√©s

### Support OGG Vorbis

Pour utiliser OGG, vous aurez besoin d'une biblioth√®que externe comme `libogg` et `libvorbis`.

```pascal
unit OggVorbisLoader;

{$mode objfpc}{$H+}

interface

uses
  OpenAL;

// Fonction pour charger un fichier OGG
function LoadOggFile(const Filename: string; out Format: ALenum;
  out Data: Pointer; out Size: ALsizei; out Frequency: ALsizei): Boolean;

implementation

// N√©cessite les bindings pour libvorbis
// Implementation simplifi√©e - voir documentation libvorbis

function LoadOggFile(const Filename: string; out Format: ALenum;
  out Data: Pointer; out Size: ALsizei; out Frequency: ALsizei): Boolean;
begin
  // TODO: Impl√©menter avec libvorbis
  Result := False;
  WriteLn('Support OGG non impl√©ment√© dans cet exemple');
end;

end.
```

### D√©tection automatique du format

```pascal
function LoadAudioFile(const Filename: string; out Format: ALenum;
  out Data: Pointer; out Size: ALsizei; out Frequency: ALsizei): Boolean;
var
  Ext: string;
begin
  Ext := LowerCase(ExtractFileExt(Filename));

  case Ext of
    '.wav': Result := LoadWaveFile(Filename, Format, Data, Size, Frequency);
    '.ogg': Result := LoadOggFile(Filename, Format, Data, Size, Frequency);
    // '.mp3': Result := LoadMP3File(Filename, Format, Data, Size, Frequency);
    else
    begin
      WriteLn('Format non support√©: ', Ext);
      Result := False;
    end;
  end;
end;
```

## D√©bogage et outils

### Affichage des informations audio

```pascal
procedure PrintAudioInfo(Audio: TOpenALSystem);
var
  X, Y, Z: Single;
begin
  WriteLn('=== Informations OpenAL ===');
  WriteLn('Vendor:   ', Audio.GetVendor);
  WriteLn('Renderer: ', Audio.GetRenderer);
  WriteLn('Version:  ', Audio.GetVersion);
  WriteLn;

  Audio.GetListenerPosition(X, Y, Z);
  WriteLn('Position du Listener: (', X:0:2, ', ', Y:0:2, ', ', Z:0:2, ')');
  WriteLn;

  WriteLn('Extensions support√©es:');
  WriteLn(Audio.GetExtensions);
  WriteLn;
end;
```

### V√©rification d'erreurs

```pascal
procedure CheckOpenALError(const Context: string);
var
  Error: ALenum;
  ErrorMsg: string;
begin
  Error := alGetError;
  if Error <> AL_NO_ERROR then
  begin
    case Error of
      AL_INVALID_NAME:      ErrorMsg := 'Invalid name';
      AL_INVALID_ENUM:      ErrorMsg := 'Invalid enum';
      AL_INVALID_VALUE:     ErrorMsg := 'Invalid value';
      AL_INVALID_OPERATION: ErrorMsg := 'Invalid operation';
      AL_OUT_OF_MEMORY:     ErrorMsg := 'Out of memory';
      else                  ErrorMsg := 'Unknown error';
    end;

    WriteLn('ERREUR OpenAL [', Context, ']: ', ErrorMsg, ' (', Error, ')');
  end;
end;

// Utilisation
alGenBuffers(1, @Buffer);
CheckOpenALError('alGenBuffers');
```

### Logger audio

```pascal
type
  TAudioLogger = class
  private
    FLogFile: TextFile;
    FEnabled: Boolean;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    procedure Log(const Msg: string);
    procedure LogError(const Context, Error: string);
    procedure LogSound(const SoundName: string; Playing: Boolean);

    property Enabled: Boolean read FEnabled write FEnabled;
  end;

constructor TAudioLogger.Create(const Filename: string);
begin
  inherited Create;
  AssignFile(FLogFile, Filename);
  Rewrite(FLogFile);
  FEnabled := True;

  Log('=== Audio Log Started ===');
  Log('Time: ' + DateTimeToStr(Now));
end;

destructor TAudioLogger.Destroy;
begin
  if FEnabled then
  begin
    Log('=== Audio Log Ended ===');
    CloseFile(FLogFile);
  end;
  inherited;
end;

procedure TAudioLogger.Log(const Msg: string);
begin
  if FEnabled then
  begin
    WriteLn(FLogFile, '[', TimeToStr(Now), '] ', Msg);
    Flush(FLogFile);
  end;
end;

procedure TAudioLogger.LogError(const Context, Error: string);
begin
  Log('ERROR in ' + Context + ': ' + Error);
end;

procedure TAudioLogger.LogSound(const SoundName: string; Playing: Boolean);
begin
  if Playing then
    Log('Playing: ' + SoundName)
  else
    Log('Stopped: ' + SoundName);
end;
```

## Bonnes pratiques

### 1. Organisation des fichiers audio

```
sounds/
‚îú‚îÄ‚îÄ music/
‚îÇ   ‚îú‚îÄ‚îÄ menu.ogg
‚îÇ   ‚îú‚îÄ‚îÄ level1.ogg
‚îÇ   ‚îú‚îÄ‚îÄ level2.ogg
‚îÇ   ‚îî‚îÄ‚îÄ boss.ogg
‚îú‚îÄ‚îÄ sfx/
‚îÇ   ‚îú‚îÄ‚îÄ jump.wav
‚îÇ   ‚îú‚îÄ‚îÄ shoot.wav
‚îÇ   ‚îú‚îÄ‚îÄ hit.wav
‚îÇ   ‚îî‚îÄ‚îÄ coin.wav
‚îú‚îÄ‚îÄ voice/
‚îÇ   ‚îú‚îÄ‚îÄ intro_en.ogg
‚îÇ   ‚îú‚îÄ‚îÄ intro_fr.ogg
‚îÇ   ‚îî‚îÄ‚îÄ tutorial_en.ogg
‚îî‚îÄ‚îÄ ambient/
    ‚îú‚îÄ‚îÄ forest.ogg
    ‚îú‚îÄ‚îÄ cave.ogg
    ‚îî‚îÄ‚îÄ city.ogg
```

### 2. Conventions de nommage

```
categorie_description_variation.extension

Exemples:
sfx_jump_01.wav
sfx_jump_02.wav
sfx_footstep_grass_01.wav
sfx_footstep_grass_02.wav
music_menu_loop.ogg
voice_tutorial_en.ogg
ambient_forest_day.ogg
```

### 3. Recommandations de format

**Musique** :
- Format : OGG Vorbis (compression)
- Bitrate : 128-192 kbps
- Sample rate : 44100 Hz
- Canaux : St√©r√©o

**Effets sonores courts** :
- Format : WAV (non compress√©, latence minimale)
- Sample rate : 22050 ou 44100 Hz
- Bits : 16-bit
- Canaux : Mono (pour 3D) ou St√©r√©o

**Voix** :
- Format : OGG ou WAV selon la longueur
- Sample rate : 44100 Hz
- Canaux : Mono

### 4. Volumes recommand√©s

```pascal
const
  DEFAULT_MASTER_VOLUME = 0.8;
  DEFAULT_MUSIC_VOLUME = 0.6;
  DEFAULT_SFX_VOLUME = 1.0;
  DEFAULT_VOICE_VOLUME = 0.9;
  DEFAULT_AMBIENT_VOLUME = 0.5;
```

### 5. Priorit√©s des sons

```pascal
const
  PRIORITY_CRITICAL = 100;  // Interface UI, dialogues importants
  PRIORITY_HIGH = 80;       // Effets de gameplay importants
  PRIORITY_NORMAL = 50;     // Effets standards
  PRIORITY_LOW = 30;        // Sons ambiants
  PRIORITY_MINIMAL = 10;    // D√©tails optionnels
```

## Checklist de d√©veloppement

### Avant de commencer

- [ ] Installer OpenAL sur toutes les plateformes cibles
- [ ] Cr√©er les bindings Pascal pour OpenAL
- [ ] Tester que OpenAL fonctionne
- [ ] D√©finir les cat√©gories audio
- [ ] Planifier l'organisation des fichiers

### Pendant le d√©veloppement

- [ ] Impl√©menter le chargement de WAV
- [ ] Cr√©er le wrapper de haut niveau
- [ ] Ajouter le support du streaming pour la musique
- [ ] Impl√©menter l'audio 3D si n√©cessaire
- [ ] Cr√©er un gestionnaire audio global
- [ ] Ajouter un menu d'options audio
- [ ] Impl√©menter la sauvegarde des param√®tres
- [ ] Optimiser avec un pool de sources
- [ ] Ajouter un syst√®me de priorit√©s

### Tests

- [ ] Tester sur Windows
- [ ] Tester sur Linux
- [ ] Tester sur macOS (si applicable)
- [ ] V√©rifier les performances (CPU/m√©moire)
- [ ] Tester avec beaucoup de sons simultan√©s
- [ ] V√©rifier l'audio 3D (positionnement, Doppler)
- [ ] Tester le streaming (pas de coupures)
- [ ] Valider le menu d'options
- [ ] Tester les sauvegardes de param√®tres

### Avant la release

- [ ] Optimiser la taille des fichiers audio
- [ ] V√©rifier la qualit√© audio
- [ ] S'assurer que OpenAL est inclus/installable
- [ ] Documenter les d√©pendances
- [ ] Tester sur diff√©rentes configurations
- [ ] Ajouter un mode "sans audio" de secours

## Comparaison des solutions audio

| Caract√©ristique | DirectSound | XAudio2 | PulseAudio | ALSA | OpenAL |
|-----------------|-------------|---------|------------|------|--------|
| **Multi-plateforme** | Non | Non | Non | Non | ‚úÖ Oui |
| **Audio 3D** | Limit√© | Avec X3DAudio | Non | Non | ‚úÖ Natif |
| **Complexit√©** | Moyenne | √âlev√©e | Moyenne | √âlev√©e | Faible |
| **Performance** | Bonne | Excellente | Bonne | Excellente | Excellente |
| **Latence** | Moyenne | Faible | Moyenne | Tr√®s faible | Faible |
| **Recommand√© pour jeux** | Non | Windows uniquement | Non | Non | ‚úÖ Oui |

## Exemple complet de jeu

```pascal
program GameWithOpenAL;

{$mode objfpc}{$H+}

uses
  GameAudioManager, SysUtils, Math;

type
  TPlayer = record
    X, Y, Z: Single;
    VX, VY, VZ: Single;
  end;

var
  AudioMgr: TGameAudioManager;
  Player: TPlayer;
  MusicIndex, FootstepIndex, AmbientIndex: Integer;
  Running: Boolean;
  DeltaTime: Single;
  LastTime, CurrentTime: QWord;

procedure InitAudio;
begin
  AudioMgr := TGameAudioManager.Create;

  // Charger les param√®tres
  AudioMgr.LoadSettings('config.ini');

  // Charger les sons
  MusicIndex := AudioMgr.LoadStreamingSound('sounds/music/game.ogg', acMusic);
  FootstepIndex := AudioMgr.LoadSound('sounds/sfx/footstep.wav', acSFX, 50, 'footstep');
  AmbientIndex := AudioMgr.LoadStreamingSound('sounds/ambient/forest.ogg', acAmbient);

  // Jouer l'ambiance et la musique
  AudioMgr.PlaySound(MusicIndex, True);
  AudioMgr.PlaySound(AmbientIndex, True);
end;

procedure UpdatePlayer;
begin
  // Simulation de mouvement
  if KeyPressed then
  begin
    case ReadKey of
      'w': Player.VZ := -5.0;
      's': Player.VZ := 5.0;
      'a': Player.VX := -5.0;
      'd': Player.VX := 5.0;
      'q': Running := False;
    end;
  end;

  // Appliquer la v√©locit√©
  Player.X := Player.X + Player.VX * DeltaTime;
  Player.Z := Player.Z + Player.VZ * DeltaTime;

  // Friction
  Player.VX := Player.VX * 0.9;
  Player.VZ := Player.VZ * 0.9;

  // Jouer le son de pas si le joueur bouge
  if (Abs(Player.VX) > 0.1) or (Abs(Player.VZ) > 0.1) then
  begin
    if not AudioMgr.IsPlaying(FootstepIndex) then
      AudioMgr.PlaySound(FootstepIndex);
  end;
end;

procedure UpdateAudio;
begin
  // Mettre √† jour la position du listener
  AudioMgr.SetListenerPosition(Player.X, Player.Y, Player.Z);

  // Orientation (regarde vers -Z)
  AudioMgr.SetListenerOrientation(0, 0, -1, 0, 1, 0);

  // Mettre √† jour le streaming
  AudioMgr.Update;
end;

procedure GameLoop;
begin
  LastTime := GetTickCount64;
  Running := True;

  WriteLn('=== Jeu avec OpenAL ===');
  WriteLn('WASD pour bouger, Q pour quitter');
  WriteLn;

  while Running do
  begin
    CurrentTime := GetTickCount64;
    DeltaTime := (CurrentTime - LastTime) / 1000.0;
    LastTime := CurrentTime;

    UpdatePlayer;
    UpdateAudio;

    // Afficher la position
    if (CurrentTime mod 1000) < 50 then
      WriteLn('Position: (', Player.X:0:1, ', ', Player.Y:0:1, ', ', Player.Z:0:1, ')');

    Sleep(16); // ~60 FPS
  end;
end;

begin
  try
    Player.X := 0;
    Player.Y := 0;
    Player.Z := 0;
    Player.VX := 0;
    Player.VY := 0;
    Player.VZ := 0;

    InitAudio;

    try
      GameLoop;
    finally
      // Sauvegarder les param√®tres
      AudioMgr.SaveSettings('config.ini');
      AudioMgr.Free;
    end;

  except
    on E: Exception do
      WriteLn('Erreur: ', E.Message);
  end;
end.
```

## Ressources et documentation

### Documentation officielle

- **OpenAL 1.1 Specification** : https://www.openal.org/documentation/
- **OpenAL Soft** : https://openal-soft.org/
- **OpenAL Programming Guide** : https://openal.org/documentation/OpenAL_Programmers_Guide.pdf

### Biblioth√®ques utiles

- **OpenAL Soft** : Impl√©mentation open source recommand√©e
- **libsndfile** : Pour charger diff√©rents formats audio
- **libvorbis** : Pour le support OGG Vorbis
- **mpg123** : Pour le support MP3

### Outils

- **Audacity** : √âditeur audio gratuit
- **OpenAL Info** : Afficher les infos de votre installation OpenAL
- **alsoft-config** : Configuration graphique d'OpenAL Soft

## Conclusion

OpenAL est la solution id√©ale pour l'audio dans les jeux multi-plateformes d√©velopp√©s avec FreePascal/Lazarus. Son API simple mais puissante permet de cr√©er des exp√©riences audio riches et immersives.

### Points cl√©s √† retenir

‚úÖ **Multi-plateforme** : Un seul code pour Windows, Linux, macOS
‚úÖ **Audio 3D natif** : Positionnement spatial, Doppler, att√©nuation
‚úÖ **API simple** : Plus facile que DirectSound/XAudio2/ALSA
‚úÖ **Performant** : G√®re facilement des dizaines de sources simultan√©es
‚úÖ **Streaming** : Facile √† impl√©menter pour la musique
‚úÖ **Extensible** : Support des effets avec EFX
‚úÖ **Standard** : Utilis√© par de nombreux jeux professionnels
‚úÖ **Open source** : OpenAL Soft est gratuit et bien maintenu

### Avantages pour FreePascal

- Bindings simples √† cr√©er (API C)
- Pas de d√©pendances COM/ActiveX
- M√™me code sur toutes les plateformes
- Excellente performance native
- Documentation abondante

### Recommandation finale

Pour tout nouveau projet de jeu en FreePascal/Lazarus, **utilisez OpenAL**. C'est la solution qui offre le meilleur rapport simplicit√©/puissance/portabilit√©.

Avec les wrappers et le gestionnaire audio pr√©sent√©s dans ce tutoriel, vous avez tout ce qu'il faut pour cr√©er un syst√®me audio professionnel qui fonctionnera parfaitement sur Windows, Linux et macOS.

Bon d√©veloppement audio ! üéµüéÆ


‚è≠Ô∏è [Input devices et contr√¥leurs](/23-developpement-jeux/05-input-devices-controleurs.md)
