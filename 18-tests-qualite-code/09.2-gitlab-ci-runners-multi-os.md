üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.9.2 GitLab CI avec Runners Multi-OS

## Introduction √† GitLab CI/CD

### Qu'est-ce que GitLab CI/CD ?

GitLab CI/CD est un syst√®me d'int√©gration et de d√©ploiement continu int√©gr√© directement dans GitLab. Contrairement √† GitHub Actions qui utilise des fichiers YAML dans `.github/workflows/`, GitLab utilise un unique fichier `.gitlab-ci.yml` √† la racine du projet.

### Pourquoi utiliser GitLab CI pour FreePascal ?

**Avantages de GitLab CI :**

‚úÖ **Gratuit et g√©n√©reux** : 400 minutes/mois gratuites (SaaS), illimit√© en auto-h√©berg√©
‚úÖ **Runners personnalis√©s** : installez vos propres machines d'ex√©cution
‚úÖ **Multi-OS natif** : Windows, Linux, macOS avec des runners d√©di√©s
‚úÖ **Auto-h√©bergement** : contr√¥le total de votre infrastructure CI/CD
‚úÖ **Interface puissante** : visualisation des pipelines, artefacts, environnements
‚úÖ **Registry int√©gr√©** : Docker registry et package registry inclus

**Cas d'usage pour FreePascal :**

1. **Compilation crois√©e** : compiler pour Windows depuis Linux et vice-versa
2. **Tests parall√®les** : tester simultan√©ment sur plusieurs OS
3. **D√©ploiement multi-cible** : d√©ployer sur serveurs Windows et Linux
4. **Build d'entreprise** : utiliser vos propres serveurs de build

---

## Architecture de GitLab CI

### Concepts Cl√©s

#### 1. Pipeline (Pipeline)

Un **pipeline** est l'ensemble du processus CI/CD, divis√© en **stages** (√©tapes).

```
Pipeline
‚îú‚îÄ‚îÄ Stage 1: Build
‚îÇ   ‚îú‚îÄ‚îÄ Job: build-linux
‚îÇ   ‚îî‚îÄ‚îÄ Job: build-windows
‚îú‚îÄ‚îÄ Stage 2: Test
‚îÇ   ‚îú‚îÄ‚îÄ Job: test-linux
‚îÇ   ‚îî‚îÄ‚îÄ Job: test-windows
‚îî‚îÄ‚îÄ Stage 3: Deploy
    ‚îî‚îÄ‚îÄ Job: deploy-production
```

#### 2. Stage (√âtape)

Un **stage** est une phase du pipeline. Les jobs d'un m√™me stage s'ex√©cutent en parall√®le.

**Stages par d√©faut :**
- `.pre` : avant tout
- `build` : compilation
- `test` : tests
- `deploy` : d√©ploiement
- `.post` : apr√®s tout

#### 3. Job (T√¢che)

Un **job** est une unit√© de travail qui s'ex√©cute sur un runner.

```yaml
build-linux:           # Nom du job
  stage: build         # Dans quel stage
  script:              # Commandes √† ex√©cuter
    - fpc MonProgramme.pas
```

#### 4. Runner (Ex√©cuteur)

Un **runner** est une machine (physique ou virtuelle) qui ex√©cute les jobs. GitLab propose :

- **Shared runners** : runners partag√©s fournis par GitLab (SaaS)
- **Group runners** : runners partag√©s au niveau d'un groupe de projets
- **Specific runners** : runners d√©di√©s √† un projet sp√©cifique

---

## Premier Pipeline : Hello World

### Cr√©er le Fichier .gitlab-ci.yml

**Emplacement :** `.gitlab-ci.yml` √† la racine du projet

```yaml
# Pipeline simple pour FreePascal

stages:
  - build

build-job:
  stage: build
  script:
    - echo "D√©but de la compilation"
    - fpc --version
    - fpc MonProgramme.pas
    - echo "Compilation termin√©e ‚úÖ"
```

### Comprendre ce Pipeline

**Structure :**
- `stages:` : d√©finit les √©tapes du pipeline (ici une seule : `build`)
- `build-job:` : nom du job
- `stage: build` : ce job appartient au stage "build"
- `script:` : liste des commandes shell √† ex√©cuter

**D√©roulement :**
1. GitLab d√©tecte le commit et lit `.gitlab-ci.yml`
2. Le pipeline d√©marre automatiquement
3. Un runner disponible prend le job `build-job`
4. Les commandes du `script` s'ex√©cutent s√©quentiellement
5. Le r√©sultat (succ√®s/√©chec) est affich√© dans GitLab

### Visualiser le Pipeline

Dans GitLab :
1. Allez dans **CI/CD ‚Üí Pipelines**
2. Cliquez sur le pipeline en cours
3. Vous voyez le stage `build` avec le job `build-job`
4. Cliquez sur le job pour voir les logs en temps r√©el

---

## Configuration Multi-OS avec Tags

### Concept des Tags

Les **tags** permettent d'assigner des jobs √† des runners sp√©cifiques selon leurs caract√©ristiques (OS, capacit√©s).

**Exemples de tags courants :**
- `linux` : runner Linux
- `windows` : runner Windows
- `docker` : runner avec support Docker
- `shell` : runner qui ex√©cute directement les commandes

### Pipeline Multi-OS Basique

```yaml
stages:
  - build

# Job pour Linux
build-linux:
  stage: build
  tags:
    - linux        # Ce job n√©cessite un runner Linux
  script:
    - apt-get update
    - apt-get install -y fpc
    - fpc -iV
    - fpc -O2 MonProgramme.pas
  artifacts:
    paths:
      - MonProgramme
    expire_in: 1 week

# Job pour Windows
build-windows:
  stage: build
  tags:
    - windows      # Ce job n√©cessite un runner Windows
  script:
    - choco install freepascal -y
    - fpc -iV
    - fpc -O2 MonProgramme.pas
  artifacts:
    paths:
      - MonProgramme.exe
    expire_in: 1 week
```

**Important :** Les deux jobs s'ex√©cutent **en parall√®le** car ils sont dans le m√™me stage.

---

## Images Docker pour Linux

### Utiliser une Image Docker Pr√™te

Au lieu d'installer FreePascal √† chaque fois, utilisez une image Docker pr√©configur√©e :

```yaml
build-linux:
  image: domisse/fpc:latest    # Image Docker avec FPC pr√©install√©
  stage: build
  script:
    - fpc -iV
    - fpc -O2 src/MonProgramme.pas
  artifacts:
    paths:
      - src/MonProgramme
```

**Avantages :**
- ‚úÖ Environnement reproductible
- ‚úÖ Pas d'installation √† chaque build (gain de temps)
- ‚úÖ Version de FPC garantie

### Images Docker Populaires pour FreePascal

| Image | Description | Utilisation |
|-------|-------------|-------------|
| `domisse/fpc` | FPC officiel | Build standard |
| `alpine:latest` + install | Minimal | Build l√©ger |
| `ubuntu:22.04` + install | Complet | Tests complets |

### Cr√©er votre Propre Image Docker

**Dockerfile :**

```dockerfile
FROM ubuntu:22.04

# Installer FreePascal
RUN apt-get update && \
    apt-get install -y fpc fpc-source && \
    rm -rf /var/lib/apt/lists/*

# V√©rifier l'installation
RUN fpc -iV

WORKDIR /builds
```

**Builder et publier :**

```yaml
build-docker-image:
  stage: .pre
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE/fpc:latest .
    - docker push $CI_REGISTRY_IMAGE/fpc:latest
  only:
    - main
```

---

## Pipeline Complet Multi-Stages

### Structure Professionnelle

```yaml
# D√©finition des stages
stages:
  - build
  - test
  - package
  - deploy

# Variables globales
variables:
  FPC_VERSION: "3.2.2"
  BUILD_DIR: "build"

# Template pour √©viter la duplication
.build_template: &build_template
  script:
    - mkdir -p $BUILD_DIR
    - fpc -O2 -FU$BUILD_DIR -FE$BUILD_DIR src/MonProgramme.pas
  artifacts:
    paths:
      - $BUILD_DIR/
    expire_in: 1 day

# ============================================
# STAGE 1: BUILD
# ============================================

build-linux:
  <<: *build_template
  stage: build
  image: ubuntu:22.04
  tags:
    - docker
  before_script:
    - apt-get update
    - apt-get install -y fpc
    - fpc -iV

build-windows:
  <<: *build_template
  stage: build
  tags:
    - windows
    - shell
  before_script:
    - choco install freepascal -y --force
    - fpc -iV

# ============================================
# STAGE 2: TEST
# ============================================

test-linux:
  stage: test
  image: ubuntu:22.04
  tags:
    - docker
  dependencies:
    - build-linux
  before_script:
    - apt-get update && apt-get install -y fpc
  script:
    - echo "Ex√©cution des tests Linux"
    - chmod +x $BUILD_DIR/MonProgramme
    - cd tests
    - fpc -Fu../src TestsSuite.pas
    - ./TestsSuite --format=plain

test-windows:
  stage: test
  tags:
    - windows
    - shell
  dependencies:
    - build-windows
  script:
    - echo "Ex√©cution des tests Windows"
    - cd tests
    - fpc -Fu..\src TestsSuite.pas
    - .\TestsSuite.exe --format=plain

# ============================================
# STAGE 3: PACKAGE
# ============================================

package-linux:
  stage: package
  image: ubuntu:22.04
  tags:
    - docker
  dependencies:
    - build-linux
  script:
    - apt-get update && apt-get install -y tar gzip
    - tar -czf MonProgramme-linux-$CI_COMMIT_TAG.tar.gz -C $BUILD_DIR .
  artifacts:
    paths:
      - MonProgramme-linux-$CI_COMMIT_TAG.tar.gz
  only:
    - tags

package-windows:
  stage: package
  tags:
    - windows
    - shell
  dependencies:
    - build-windows
  script:
    - Compress-Archive -Path $env:BUILD_DIR\* -DestinationPath MonProgramme-windows-$env:CI_COMMIT_TAG.zip
  artifacts:
    paths:
      - MonProgramme-windows-*.zip
  only:
    - tags

# ============================================
# STAGE 4: DEPLOY
# ============================================

deploy-production:
  stage: deploy
  tags:
    - linux
  script:
    - echo "D√©ploiement en production"
    - scp $BUILD_DIR/MonProgramme user@server:/opt/app/
    - ssh user@server "systemctl restart monapp"
  only:
    - tags
  when: manual  # N√©cessite une confirmation manuelle
```

### √âl√©ments Cl√©s Expliqu√©s

#### Variables

```yaml
variables:
  FPC_VERSION: "3.2.2"
  BUILD_DIR: "build"
```

Variables accessibles dans tous les jobs via `$FPC_VERSION` ou `$BUILD_DIR`.

**Variables pr√©d√©finies par GitLab :**
- `$CI_COMMIT_SHA` : hash du commit
- `$CI_COMMIT_TAG` : nom du tag (si c'est un tag)
- `$CI_PROJECT_NAME` : nom du projet
- `$CI_REGISTRY` : URL du registry Docker GitLab

#### Templates (Anchors YAML)

```yaml
.build_template: &build_template
  script:
    - fpc MonProgramme.pas

build-linux:
  <<: *build_template  # R√©utilise le template
  tags:
    - linux
```

√âvite la duplication de code.

#### Dependencies

```yaml
test-linux:
  dependencies:
    - build-linux  # R√©cup√®re les artefacts de build-linux
```

Permet de passer des fichiers (artefacts) d'un job √† un autre.

#### Rules et Conditions

```yaml
only:
  - tags      # S'ex√©cute seulement sur les tags

except:
  - branches  # Ne s'ex√©cute PAS sur les branches

when: manual  # N√©cessite un clic manuel pour d√©marrer
```

---

## Installation et Configuration des Runners

### Shared Runners (Runners Partag√©s GitLab.com)

Si vous utilisez GitLab.com, des runners partag√©s sont automatiquement disponibles avec les tags :
- `saas-linux-small-amd64`
- `saas-linux-medium-amd64`
- `saas-windows-medium-amd64` (limit√©)

**Activation :**
1. Allez dans **Settings ‚Üí CI/CD ‚Üí Runners**
2. Activez "Enable shared runners for this project"

### Installer un Runner Linux Sp√©cifique

#### Installation sur Ubuntu

```bash
# 1. Ajouter le d√©p√¥t GitLab
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash

# 2. Installer le runner
sudo apt-get install gitlab-runner

# 3. V√©rifier l'installation
gitlab-runner --version
```

#### Enregistrer le Runner

```bash
sudo gitlab-runner register
```

**Questions pos√©es :**

1. **GitLab instance URL :** `https://gitlab.com` (ou votre instance)
2. **Registration token :** Trouvez-le dans `Settings ‚Üí CI/CD ‚Üí Runners`
3. **Description :** `Linux FPC Builder`
4. **Tags :** `linux, fpc, docker`
5. **Executor :** `docker` (recommand√©) ou `shell`
6. **Default Docker image :** `ubuntu:22.04`

#### Configuration Avanc√©e

**Fichier `/etc/gitlab-runner/config.toml` :**

```toml
concurrent = 4  # Nombre de jobs simultan√©s

[[runners]]
  name = "Linux FPC Builder"
  url = "https://gitlab.com"
  token = "votre_token"
  executor = "docker"
  [runners.docker]
    tls_verify = false
    image = "ubuntu:22.04"
    privileged = false
    disable_cache = false
    volumes = ["/cache"]
    shm_size = 0
  [runners.cache]
    Type = "s3"
    Shared = true
```

### Installer un Runner Windows Sp√©cifique

#### Installation sur Windows

```powershell
# 1. T√©l√©charger le runner
Invoke-WebRequest -Uri "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-windows-amd64.exe" -OutFile "C:\GitLab-Runner\gitlab-runner.exe"

# 2. Installer le service
cd C:\GitLab-Runner
.\gitlab-runner.exe install

# 3. D√©marrer le service
.\gitlab-runner.exe start
```

#### Enregistrer le Runner Windows

```powershell
.\gitlab-runner.exe register
```

**Configuration recommand√©e pour Windows :**
- **Executor :** `shell` (PowerShell)
- **Tags :** `windows, fpc, shell`

#### Pr√©parer le Runner Windows

```powershell
# Installer FreePascal
choco install freepascal -y

# Installer Git (n√©cessaire pour le checkout)
choco install git -y

# V√©rifier
fpc -iV
git --version
```

---

## Artefacts et Cache

### Artefacts (Artifacts)

Les **artefacts** sont des fichiers g√©n√©r√©s par un job et conserv√©s pour :
- √ätre t√©l√©charg√©s depuis l'interface GitLab
- √ätre utilis√©s par les jobs suivants
- √ätre attach√©s aux releases

#### D√©finir des Artefacts

```yaml
build-linux:
  script:
    - fpc -O2 MonProgramme.pas
  artifacts:
    name: "MonProgramme-$CI_COMMIT_REF_NAME"
    paths:
      - MonProgramme
      - "*.log"
      - config/
    exclude:
      - "*.tmp"
    expire_in: 30 days
    reports:
      dotenv: build.env
```

**Options expliqu√©es :**
- `name` : nom de l'archive d'artefacts
- `paths` : fichiers/dossiers √† conserver
- `exclude` : fichiers √† exclure
- `expire_in` : dur√©e de conservation (1 day, 1 week, 30 days, never)
- `reports` : rapports sp√©ciaux (coverage, junit, dotenv)

#### T√©l√©charger les Artefacts

Dans l'interface GitLab :
1. Allez dans **CI/CD ‚Üí Pipelines**
2. Cliquez sur le pipeline
3. Cliquez sur le bouton de t√©l√©chargement √† c√¥t√© du job

### Cache

Le **cache** permet de r√©utiliser des fichiers entre les ex√©cutions de pipeline (d√©pendances, compilations interm√©diaires).

```yaml
variables:
  CACHE_VERSION: "v1"

# Cache global
cache:
  key: "$CI_COMMIT_REF_SLUG-$CACHE_VERSION"
  paths:
    - .fpc/
    - lib/

build-linux:
  script:
    - fpc -O2 MonProgramme.pas
  cache:
    key: "linux-build-$CACHE_VERSION"
    paths:
      - .fpc/
      - *.ppu
      - *.o
    policy: pull-push  # T√©l√©charge et met √† jour le cache
```

**Diff√©rence Cache vs Artefacts :**

| Cache | Artefacts |
|-------|-----------|
| Temporaire | Permanents |
| Optimisation | Livrables |
| Non garanti | Garanti |
| Entre pipelines | Entre jobs |

---

## Variables et Secrets

### Variables d'Environnement

#### Variables dans .gitlab-ci.yml

```yaml
variables:
  # Variables simples
  PROJECT_NAME: "MonProjet"
  BUILD_VERSION: "1.0.0"

  # Variables multi-lignes
  DEPLOY_SCRIPT: |
    echo "D√©ploiement en cours..."
    scp MonProgramme user@server:/opt/app/

build:
  script:
    - echo "Projet: $PROJECT_NAME"
    - echo "Version: $BUILD_VERSION"
```

#### Variables Prot√©g√©es (Secrets)

Pour stocker des donn√©es sensibles (mots de passe, tokens) :

**1. Ajouter une variable dans GitLab :**
- Allez dans **Settings ‚Üí CI/CD ‚Üí Variables**
- Cliquez sur **Add variable**
- Nom : `DEPLOY_PASSWORD`
- Valeur : `votre_mot_de_passe_secret`
- ‚úÖ Cochez **Protect variable** (disponible seulement sur branches/tags prot√©g√©s)
- ‚úÖ Cochez **Mask variable** (masqu√© dans les logs)

**2. Utiliser la variable :**

```yaml
deploy:
  script:
    - echo "Connexion au serveur..."
    - sshpass -p $DEPLOY_PASSWORD scp MonProgramme user@server:/opt/app/
```

**Important :** La variable `$DEPLOY_PASSWORD` ne sera JAMAIS affich√©e dans les logs.

### Variables Pr√©d√©finies Utiles

| Variable | Description | Exemple |
|----------|-------------|---------|
| `$CI_COMMIT_SHA` | Hash du commit | `a3f5c9d...` |
| `$CI_COMMIT_SHORT_SHA` | Hash court | `a3f5c9d` |
| `$CI_COMMIT_REF_NAME` | Nom de la branche ou du tag | `main` |
| `$CI_COMMIT_TAG` | Nom du tag (si applicable) | `v1.0.0` |
| `$CI_PROJECT_NAME` | Nom du projet | `mon-projet` |
| `$CI_PROJECT_DIR` | R√©pertoire du projet | `/builds/user/projet` |
| `$CI_PIPELINE_ID` | ID du pipeline | `12345` |
| `$CI_JOB_NAME` | Nom du job | `build-linux` |
| `$CI_RUNNER_EXECUTABLE_ARCH` | Architecture du runner | `linux/amd64` |

**Exemple d'utilisation :**

```yaml
build:
  script:
    - echo "Compilation du commit $CI_COMMIT_SHORT_SHA"
    - fpc -dVERSION=$CI_COMMIT_TAG MonProgramme.pas
    - echo "Build termin√©, artefact: MonProgramme-$CI_COMMIT_TAG"
```

---

## Conditions et Rules

### Contr√¥ler l'Ex√©cution des Jobs

#### Only / Except (Syntaxe Classique)

```yaml
# S'ex√©cute seulement sur main
deploy-prod:
  script:
    - echo "D√©ploiement production"
  only:
    - main

# S'ex√©cute seulement sur les tags
release:
  script:
    - echo "Cr√©ation de release"
  only:
    - tags

# S'ex√©cute partout SAUF sur develop
build:
  script:
    - fpc MonProgramme.pas
  except:
    - develop
```

#### Rules (Syntaxe Moderne et Recommand√©e)

```yaml
# Job avec plusieurs conditions
deploy:
  script:
    - echo "D√©ploiement"
  rules:
    # Si c'est un tag qui commence par 'v', d√©ployer en production
    - if: '$CI_COMMIT_TAG =~ /^v/'
      variables:
        ENVIRONMENT: "production"

    # Si c'est la branche main, d√©ploiement en staging
    - if: '$CI_COMMIT_REF_NAME == "main"'
      variables:
        ENVIRONMENT: "staging"
      when: manual  # N√©cessite confirmation

    # Sinon, ne pas ex√©cuter
    - when: never
```

**Op√©rateurs disponibles :**
- `==` : √©gal
- `!=` : diff√©rent
- `=~` : correspond √† l'expression r√©guli√®re
- `!~` : ne correspond pas

#### Conditions sur les Fichiers Modifi√©s

```yaml
build-documentation:
  script:
    - echo "Build de la doc"
  rules:
    - changes:
        - docs/**/*
        - README.md
      when: always
    - when: never  # N'ex√©cute que si les fichiers docs/* changent
```

---

## Parall√©lisation avec Matrix

### Tester Plusieurs Configurations

```yaml
.build_matrix:
  stage: build
  script:
    - echo "Compilation avec FPC $FPC_VERSION sur $OS"
    - fpc -dVERSION=$FPC_VERSION MonProgramme.pas
  parallel:
    matrix:
      - FPC_VERSION: ["3.2.0", "3.2.2", "3.2.3"]
        OS: ["linux", "windows"]
```

**R√©sultat :** GitLab cr√©e automatiquement **6 jobs** :
1. FPC 3.2.0 + Linux
2. FPC 3.2.0 + Windows
3. FPC 3.2.2 + Linux
4. FPC 3.2.2 + Windows
5. FPC 3.2.3 + Linux
6. FPC 3.2.3 + Windows

### Matrice avec Tags Dynamiques

```yaml
test:
  stage: test
  parallel:
    matrix:
      - PLATFORM: linux
        RUNNER_TAG: linux
      - PLATFORM: windows
        RUNNER_TAG: windows
  tags:
    - $RUNNER_TAG
  script:
    - echo "Test sur $PLATFORM"
    - ./run_tests.sh
```

---

## Pipeline Multi-Projets

### D√©clencher un Pipeline dans un Autre Projet

```yaml
# Projet A : d√©clenche le build de Projet B
trigger-project-b:
  stage: deploy
  trigger:
    project: groupe/projet-b
    branch: main
    strategy: depend  # Attend que le pipeline B se termine
  only:
    - main
```

### Inclure des Configurations Externes

```yaml
# .gitlab-ci.yml principal
include:
  # Fichier local
  - local: '/templates/build-template.yml'

  # Fichier distant
  - remote: 'https://gitlab.com/groupe/ci-templates/-/raw/main/fpc-build.yml'

  # Template GitLab officiel
  - template: 'Security/SAST.gitlab-ci.yml'

stages:
  - build
  - test

# Utiliser les jobs d√©finis dans les templates
```

**Fichier `/templates/build-template.yml` :**

```yaml
.fpc_build:
  before_script:
    - apt-get update && apt-get install -y fpc
  script:
    - fpc -O2 $SOURCE_FILE

build-linux:
  extends: .fpc_build
  variables:
    SOURCE_FILE: "src/MonProgramme.pas"
```

---

## D√©ploiement Avanc√©

### D√©ploiement sur SSH avec Variables

```yaml
deploy-linux-server:
  stage: deploy
  tags:
    - linux
  script:
    # Configurer SSH
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $DEPLOY_HOST >> ~/.ssh/known_hosts

    # D√©ployer
    - scp -r build/* $DEPLOY_USER@$DEPLOY_HOST:/opt/monapp/
    - ssh $DEPLOY_USER@$DEPLOY_HOST "systemctl restart monapp"
  environment:
    name: production
    url: https://monapp.example.com
  only:
    - tags
  when: manual
```

**Variables n√©cessaires (dans Settings ‚Üí CI/CD ‚Üí Variables) :**
- `SSH_PRIVATE_KEY` : Cl√© SSH priv√©e
- `DEPLOY_HOST` : IP ou nom d'h√¥te du serveur
- `DEPLOY_USER` : Nom d'utilisateur SSH

### D√©ploiement Docker avec Registry GitLab

```yaml
variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG

build-docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
  only:
    - main
    - tags

deploy-docker:
  stage: deploy
  image: docker:latest
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker pull $IMAGE_TAG
    - docker stop monapp || true
    - docker rm monapp || true
    - docker run -d --name monapp -p 8080:8080 $IMAGE_TAG
  environment:
    name: production
  only:
    - tags
  when: manual
```

---

## Environnements et D√©ploiements

### D√©finir des Environnements

```yaml
deploy-staging:
  stage: deploy
  script:
    - echo "D√©ploiement sur staging"
  environment:
    name: staging
    url: https://staging.monapp.com
    on_stop: stop-staging
  only:
    - develop

deploy-production:
  stage: deploy
  script:
    - echo "D√©ploiement sur production"
  environment:
    name: production
    url: https://monapp.com
  only:
    - tags
  when: manual

stop-staging:
  stage: deploy
  script:
    - echo "Arr√™t de l'environnement staging"
  environment:
    name: staging
    action: stop
  when: manual
```

**Avantages des environnements :**
- ‚úÖ Historique des d√©ploiements dans l'interface GitLab
- ‚úÖ Liens directs vers les environnements
- ‚úÖ Possibilit√© d'arr√™ter/d√©marrer les environnements
- ‚úÖ Protection des environnements (approval required)

### Visualisation dans GitLab

Dans **Deployments ‚Üí Environments**, vous voyez :
- Liste des environnements (staging, production)
- Historique des d√©ploiements
- Liens vers les URLs
- Boutons pour red√©ployer ou arr√™ter

---

## Optimisation des Pipelines

### R√©duire le Temps d'Ex√©cution

#### 1. Utiliser le Cache Efficacement

```yaml
cache:
  key:
    files:
      - fpc.cfg  # Cl√© bas√©e sur le fichier de config
  paths:
    - .fpc/
    - lib/
  policy: pull-push

build:
  script:
    - fpc -O2 MonProgramme.pas
  cache:
    policy: pull  # Seulement t√©l√©charger, pas mettre √† jour
```

#### 2. Parall√©liser les Jobs Ind√©pendants

```yaml
# Au lieu de :
stages:
  - build-linux
  - build-windows

# Faire :
stages:
  - build  # Les deux builds s'ex√©cutent en parall√®le

build-linux:
  stage: build
  ...

build-windows:
  stage: build
  ...
```

#### 3. Utiliser needs pour Sauter des Stages

```yaml
stages:
  - build
  - test
  - deploy

deploy:
  stage: deploy
  needs: ["build-linux"]  # D√©marre d√®s que build-linux est termin√©
                          # Sans attendre les autres jobs du stage build
  script:
    - echo "D√©ploiement rapide"
```

#### 4. Build Incr√©mental

```yaml
build:
  script:
    - |
      # Ne recompiler que les fichiers modifi√©s
      if [ -f .build_cache/checksums.txt ]; then
        # Logique de build incr√©mental
        fpc -B MonProgramme.pas  # Seulement si n√©cessaire
      else
        fpc -B MonProgramme.pas  # Build complet
      fi
  cache:
    paths:
      - .build_cache/
      - "*.ppu"
      - "*.o"
```

---

## Monitoring et Notifications

### Badges de Statut

Affichez un badge dans votre README pour montrer l'√©tat du pipeline :

**Markdown :**

```markdown
# Mon Projet FreePascal

[![Pipeline Status](https://gitlab.com/username/projet/badges/main/pipeline.svg)](https://gitlab.com/username/projet/-/commits/main)

[![Coverage](https://gitlab.com/username/projet/badges/main/coverage.svg)](https://gitlab.com/username/projet/-/commits/main)
```

**HTML :**

```html
<img src="https://gitlab.com/username/projet/badges/main/pipeline.svg" alt="Pipeline Status">
```

**Badge personnalis√© dans .gitlab-ci.yml :**

```yaml
pages:
  stage: deploy
  script:
    - echo "G√©n√©ration du badge personnalis√©"
    - mkdir -p public
    - echo '{"schemaVersion":1,"label":"FreePascal","message":"3.2.2","color":"blue"}' > public/badge.json
  artifacts:
    paths:
      - public
  only:
    - main
```

Acc√®s au badge : `https://username.gitlab.io/projet/badge.json`

### Notifications Email

GitLab envoie automatiquement des emails, mais vous pouvez personnaliser :

**Fichier .gitlab-ci.yml :**

```yaml
notify-failure:
  stage: .post
  script:
    - |
      curl --request POST --header "PRIVATE-TOKEN: $GITLAB_API_TOKEN" \
      "https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/issues" \
      --form "title=Pipeline $CI_PIPELINE_ID √©chou√©" \
      --form "description=Le pipeline a √©chou√© sur le commit $CI_COMMIT_SHA"
  when: on_failure
  only:
    - main
```

### Int√©gration Slack

```yaml
notify-slack:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      if [ "$CI_JOB_STATUS" = "success" ]; then
        COLOR="good"
        MESSAGE="‚úÖ Pipeline r√©ussi"
      else
        COLOR="danger"
        MESSAGE="‚ùå Pipeline √©chou√©"
      fi

      curl -X POST $SLACK_WEBHOOK_URL \
        -H 'Content-Type: application/json' \
        -d "{
          \"attachments\": [{
            \"color\": \"$COLOR\",
            \"title\": \"$MESSAGE\",
            \"fields\": [
              {\"title\": \"Projet\", \"value\": \"$CI_PROJECT_NAME\", \"short\": true},
              {\"title\": \"Branche\", \"value\": \"$CI_COMMIT_REF_NAME\", \"short\": true},
              {\"title\": \"Commit\", \"value\": \"$CI_COMMIT_SHORT_SHA\", \"short\": true},
              {\"title\": \"Auteur\", \"value\": \"$GITLAB_USER_NAME\", \"short\": true}
            ],
            \"actions\": [{
              \"type\": \"button\",
              \"text\": \"Voir le pipeline\",
              \"url\": \"$CI_PIPELINE_URL\"
            }]
          }]
        }"
  when: always
  only:
    - main
```

**Configuration :**
1. Cr√©ez un webhook Slack
2. Ajoutez-le comme variable : `SLACK_WEBHOOK_URL`

### Int√©gration Discord

```yaml
notify-discord:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      if [ "$CI_JOB_STATUS" = "success" ]; then
        COLOR=3066993  # Vert
        EMOJI="‚úÖ"
      else
        COLOR=15158332  # Rouge
        EMOJI="‚ùå"
      fi

      curl -X POST $DISCORD_WEBHOOK_URL \
        -H 'Content-Type: application/json' \
        -d "{
          \"embeds\": [{
            \"title\": \"$EMOJI Pipeline $CI_PROJECT_NAME\",
            \"description\": \"Branche: $CI_COMMIT_REF_NAME\nCommit: $CI_COMMIT_SHORT_SHA\",
            \"color\": $COLOR,
            \"url\": \"$CI_PIPELINE_URL\",
            \"author\": {
              \"name\": \"$GITLAB_USER_NAME\"
            },
            \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"
          }]
        }"
  when: always
```

### Notifications Microsoft Teams

```yaml
notify-teams:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      curl -X POST $TEAMS_WEBHOOK_URL \
        -H 'Content-Type: application/json' \
        -d "{
          \"@type\": \"MessageCard\",
          \"@context\": \"https://schema.org/extensions\",
          \"summary\": \"Pipeline $CI_PROJECT_NAME\",
          \"themeColor\": \"0078D7\",
          \"title\": \"Pipeline $CI_JOB_STATUS\",
          \"sections\": [{
            \"activityTitle\": \"$CI_PROJECT_NAME\",
            \"facts\": [
              {\"name\": \"Branche\", \"value\": \"$CI_COMMIT_REF_NAME\"},
              {\"name\": \"Commit\", \"value\": \"$CI_COMMIT_SHORT_SHA\"},
              {\"name\": \"Auteur\", \"value\": \"$GITLAB_USER_NAME\"}
            ],
            \"markdown\": true
          }],
          \"potentialAction\": [{
            \"@type\": \"OpenUri\",
            \"name\": \"Voir le pipeline\",
            \"targets\": [{
              \"os\": \"default\",
              \"uri\": \"$CI_PIPELINE_URL\"
            }]
          }]
        }"
  when: always
```

---

## Tests de Performance et Couverture

### Mesure de Couverture de Code

```yaml
test-coverage:
  stage: test
  image: ubuntu:22.04
  before_script:
    - apt-get update
    - apt-get install -y fpc lcov
  script:
    # Compiler avec couverture
    - cd src
    - fpc -Cg -gl MonProgramme.pas

    # Ex√©cuter les tests
    - cd ../tests
    - fpc -Cg -gl -Fu../src TestsSuite.pas
    - ./TestsSuite

    # G√©n√©rer le rapport de couverture
    - lcov --capture --directory . --output-file coverage.info
    - lcov --remove coverage.info '/usr/*' --output-file coverage.info
    - lcov --list coverage.info

    # Extraire le pourcentage
    - COVERAGE=$(lcov --summary coverage.info | grep lines | awk '{print $2}' | sed 's/%//')
    - echo "Couverture de code: $COVERAGE%"
    - echo "COVERAGE=$COVERAGE" >> coverage.env
  coverage: '/lines\.*: \d+\.\d+%/'
  artifacts:
    paths:
      - tests/coverage.info
    reports:
      coverage_report:
        coverage_format: cobertura
        path: tests/coverage.xml
      dotenv: coverage.env
```

**Visualisation dans GitLab :**
- Allez dans **CI/CD ‚Üí Pipelines**
- Cliquez sur un pipeline
- Le pourcentage de couverture s'affiche √† c√¥t√© du job

### Benchmarks et Tests de Performance

```yaml
benchmark:
  stage: test
  tags:
    - performance  # Runner d√©di√© avec ressources garanties
  script:
    - fpc -O3 -Xs src/MonProgramme.pas

    # Ex√©cuter le benchmark
    - ./src/MonProgramme --benchmark > benchmark_results.txt

    # Extraire les m√©triques
    - |
      EXEC_TIME=$(grep "Temps d'ex√©cution:" benchmark_results.txt | awk '{print $3}')
      MEMORY_USAGE=$(grep "M√©moire utilis√©e:" benchmark_results.txt | awk '{print $3}')

      echo "EXEC_TIME=$EXEC_TIME" >> metrics.env
      echo "MEMORY_USAGE=$MEMORY_USAGE" >> metrics.env

      # V√©rifier les seuils
      if (( $(echo "$EXEC_TIME > 10.0" | bc -l) )); then
        echo "‚ö†Ô∏è Performance d√©grad√©e: ${EXEC_TIME}s (seuil: 10s)"
        exit 1
      fi
  artifacts:
    paths:
      - benchmark_results.txt
    reports:
      dotenv: metrics.env
      metrics: metrics.txt
  only:
    - main
    - merge_requests
```

**Fichier metrics.txt (format GitLab) :**

```yaml
# G√©n√©r√© automatiquement
deploy:
  script:
    - |
      cat > metrics.txt << EOF
      # TYPE execution_time gauge
      # UNIT execution_time seconds
      execution_time $EXEC_TIME

      # TYPE memory_usage gauge
      # UNIT memory_usage megabytes
      memory_usage $MEMORY_USAGE
      EOF
```

---

## S√©curit√© et Analyse de Code

### SAST (Static Application Security Testing)

GitLab propose des analyses de s√©curit√© int√©gr√©es :

```yaml
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml

# Personnaliser l'analyse SAST
sast:
  variables:
    SAST_EXCLUDED_PATHS: "tests/,docs/"
```

### Analyse Personnalis√©e pour FreePascal

```yaml
code-quality:
  stage: test
  image: ubuntu:22.04
  before_script:
    - apt-get update
    - apt-get install -y fpc shellcheck
  script:
    # V√©rifier la syntaxe de tous les fichiers Pascal
    - |
      echo "V√©rification syntaxe Pascal..."
      find src -name "*.pas" -exec fpc -S {} \; 2>&1 | tee syntax_check.log
      if grep -q "Error:" syntax_check.log; then
        echo "‚ùå Erreurs de syntaxe d√©tect√©es"
        exit 1
      fi

    # Rechercher les patterns dangereux
    - |
      echo "Recherche de patterns dangereux..."

      # Commandes shell non s√©curis√©es
      if grep -r "ShellExecute\|Exec\|System(" src/; then
        echo "‚ö†Ô∏è Utilisation de commandes shell - v√©rifier la s√©curit√©"
      fi

      # Fuites m√©moire potentielles
      if grep -r "GetMem\|New(" src/ | grep -v -E "FreeMem|Dispose"; then
        echo "‚ö†Ô∏è Allocations m√©moire potentiellement non lib√©r√©es"
      fi

    # Complexit√© du code
    - |
      echo "Analyse de complexit√©..."
      for file in src/*.pas; do
        # Compter les lignes par fonction
        awk '/^(function|procedure)/{start=NR; name=$2}
             /^end;/{
               if (NR-start > 100) {
                 print FILENAME ":" start " - Fonction " name " trop longue (" NR-start " lignes)"
               }
             }' "$file"
      done
  artifacts:
    paths:
      - syntax_check.log
    expire_in: 1 week
```

### Scan des D√©pendances

```yaml
dependency-check:
  stage: test
  image: ubuntu:22.04
  script:
    - |
      echo "V√©rification des versions de biblioth√®ques..."

      # Lister les uses dans le code
      find src -name "*.pas" -exec grep -h "^uses" {} \; | sort -u > dependencies.txt

      # V√©rifier les versions connues avec vuln√©rabilit√©s
      # (n√©cessite une base de donn√©es de vuln√©rabilit√©s)

      cat dependencies.txt
  artifacts:
    paths:
      - dependencies.txt
```

---

## Pipelines Multi-Projets et Monorepo

### Pipeline pour Monorepo

Structure du projet :

```
monorepo/
‚îú‚îÄ‚îÄ .gitlab-ci.yml
‚îú‚îÄ‚îÄ projet-a/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ .gitlab-ci.yml
‚îú‚îÄ‚îÄ projet-b/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ .gitlab-ci.yml
‚îî‚îÄ‚îÄ shared/
    ‚îî‚îÄ‚îÄ lib/
```

**Fichier racine .gitlab-ci.yml :**

```yaml
stages:
  - build
  - test
  - deploy

# Inclure les pipelines des sous-projets
include:
  - local: '/projet-a/.gitlab-ci.yml'
  - local: '/projet-b/.gitlab-ci.yml'

# Build seulement si les fichiers du projet ont chang√©
.build-template:
  stage: build
  script:
    - cd $PROJECT_DIR
    - fpc -O2 src/Main.pas
  artifacts:
    paths:
      - $PROJECT_DIR/Main*

build-projet-a:
  extends: .build-template
  variables:
    PROJECT_DIR: "projet-a"
  rules:
    - changes:
        - projet-a/**/*
        - shared/**/*
      when: always
    - when: never

build-projet-b:
  extends: .build-template
  variables:
    PROJECT_DIR: "projet-b"
  rules:
    - changes:
        - projet-b/**/*
        - shared/**/*
      when: always
    - when: never
```

### D√©clenchement de Pipelines en Cascade

**Projet parent :**

```yaml
trigger-child-pipeline:
  stage: deploy
  trigger:
    project: groupe/projet-enfant
    branch: main
    strategy: depend  # Attend la fin du pipeline enfant
  variables:
    PARENT_VERSION: $CI_COMMIT_TAG
    DEPLOY_ENV: production
  only:
    - tags
```

**Projet enfant :**

```yaml
build-child:
  stage: build
  script:
    - echo "Build d√©clench√© par parent"
    - echo "Version parent: $PARENT_VERSION"
    - echo "Environnement: $DEPLOY_ENV"
    - fpc -dVERSION=$PARENT_VERSION src/Child.pas
```

---

## Gestion des Releases Automatiques

### Cr√©ation de Release avec Changelog

```yaml
release:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'  # Tags semver uniquement
  script:
    - echo "Cr√©ation de la release $CI_COMMIT_TAG"
  release:
    tag_name: '$CI_COMMIT_TAG'
    name: 'Release $CI_COMMIT_TAG'
    description: |
      ## Changements dans $CI_COMMIT_TAG

      $(git log $(git describe --tags --abbrev=0 HEAD^)..HEAD --pretty=format:"- %s (%h)" --no-merges)

      ## T√©l√©chargements

      - [Linux (x64)](https://gitlab.com/$CI_PROJECT_PATH/-/jobs/artifacts/$CI_COMMIT_TAG/raw/MonProgramme?job=build-linux)
      - [Windows (x64)](https://gitlab.com/$CI_PROJECT_PATH/-/jobs/artifacts/$CI_COMMIT_TAG/raw/MonProgramme.exe?job=build-windows)
    assets:
      links:
        - name: 'Linux Binary'
          url: 'https://gitlab.com/$CI_PROJECT_PATH/-/jobs/artifacts/$CI_COMMIT_TAG/raw/MonProgramme?job=build-linux'
          link_type: 'package'
        - name: 'Windows Binary'
          url: 'https://gitlab.com/$CI_PROJECT_PATH/-/jobs/artifacts/$CI_COMMIT_TAG/raw/MonProgramme.exe?job=build-windows'
          link_type: 'package'
```

### G√©n√©ration Automatique du Changelog

```yaml
generate-changelog:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      # R√©cup√©rer le tag pr√©c√©dent
      PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

      # G√©n√©rer le changelog
      cat > CHANGELOG.md << EOF
      # Changelog

      ## [$CI_COMMIT_TAG] - $(date +%Y-%m-%d)

      ### Features
      $(git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s" --grep="^feat:" --no-merges)

      ### Bug Fixes
      $(git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s" --grep="^fix:" --no-merges)

      ### Breaking Changes
      $(git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s" --grep="^BREAKING CHANGE:" --no-merges)
      EOF

      cat CHANGELOG.md
  artifacts:
    paths:
      - CHANGELOG.md
  only:
    - tags
```

---

## Configuration Avanc√©e des Runners

### Runner avec Docker-in-Docker

Pour builder des images Docker dans GitLab CI :

```yaml
build-docker-image:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  before_script:
    - docker info
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
  only:
    - tags
```

### Runner avec Cache Distribu√© (S3)

**Configuration du runner (`/etc/gitlab-runner/config.toml`) :**

```toml
[[runners]]
  [runners.cache]
    Type = "s3"
    Shared = true
    [runners.cache.s3]
      ServerAddress = "s3.amazonaws.com"
      AccessKey = "VOTRE_ACCESS_KEY"
      SecretKey = "VOTRE_SECRET_KEY"
      BucketName = "gitlab-runner-cache"
      BucketLocation = "eu-west-1"
```

**Pipeline avec cache S3 :**

```yaml
variables:
  CACHE_S3_BUCKET: "gitlab-runner-cache"

build:
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - .fpc/
      - lib/
    policy: pull-push
  script:
    - fpc -O2 MonProgramme.pas
```

### Configuration Multi-Runner

**Fichier config.toml avec plusieurs runners :**

```toml
concurrent = 10  # Nombre de jobs simultan√©s total

# Runner Linux avec Docker
[[runners]]
  name = "Linux Docker Builder"
  url = "https://gitlab.com"
  token = "TOKEN_LINUX"
  executor = "docker"
  [runners.docker]
    image = "ubuntu:22.04"
    privileged = false
    volumes = ["/cache"]

# Runner Windows avec Shell
[[runners]]
  name = "Windows Shell Builder"
  url = "https://gitlab.com"
  token = "TOKEN_WINDOWS"
  executor = "shell"
  shell = "powershell"

# Runner de d√©ploiement avec SSH
[[runners]]
  name = "Deployment Runner"
  url = "https://gitlab.com"
  token = "TOKEN_DEPLOY"
  executor = "shell"
  [runners.custom_build_dir]
    enabled = true
```

---

## Debugging et Troubleshooting

### Mode Debug

Activez le mode debug pour voir les commandes exactes ex√©cut√©es :

```yaml
build-debug:
  stage: build
  variables:
    CI_DEBUG_TRACE: "true"  # Active les logs verbeux
  script:
    - echo "Mode debug activ√©"
    - fpc -viwn MonProgramme.pas  # Verbose output
```

### Ex√©cuter un Job Localement

Utilisez `gitlab-runner exec` pour tester localement :

```bash
# Installer gitlab-runner localement
sudo apt install gitlab-runner

# Ex√©cuter un job sp√©cifique
gitlab-runner exec shell build-linux

# Avec des variables
gitlab-runner exec shell build-linux \
  --env "FPC_VERSION=3.2.2"
```

### Job Interactif (Debug Mode)

Activez le mode debug interactif dans l'interface GitLab :

1. Allez dans **CI/CD ‚Üí Pipelines**
2. Cliquez sur "Run pipeline"
3. Cochez "Enable debug mode"
4. Le job cr√©e une session SSH interactive

**Dans le pipeline :**

```yaml
debug-session:
  stage: test
  script:
    - echo "Job de debug"
  when: manual
  timeout: 1h
```

Quand le job s'ex√©cute en mode debug, GitLab affiche :

```
Session is available:
ssh ci-debug-session@gitlab.com -p 22
```

### Inspecter les Artefacts

```yaml
inspect-artifacts:
  stage: .post
  script:
    - echo "Inspection des artefacts pr√©c√©dents"
    - ls -lah
    - find . -type f -name "*.o" -o -name "*.ppu"
  dependencies:
    - build-linux
    - build-windows
  when: on_failure  # S'ex√©cute seulement si un job pr√©c√©dent √©choue
```

---

## Bonnes Pratiques et Conseils

### Checklist de Pipeline de Qualit√©

‚úÖ **Organisation**
- [ ] Stages bien d√©finis (build ‚Üí test ‚Üí deploy)
- [ ] Jobs nomm√©s de mani√®re descriptive
- [ ] Commentaires pour les sections complexes

‚úÖ **Performance**
- [ ] Cache configur√© pour les d√©pendances
- [ ] Jobs ind√©pendants ex√©cut√©s en parall√®le
- [ ] Utilisation de `needs:` pour √©viter les attentes inutiles

‚úÖ **S√©curit√©**
- [ ] Variables sensibles dans CI/CD Settings (masked + protected)
- [ ] Pas de secrets en clair dans .gitlab-ci.yml
- [ ] Runners d√©di√©s pour les d√©ploiements production

‚úÖ **Fiabilit√©**
- [ ] Tests automatiques sur chaque commit
- [ ] D√©ploiement manuel pour la production
- [ ] Retry configur√© pour les jobs instables

‚úÖ **Maintenance**
- [ ] Templates utilis√©s pour √©viter la duplication
- [ ] Versions fixes pour les images Docker
- [ ] Documentation des variables requises

### Optimisations Courantes

#### 1. √âviter les T√©l√©chargements R√©p√©titifs

```yaml
.install_fpc_template: &install_fpc
  before_script:
    - |
      if ! command -v fpc &> /dev/null; then
        apt-get update
        apt-get install -y fpc
      fi
    - fpc -iV

build-linux:
  <<: *install_fpc
  script:
    - fpc MonProgramme.pas
```

#### 2. Build Conditionnel

```yaml
# Ne build que si les sources ont chang√©
build:
  script:
    - fpc MonProgramme.pas
  rules:
    - changes:
        - src/**/*.pas
        - lib/**/*.pas
      when: always
    - when: never
```

#### 3. Nettoyage Automatique

```yaml
.post-cleanup:
  stage: .post
  script:
    - echo "Nettoyage des fichiers temporaires"
    - find . -name "*.o" -delete
    - find . -name "*.ppu" -delete
  when: always
```

### Patterns √† √âviter

‚ùå **Mauvais :**

```yaml
# Tout dans un seul job
build-and-test-and-deploy:
  script:
    - fpc MonProgramme.pas
    - ./run_tests.sh
    - scp MonProgramme server:/opt/app/
```

‚úÖ **Bon :**

```yaml
build:
  stage: build
  script:
    - fpc MonProgramme.pas

test:
  stage: test
  needs: [build]
  script:
    - ./run_tests.sh

deploy:
  stage: deploy
  needs: [test]
  script:
    - scp MonProgramme server:/opt/app/
  when: manual
```

---

## Exemple de Pipeline Complet et Professionnel

```yaml
# .gitlab-ci.yml - Pipeline FreePascal Multi-OS Complet

# ============================================
# CONFIGURATION GLOBALE
# ============================================

image: ubuntu:22.04

stages:
  - .pre
  - build
  - test
  - quality
  - package
  - deploy
  - .post

variables:
  FPC_VERSION: "3.2.2"
  BUILD_DIR: "build"
  ARTIFACTS_EXPIRE: "30 days"

# Template de build commun
.build_template:
  stage: build
  script:
    - mkdir -p $BUILD_DIR
    - cd src
    - fpc -O2 -gl -FU../$BUILD_DIR -FE../$BUILD_DIR Main.pas
  artifacts:
    paths:
      - $BUILD_DIR/
    expire_in: $ARTIFACTS_EXPIRE

# ============================================
# STAGE: .pre (Pr√©paration)
# ============================================

check-version:
  stage: .pre
  script:
    - echo "Pipeline pour commit $CI_COMMIT_SHORT_SHA"
    - echo "Branche: $CI_COMMIT_REF_NAME"
    - if [ -n "$CI_COMMIT_TAG" ]; then echo "Tag: $CI_COMMIT_TAG"; fi

# ============================================
# STAGE: build
# ============================================

build-linux:
  extends: .build_template
  image: ubuntu:22.04
  tags:
    - docker
  before_script:
    - apt-get update
    - apt-get install -y fpc
    - fpc -iV

build-windows:
  extends: .build_template
  tags:
    - windows
    - shell
  before_script:
    - choco install freepascal -y
    - fpc -iV

# ============================================
# STAGE: test
# ============================================

test-unit:
  stage: test
  image: ubuntu:22.04
  dependencies:
    - build-linux
  before_script:
    - apt-get update && apt-get install -y fpc
  script:
    - cd tests
    - fpc -Fu../src -gl TestsSuite.pas
    - ./TestsSuite --format=plain
  coverage: '/lines\.*: \d+\.\d+%/'

test-integration:
  stage: test
  image: ubuntu:22.04
  dependencies:
    - build-linux
  script:
    - chmod +x $BUILD_DIR/Main
    - ./$BUILD_DIR/Main --integration-tests

# ============================================
# STAGE: quality
# ============================================

code-quality:
  stage: quality
  image: ubuntu:22.04
  before_script:
    - apt-get update && apt-get install -y fpc cloc
  script:
    - cloc src/ --md > code_stats.md
    - cat code_stats.md
  artifacts:
    paths:
      - code_stats.md

security-scan:
  stage: quality
  script:
    - echo "Analyse de s√©curit√©..."
    - grep -r "ShellExecute\|System(" src/ || echo "Aucun pattern dangereux"

# ============================================
# STAGE: package
# ============================================

package-linux:
  stage: package
  image: ubuntu:22.04
  dependencies:
    - build-linux
  script:
    - tar -czf MonProgramme-linux-$CI_COMMIT_TAG.tar.gz $BUILD_DIR/
  artifacts:
    paths:
      - MonProgramme-linux-*.tar.gz
  only:
    - tags

package-windows:
  stage: package
  tags:
    - windows
  dependencies:
    - build-windows
  script:
    - Compress-Archive -Path $env:BUILD_DIR\* -DestinationPath MonProgramme-windows-$env:CI_COMMIT_TAG.zip
  artifacts:
    paths:
      - MonProgramme-windows-*.zip
  only:
    - tags

# ============================================
# STAGE: deploy
# ============================================

deploy-staging:
  stage: deploy
  tags:
    - deployment
  dependencies:
    - build-linux
  script:
    - echo "D√©ploiement staging"
    - scp -r $BUILD_DIR/* $STAGING_USER@$STAGING_HOST:/opt/app/
    - ssh $STAGING_USER@$STAGING_HOST "systemctl restart app"
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy-production:
  stage: deploy
  tags:
    - deployment
  dependencies:
    - build-linux
  script:
    - echo "D√©ploiement production"
    - scp -r $BUILD_DIR/* $PROD_USER@$PROD_HOST:/opt/app/
    - ssh $PROD_USER@$PROD_HOST "systemctl restart app"
  environment:
    name: production
    url: https://example.com
  only:
    - tags
  when: manual

# ============================================
# STAGE: .post (Nettoyage et notifications)
# ============================================

notify-success:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      curl -X POST $SLACK_WEBHOOK_URL \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"‚úÖ Pipeline $CI_PROJECT_NAME r√©ussi\"}"
  when: on_success
  only:
    - main
    - tags

notify-failure:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      curl -X POST $SLACK_WEBHOOK_URL \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"‚ùå Pipeline $CI_PROJECT_NAME √©chou√©\"}"
  when: on_failure
```

---

## Conclusion

GitLab CI offre une plateforme puissante et flexible pour l'int√©gration continue de projets FreePascal multi-plateformes.

### Points Cl√©s √† Retenir

**Avantages de GitLab CI pour FreePascal :**

‚úÖ **Flexibilit√© totale**
- Runners personnalis√©s sur vos propres machines
- Support natif Windows, Linux, macOS
- Auto-h√©bergement possible pour un contr√¥le total

‚úÖ **√âcosyst√®me complet**
- Registry Docker int√©gr√©
- Gestion des releases et packages
- Environnements et d√©ploiements track√©s

‚úÖ **Performance**
- Cache distribu√© (local ou S3)
- Parall√©lisation native des jobs
- Optimisations avec `needs:` et matrices

‚úÖ **S√©curit√©**
- Variables masqu√©es et prot√©g√©es
- Runners d√©di√©s par environnement
- Scan de s√©curit√© int√©gr√© (SAST, dependency scanning)

### Comparaison GitLab CI vs GitHub Actions

| Crit√®re | GitLab CI | GitHub Actions |
|---------|-----------|----------------|
| **Fichier config** | `.gitlab-ci.yml` (unique) | `.github/workflows/*.yml` (multiples) |
| **Runners** | Shared + auto-h√©berg√©s faciles | Shared + auto-h√©berg√©s |
| **Minutes gratuites** | 400/mois (SaaS) | 2000/mois |
| **Auto-h√©bergement** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | ‚≠ê‚≠ê‚≠ê Bon |
| **Cache** | Local + S3 | GitHub cache API |
| **Registry** | Int√©gr√© | Int√©gr√© (GHCR) |
| **Environnements** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s complet | ‚≠ê‚≠ê‚≠ê‚≠ê Bon |
| **UI/UX** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | ‚≠ê‚≠ê‚≠ê‚≠ê Bon |
| **Marketplace** | Limit√© | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê √ânorme |

### Workflow Recommand√© pour FreePascal

**Pour un projet professionnel, utilisez cette structure :**

```
Projet FreePascal
‚îú‚îÄ‚îÄ Commits ‚Üí Push
‚îú‚îÄ‚îÄ Pipeline GitLab CI
‚îÇ   ‚îú‚îÄ‚îÄ Stage 1: Build (Linux + Windows en parall√®le)
‚îÇ   ‚îú‚îÄ‚îÄ Stage 2: Tests (unitaires + int√©gration)
‚îÇ   ‚îú‚îÄ‚îÄ Stage 3: Quality (couverture + analyse statique)
‚îÇ   ‚îú‚îÄ‚îÄ Stage 4: Package (cr√©er les archives)
‚îÇ   ‚îî‚îÄ‚îÄ Stage 5: Deploy (staging auto, prod manuel)
‚îú‚îÄ‚îÄ Artefacts sauvegard√©s (30 jours)
‚îú‚îÄ‚îÄ Release cr√©√©e (sur tags)
‚îî‚îÄ‚îÄ Notifications (Slack/Discord)
```

### Conseils Finaux

**1. Commencez Simple**
```yaml
# Version minimale qui fonctionne
stages:
  - build

build:
  script:
    - fpc MonProgramme.pas
```

Puis ajoutez progressivement : tests, multi-OS, cache, d√©ploiement.

**2. Utilisez les Templates**

Cr√©ez des templates r√©utilisables pour √©viter la duplication :

```yaml
.fpc_template:
  before_script:
    - apt-get update && apt-get install -y fpc
  script:
    - fpc $SOURCE_FILE

build-app1:
  extends: .fpc_template
  variables:
    SOURCE_FILE: "app1/Main.pas"
```

**3. Documentez Vos Pipelines**

Ajoutez un README.md dans `.gitlab/` pour expliquer :
- Les variables requises
- Les runners n√©cessaires
- Le workflow de d√©ploiement

**4. Monitorer et Optimiser**

Suivez ces m√©triques :
- Temps d'ex√©cution des pipelines (objectif : <10 minutes)
- Taux de succ√®s (objectif : >95%)
- Consommation de minutes CI/CD
- Taille des artefacts

**5. S√©curisez Vos D√©ploiements**

- Utilisez des runners d√©di√©s pour la production
- Activez les d√©ploiements manuels pour prod
- Prot√©gez les branches main/production
- Limitez l'acc√®s aux variables sensibles

### Ressources Utiles

**Documentation officielle :**
- [GitLab CI/CD Documentation](https://docs.gitlab.com/ee/ci/)
- [GitLab Runner Documentation](https://docs.gitlab.com/runner/)
- [GitLab CI/CD Examples](https://docs.gitlab.com/ee/ci/examples/)

**Communaut√© :**
- [GitLab Forum](https://forum.gitlab.com/)
- [GitLab CI/CD Templates](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates)

**Templates FreePascal :**
- Cr√©ez vos propres templates et partagez-les dans un projet d√©di√©
- R√©utilisez-les avec `include: { project: 'groupe/templates' }`

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez GitLab CI pour FreePascal :

1. **Mettez en place votre premier pipeline** avec build Linux + Windows
2. **Ajoutez des tests automatiques** avec FPCUnit
3. **Configurez un runner auto-h√©berg√©** pour tester sur votre infrastructure
4. **Automatisez vos d√©ploiements** vers staging puis production
5. **Int√©grez les notifications** pour votre √©quipe

Avec GitLab CI, vous disposez d'une infrastructure CI/CD professionnelle, gratuite (en auto-h√©berg√©) et parfaitement adapt√©e au d√©veloppement multi-plateforme FreePascal ! üöÄ

**Bon d√©veloppement et bons pipelines !** ‚ú®

‚è≠Ô∏è [Documentation automatique](/18-tests-qualite-code/10-documentation-automatique.md)
